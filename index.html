<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>è‡ªè»¢è»Šãƒ«ãƒ¼ãƒˆæ¯”è¼ƒï¼‹ä¼‘æ†©ï¼ˆçµ±åˆç‰ˆ å®Œå…¨ï¼‰</title>

<!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map { height: 520px; width: 100%; }
html,body { height: 100%; margin: 0; padding: 0; }
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move;display:flex;justify-content:space-between;align-items:center;gap:8px}
#pointList li small{color:#666}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px;cursor:pointer}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
#routeButtons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
#routeButtons button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#f4f4f4;cursor:pointer}
#routeButtons button.active{background:#dfefff;border-color:#7aa7ff}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.92rem}
</style>
</head>
<body>

<!-- æ“ä½œãƒ‘ãƒãƒ« -->
<div id="controls">
  <input id="placeInput" placeholder="åœ°åãƒ»ä½æ‰€" style="width:260px">
  <button id="searchBtn">æ¤œç´¢</button>
  <button id="drawBtn">ä¼‘æ†©å ´æ‰€æ¤œç´¢</button>
  <button id="solveCombBtn">ãƒ«ãƒ¼ãƒˆæ¤œç´¢</button>

</div>

<!-- â–¼â–¼ åœ°åæ¤œç´¢å€™è£œãƒªã‚¹ãƒˆ â–¼â–¼ -->
<ul id="searchSuggestions"
    style="list-style:none;margin:4px 0;padding:0 8px;background:#fff;
           border:1px solid #ccc;max-height:150px;overflow:auto;">
</ul>

<!-- POI æ¤œç´¢è¨­å®š -->
<div class="section">
  <details open>
  <summary>ä¼‘æ†©åœ°ç‚¹ã¾ã‚ã‚Šã®POI</summary>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <label><input type="checkbox" id="poiToggle" checked> POIè¡¨ç¤º</label>
    <label>åˆæœŸåŠå¾„ <input id="poiRadius" type="number" value="500" min="50" step="50"> m</label>
    <label>ä»¶æ•°ä¸Šé™ï¼ˆè¿‘ã„é †ï¼‰ <input id="poiLimit" type="number" value="5" min="1" step="1"> ä»¶</label>
    <label><input type="checkbox" id="chkConvenience" checked> ã‚³ãƒ³ãƒ“ãƒ‹</label>
    <label><input type="checkbox" id="chkSuper" checked> ã‚¹ãƒ¼ãƒ‘ãƒ¼</label>
    <label><input type="checkbox" id="chkDrug"  checked> ãƒ‰ãƒ©ãƒƒã‚°ã‚¹ãƒˆã‚¢</label>
  </div>
</details>
</div>

<!-- ä¼‘æ†©è¨­å®šãƒ‘ãƒãƒ« -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©è¨­å®š (ãƒˆãƒªã‚¬ãƒ¼ç®—å‡º)</summary>
    
    <div style="margin-bottom:6px; margin-top:8px;">
      <div style="font-weight:bold; color:#555; margin-bottom:4px;">1. åŸºæœ¬åˆ†å‰²ãƒ¢ãƒ¼ãƒ‰:</div>
      <label style="margin-right:8px;"><input type="radio" name="restMode" value="interval" onclick="updateRestUiState()"> è·é›¢é–“éš”</label>
      <label style="margin-right:8px;"><input type="radio" name="restMode" value="count" onclick="updateRestUiState()"> å›æ•°æŒ‡å®š</label>
      <label><input type="radio" name="restMode" value="auto_unit" checked onclick="updateRestUiState()"> å˜ä½ã‹ã‚‰è‡ªå‹•</label>
    </div>

    <div id="input_interval_area" style="display:none; margin-left:10px; margin-bottom:8px;">
      é–“éš”: <input type="number" id="restInterval" value="20" style="width:50px;"> kmã”ã¨
    </div>

    <div id="input_count_area" style="display:none; margin-left:10px; margin-bottom:8px;">
      å›æ•°: <input type="number" id="restCount" value="3" style="width:50px;"> å›
    </div>

    <div id="input_auto_unit_area" style="display:block; margin:4px 0 8px 4px; padding:6px; background:#f0f8ff; border:1px solid #cceeff; border-radius:4px;">
      <div>
        åŸºæº–è·é›¢: <input type="number" id="autoUnitValue" value="20" style="width:50px;" oninput="updateAutoCalcPreview()"> km ã«1å›
      </div>
      <div style="margin-top:4px; font-size:0.9em;">
        ç«¯æ•°å‡¦ç†: 
        <label style="margin-right:6px;"><input type="radio" name="roundingMode" value="round" checked onchange="updateAutoCalcPreview()"> å››æ¨äº”å…¥</label>
        <label style="margin-right:6px;"><input type="radio" name="roundingMode" value="floor" onchange="updateAutoCalcPreview()"> åˆ‡ã‚Šæ¨ã¦</label>
        <label><input type="radio" name="roundingMode" value="ceil" onchange="updateAutoCalcPreview()"> åˆ‡ã‚Šä¸Šã’</label>
      </div>
      <div id="autoCalcPreview" style="margin-top:4px; color:#0055aa; font-weight:bold; font-size:0.9em; border-top:1px dashed #aad; padding-top:2px;">
        (ãƒ«ãƒ¼ãƒˆæ¤œç´¢å¾Œã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼)
      </div>
    </div>

    <div style="margin-top:10px; padding-top:6px; border-top:1px dashed #ccc;">
      <div style="font-weight:bold; color:#555; margin-bottom:4px;">2. è¿½åŠ ãƒˆãƒªã‚¬ãƒ¼:</div>
      
      <div style="margin-bottom:4px;">
        <label><input type="checkbox" id="optPercentTrigger"> å‰²åˆ(%) </label>
        <input id="percentStep" type="number" value="25" style="width:40px;"> %ã”ã¨
        <select id="percentMetric" style="font-size:0.9em;">
          <option value="distance" selected>è·é›¢</option>
          <option value="energy">ã‚¨ãƒãƒ«ã‚®ãƒ¼</option>
          <option value="time">æ™‚é–“</option>
        </select>
      </div>

      <div>
        <label><input type="checkbox" id="optStatTrigger"> çµ±è¨ˆåˆ†å¸ƒ </label>
        <span style="font-size:0.85em; color:#666;">(å¹³å‡<input id="statMean" type="number" value="20" style="width:30px;">km)</span>
      </div>
    </div>

    <div style="margin-top:12px; padding-top:8px; border-top:1px solid #eee;">
      æ¤œç´¢åŠå¾„: <input type="number" id="searchRadius" value="500" style="width:50px;"> m <br>
      POIä»¶æ•°ä¸Šé™: <input type="number" id="poiLimit" value="5" style="width:40px;"> ä»¶/ç®‡æ‰€
    </div>
    
    <div style="margin-top:6px; font-size:0.85em; color:#666;">
      <label><input type="checkbox" id="skipNearGoalToggle" checked> ã‚´ãƒ¼ãƒ«æ‰‹å‰ã‚¹ã‚­ãƒƒãƒ—</label>
      <label><input type="checkbox" id="skipNearNodeToggle" checked> é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—</label>
    </div>

  </details>
</div>

<!-- ä¼‘æ†©ãƒ­ã‚°è¡¨ç¤º -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ»ãƒ’ãƒƒãƒˆçŠ¶æ³</summary>
    <div id="restDebug" style="white-space:pre-wrap;font-size:0.9em"></div>
  </details>
</div>

<!-- â–¼â–¼ ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆè¡¨ç¤º â–¼â–¼ -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆ</summary>
    <ul id="restListPanel"
        style="list-style:none;margin:0;padding:0;font-size:0.9rem"></ul>
  </details>
</div>

<div class="section" style="background:#f0f8ff;">
  <details>
    <summary>æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒï¼ˆä¸€æ‹¬ vs åŒºé–“ç©ä¸Šï¼‰</summary>
    <div style="padding:8px; font-size:0.9rem;">
      <p style="margin:0 0 8px 0;color:#666">å„ãƒˆãƒªã‚¬ãƒ¼ã§çµŒç”±ã™ã‚‹POIã‚’é¸ã‚“ã§æç”»ã—ã¾ã™ã€‚</p>
      
      <button onclick="updateManualRouteUI()" style="margin-bottom:8px;font-size:12px;">ğŸ”„ ãƒªã‚¹ãƒˆãŒç©ºã®å ´åˆã¯ã“ã“ã‚’æŠ¼ã—ã¦æ›´æ–°</button>

      <div id="manualRouteSelectors" style="display:flex;flex-direction:column;gap:6px;margin-bottom:8px;">
        (ä¼‘æ†©å ´æ‰€æ¤œç´¢ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„)
      </div>

      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:8px;">
        <label style="color:#0055aa;font-weight:bold;">
          <input type="checkbox" id="chkManBatch" checked> ä¸€æ‹¬ (API1å›/é’)
        </label>
        <label style="color:#aa0000;font-weight:bold;">
          <input type="checkbox" id="chkManSeg" checked> åŒºé–“ç©ä¸Š (APIè¤‡æ•°å›/èµ¤)
        </label>
      </div>
      
      <button id="btnDrawManualRoute" onclick="drawManualComparison()" style="width:100%;padding:6px;">é¸æŠã—ãŸPOIã§æ¯”è¼ƒæç”»</button>
      <div id="manualRouteInfo" style="margin-top:6px;font-size:0.85rem;white-space:pre-wrap;"></div>
    </div>
  </details>
</div>

<!-- ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼åˆ¥ã®å€™è£œPOI -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼åˆ¥ã®å€™è£œPOI</summary>
    <ol id="restPoiPanel" style="margin:0;padding-left:1.1rem;font-size:0.9rem"></ol>
  </details>
</div>

<!-- åœ°ç‚¹ãƒªã‚¹ãƒˆã¨åœ°å›³ -->
<ul id="pointList"></ul>
<div id="map"></div>

<!-- ãƒ«ãƒ¼ãƒˆæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  -->
<!-- ç›´ç·šè·é›¢ï¼ˆå…¨çµ„ã¿åˆã‚ã›ï¼‰ -->
<div class="section">
  <h3>ç›´ç·šè·é›¢ï¼ˆå…¨çµ„ã¿åˆã‚ã›ï¼‰</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px">
    <button id="btnCalcLinear">ç›´ç·šè·é›¢ã‚’è¨ˆç®—ï¼ˆ1ãƒˆãƒªã‚¬ãƒ¼1ä»¶ Ã— å…¨çµ„åˆã›ï¼‰</button>
    <button id="btnDownloadLinearCsv" disabled>CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  </div>
  <div id="linearSummary" style="font-size:0.9rem;color:#555"></div>
  <div id="linearList" style="font-family:ui-monospace,monospace;white-space:pre;max-height:260px;overflow:auto;border:1px solid #eee;padding:6px"></div>
</div>

<div class="section">
  <label>æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
    <select id="algoSelect">
      <option value="greedy" selected>ç­‰é–“éš”è²ªæ¬²ï¼ˆé«˜é€Ÿãƒ»ã‚¼ãƒ­APIï¼‰</option>
      <option value="beam3">ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ãƒ»ã‚¼ãƒ­APIï¼‰</option>
      <option value="bruteforce">ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰</option>
      <option value="dp">DPï¼ˆæœ€çŸ­è·¯ãƒ»ã‚¼ãƒ­APIï¼‰</option>
    </select>
  </label>
  <small style="color:#666;margin-left:8px">â€»ç·å½“ãŸã‚Šã¯APIåˆ¶é™ã«æ³¨æ„</small>
</div>

<!-- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚° -->
<div class="section">
  <details open>
    <summary>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ï¼ˆç·å½“ãŸã‚Š vs ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼‰</summary>
    <div style="margin:6px 0;">
      <button id="btnAlgoCompare" type="button">
        ç·å½“ãŸã‚Š ã¨ ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ ã‚’æ¯”è¼ƒï¼ˆåŒã˜POIã‚»ãƒƒãƒˆï¼‰
      </button>
      <button id="dbgAlgoCsv" type="button" style="margin-left:8px;">
        Excelç”¨CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      </button>
      <small style="color:#666;display:block;margin-top:4px">
        â€»å…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã§ ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼‹POI ã‚’ä½œã£ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚
      </small>
    </div>
    <pre id="algoComparePanel"
         style="font-family:ui-monospace,monospace;font-size:12px;
                white-space:pre-wrap;border:1px solid #eee;
                padding:6px;max-height:260px;overflow:auto;">
æœªå®Ÿè¡Œ
    </pre>
  </details>
</div>

<div id="viterbiEdgeTools" style="display:flex; gap:8px; flex-wrap:wrap; margin:6px 0; align-items:center;">
  <button id="btnShowViterbiEdges" type="button">Viterbiã‚¨ãƒƒã‚¸è¡¨ç¤º</button>
  <button id="btnHideViterbiEdges" type="button">éè¡¨ç¤º</button>
  <button id="btnDlViterbiEdgesCsv" type="button">CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  <span id="viterbiEdgeStat" style="font-size:12px; color:#666; margin-left:4px;"></span>
</div>

<pre id="viterbiEdgePanel" 
     style="display:none; max-height:260px; overflow:auto; border:1px solid #ccc; padding:6px; background:#fafafa; font-size:11px; font-family:monospace;">
</pre>

<div style="display:flex; flex-direction:column; gap:4px; margin:8px 0; padding:8px; background:#f9f9f9; border:1px solid #ddd; border-radius:4px;">
<div style="display:flex; flex-direction:column; gap:4px; margin:8px 0; padding:8px; background:#f9f9f9; border:1px solid #ddd; border-radius:4px;">
 <div style="font-weight:bold; margin-bottom:4px; color:#555;">æ¯”è¼ƒã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </div>
<label><input type="checkbox" id="dbg_bf" checked> 1. ç·å½“ãŸã‚Š (Ground Truth)</label>
<label><input type="checkbox" id="dbg_vit_pure" checked> 2. ç´”ç²‹Viterbi (é«˜é€Ÿ)</label>
<label><input type="checkbox" id="dbg_vit_pure_rerank" checked> 3. ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯</label>
<label><input type="checkbox" id="dbg_linear"> 4. ç›´ç·šæ¯”è¼ƒ (Zero API)</label>
<label><input type="checkbox" id="dbg_beam"> 5. ç´”ç²‹ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ (Width=5)</label>
<label><input type="checkbox" id="dbg_vit_sg_excl"> 6. SGæ’é™¤ãƒ»ç´”ç²‹Viterbi</label>
<label><input type="checkbox" id="dbg_vit_sg_excl_rerank"> 7. SGæ’é™¤ãƒ»ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯</label>
  <label><input type="checkbox" id="dbg_matrix_bf" checked> 8. ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ç·å½“ãŸã‚Š (æ¨å¥¨)</label>
</div>

<!-- ã‚µãƒãƒªãƒ¼ -->
<div id="summary">
  <div id="routeInfo">æœªè¨ˆç®—</div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒãƒ¼ã®ã©ã“ã‹ã«è¿½åŠ  -->

<script>
/* ====== è¨­å®š ====== */
// const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; 
const ORS_KEY  = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjE0YTgxN2M5OWZmNjQ4MmNiMTZkYTk3YWFkMDI2MDAxIiwiaCI6Im11cm11cjY0In0=';
const ORS_ROOT = 'https://api.openrouteservice.org';

const ORS_INTERVAL = 2500;

/* ====== ãƒ˜ãƒ«ãƒ‘ ====== */
let map, pts=[], markerLayer, routeLayers={}, lastDirTs=0;
let routeData = { shortest:null, fastest:null, slope:null, arterial:null };
let OVERPASS_CALL_TOTAL = 0;  // Overpass API ã®ç´¯è¨ˆå‘¼ã³å‡ºã—å›æ•°

  window.__algoCompareRows = [];
  window.__bruteforceAllResults = [];   // â˜… ç·å½“ãŸã‚Šã®å…¨çµæœã‚’ä¿å­˜ã™ã‚‹é…åˆ—

// æ—¢å­˜ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è¿‘ãã«è¿½åŠ 
let restBeamLayer;   // ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®é“ã®ã‚Šãƒ“ãƒ¼ãƒ ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼

/* ===== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */

// restGroups ã®è¦ç´ ãŒ
// å½¢â‘ : {rest, pois:[...]} ã§ã‚‚ å½¢â‘¡: [...] ã§ã‚‚åŒã˜ã‚ˆã†ã« POIé…åˆ—ã‚’å–ã‚Šå‡ºã™
function getPoisGroup(g){
  if (Array.isArray(g)) return g.filter(Boolean);
  if (g && Array.isArray(g.pois)) return g.pois.filter(Boolean);
  return [];
}

// restGroups(å½¢â‘ /â‘¡ã©ã¡ã‚‰ã§ã‚‚OK) â†’ [ [poi...], [poi...], ... ] ã«çµ±ä¸€ã—ã¦è¿”ã™
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const name = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();
  if (name) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // â† POI{ãƒˆãƒªã‚¬ãƒ¼ID}_{ID}
  return poi;
}

function makeCandGroupsFromRestGroups(restGroups, cap=5, sorter=null){
  return (restGroups || []).map((g, i)=>{
    const arr = getPoisGroup(g);
    if(!arr.length) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã«å€™è£œPOIãŒã‚ã‚Šã¾ã›ã‚“`);

    const out = arr.slice();
    if (typeof sorter === 'function') out.sort(sorter);

    const sliced = out.slice(0, Math.min(cap, out.length));

    // â˜…ã“ã“ã§ç¢ºå®Ÿã«åå‰ã‚’ä»˜ã‘ã‚‹ï¼ˆ0å§‹ã¾ã‚Š & å®‰å®šIDï¼‰
    sliced.forEach((p, b) => {
      // ã™ã§ã« ensureProjections ã§ _triggerId/_poiIdInTrigger ãŒä»˜ã„ã¦ã‚‹ãªã‚‰ãã‚ŒãŒå„ªå…ˆã•ã‚Œã‚‹
      ensurePoiName(p, i, b);
    });

    return sliced;
  });
}

// HTMLè¦ç´ å–å¾—
function $(id){ return document.getElementById(id); }

// CSVç”¨ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
function csvEscape(s){
  return String(s).replace(/"/g, '""');
}

// CSVæ–‡å­—åˆ—ã‚’ä½œã£ã¦ Blob ã‚’è¿”ã™ï¼ˆUTF-8 BOM & CRLFï¼‰
function buildCsvBlob(header, rows){
  const lines = [];
  if (header && header.length) lines.push(header.join(','));
  if (rows && rows.length){
    for (const cols of rows){
      lines.push(cols.join(','));
    }
  }
  const bom = new Uint8Array([0xEF,0xBB,0xBF]);
  const csv = lines.join('\r\n');
  return new Blob([bom, csv], { type: 'text/csv;charset=utf-8' });
}

// Blob ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

// é…åˆ—ã®æ¨™æº–åå·®
function stdDev(arr){
  if (!arr || !arr.length) return 0;
  const m = arr.reduce((a,b)=>a+b, 0) / arr.length;
  const v = arr.reduce((s,x)=> s + (x-m)*(x-m), 0) / arr.length;
  return Math.sqrt(v);
}

/* ==========================================================
   ã€ä¿®æ­£1ã€‘UIåˆ¶å¾¡ãƒ»è‡ªå‹•è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ (åŒºé–“æ•°ãƒ™ãƒ¼ã‚¹ä¿®æ­£ç‰ˆ)
   â€»HTMLã®onclickã‹ã‚‰å‘¼ã°ã‚Œã‚‹ãŸã‚ã€å¿…ãšã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç½®ã„ã¦ãã ã•ã„
   ========================================================== */

// 1. åˆ†å‰²ãƒ¢ãƒ¼ãƒ‰ï¼ˆè·é›¢/å›æ•°/è‡ªå‹•ï¼‰ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
window.updateRestUiState = function() {
  const mode = document.querySelector('input[name="restMode"]:checked')?.value || 'auto_unit';
  
  const divInt = document.getElementById('input_interval_area');
  const divCnt = document.getElementById('input_count_area');
  const divAuto = document.getElementById('input_auto_unit_area');

  if(divInt) divInt.style.display = (mode === 'interval') ? 'block' : 'none';
  if(divCnt) divCnt.style.display = (mode === 'count')    ? 'block' : 'none';
  if(divAuto) divAuto.style.display = (mode === 'auto_unit') ? 'block' : 'none';

  // è‡ªå‹•ãƒ¢ãƒ¼ãƒ‰ãªã‚‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
  if (mode === 'auto_unit') updateAutoCalcPreview();
};

// 2. è‡ªå‹•è¨ˆç®—ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ–‡å­—ï¼ˆä¾‹: "71.1km Ã· 20 = 3.6åŒºé–“ â†’ 3å›"ï¼‰ã‚’æ›´æ–°
window.updateAutoCalcPreview = function() {
  const prevBox = document.getElementById('autoCalcPreview');
  if (!prevBox) return;
  
  // ç´¯ç©ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å…¨é•·ã‚’å–å¾—
  const totalD = (window.__cumTotals && window.__cumTotals.D) ? window.__cumTotals.D : 0;
  const totalKm = totalD / 1000;
  
  if (totalKm <= 0) {
    prevBox.textContent = '(ãƒ«ãƒ¼ãƒˆæ¤œç´¢å¾Œã«è¨ˆç®—å€¤ãŒè¡¨ç¤ºã•ã‚Œã¾ã™)';
    return;
  }

  // è¡¨ç¤ºç”¨ã«è¨ˆç®—éç¨‹ã‚’å–å¾—
  const unitVal = parseFloat(document.getElementById('autoUnitValue')?.value) || 20;
  const rawSegments = (unitVal > 0) ? (totalKm / unitVal) : 0;
  
  const count = calcAutoTriggerCount(totalKm);
  const actualSegments = count + 1;
  const span = (totalKm / actualSegments).toFixed(1);
  
  // ã‚ã‹ã‚Šã‚„ã™ã„è¡¨ç¤ºã«å¤‰æ›´
  prevBox.textContent = `${totalKm.toFixed(1)}kmÃ·${unitVal}km=${rawSegments.toFixed(1)}åŒºé–“ â†’ ä¼‘æ†©${count}å› (ç´„${span}kmé–“éš”)`;
};

// 3. è‡ªå‹•è¨ˆç®—ã®ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ (åŒºé–“æ•°ã‚’ä¸¸ã‚ã¦ -1 ã™ã‚‹)
window.calcAutoTriggerCount = function(totalDistKm) {
  const unitVal = parseFloat(document.getElementById('autoUnitValue')?.value) || 20;
  if (unitVal <= 0) return 1;

  // 1. åŒºé–“æ•°ã‚’è¨ˆç®— (ä¾‹: 71.1 / 20 = 3.555)
  const rawSegments = totalDistKm / unitVal;
  
  // 2. ä¸¸ã‚ã‚‹ (ä¾‹: 3.555 -> 4)
  const roundMode = document.querySelector('input[name="roundingMode"]:checked')?.value || 'round';
  let segments = 0;
  
  if (roundMode === 'floor') {
    segments = Math.floor(rawSegments);
  } else if (roundMode === 'ceil') {
    segments = Math.ceil(rawSegments);
  } else {
    segments = Math.round(rawSegments);
  }

  // 3. ä¼‘æ†©å›æ•°ã¯ã€ŒåŒºé–“æ•° - 1ã€ (ä¾‹: 4åŒºé–“ -> 3å›ä¼‘æ†©)
  let count = segments - 1;

  // å®‰å…¨ã®ãŸã‚1~50å›ã«åˆ¶é™
  return Math.max(1, Math.min(50, count)); 
};
/* ===== ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ»è©•ä¾¡é–¢é€£ ===== */
// ã“ã“ã« comboScore é–¢é€£ / SCORE_METRIC / evalByCums ãªã©
// ã€Œãƒ«ãƒ¼ãƒˆè©•ä¾¡ãƒ»ã‚¹ã‚³ã‚¢ç®—å‡ºã€ã‚’è¡Œã†é–¢æ•°ãŸã¡ã‚’ã¾ã¨ã‚ã¦ç½®ã
  
// ã‚¹ã‚³ã‚¢ï¼ˆå°ã•ã„ã»ã©è‰¯ã„ï¼‰ï¼šè·é›¢/æ™‚é–“/ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ¨™æº–åå·®ã®åˆè¨ˆ
function comboScore(legStats){
  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const metric = getScoreMetric();
  if (metric === 'time')   return sd(legStats.time);
  if (metric === 'energy') return sd(legStats.energy);
  return sd(legStats.dist); // default: distance
}

// picksByTriggerï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ã®é¸æŠï¼‰ã‚’ç´¯ç©ã‹ã‚‰è©•ä¾¡ï¼ˆã‚¼ãƒ­APIï¼‰
function evalByCums(restGroups, picksByTrigger, cumTotals){
  const totalD = Number(cumTotals?.D) || 0;   // m
  const totalT = Number(cumTotals?.T) || 0;   // s
  const totalE = Number(cumTotals?.E) || 0;   // kJ

  // ä¼‘æ†©åˆ†å‰²ã«ã‚ˆã‚‹ã€ŒåŒºåˆ‡ã‚Šã€ã‚’ç´¯ç©è·é›¢ã§ä½œã‚‹
  const cuts = [0];
  (picksByTrigger || []).forEach(p => {
    const v = Number(p?._proj?.cumD);
    if (Number.isFinite(v) && v > 0 && v < totalD) cuts.push(v);
  });
  if (totalD > 0) cuts.push(totalD);

  // åŒºé–“è·é›¢ï¼ˆkmï¼‰
  const dist = [];
  if (cuts.length >= 2){
    cuts.sort((a,b)=>a-b);
    for (let i=1;i<cuts.length;i++){
      const d = (Number(cuts[i]) - Number(cuts[i-1])) / 1000; // km
      if (Number.isFinite(d) && d >= 0) dist.push(d);
    }
  }

  // åŒºé–“æ™‚é–“/ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯è·é›¢æ¯”åˆ†é…ï¼ˆç·é‡ãŒ0ãªã‚‰å‡ç­‰å‰²ï¼‰
  const time = [], energy = [];
  if (dist.length){
    if (totalD > 0 && Number.isFinite(totalD)){
      for (const d of dist){
        const ratio = ((d*1000) / totalD); // 0..1
        time.push((totalT/60) * (Number.isFinite(ratio)? ratio : 0)); // åˆ†
        energy.push(totalE * (Number.isFinite(ratio)? ratio : 0));    // kJ
      }
    } else {
      const eqT = (totalT/60) / dist.length;
      const eqE = (totalE) / dist.length;
      for (let i=0;i<dist.length;i++){ time.push(eqT||0); energy.push(eqE||0); }
    }
  }

  // å®‰å…¨åŒ–
  const finite = a => a.filter(x => Number.isFinite(x));
  const distF = finite(dist), timeF = finite(time), energyF = finite(energy);

  // æ¨™æº–åå·®
  const sd = (a) => {
    if (!a.length) return 0;
    const m = a.reduce((s,v)=>s+v,0) / a.length;
    const v = a.reduce((s,v)=>s+(v-m)*(v-m),0) / a.length;
    return Math.sqrt(v);
  };

  // â˜… å˜ä¸€æŒ‡æ¨™ã‚¹ã‚³ã‚¢ï¼ˆUIã®é¸æŠã«å¾“ã†ï¼‰
  const metric = getScoreMetric();
  const sigmas = { dist: sd(distF), time: sd(timeF), energy: sd(energyF) };
  const score =
      metric === 'time'   ? sigmas.time
    : metric === 'energy' ? sigmas.energy
    :                       sigmas.dist;   // default: distance

  return { stats: { dist: distF, time: timeF, energy: energyF }, score, sigma: sigmas };
}

 /* ===== ã‚¹ã‚³ã‚¢æŒ‡æ¨™ï¼ˆdistance|time|energyï¼‰ ===== */
let SCORE_METRIC = (localStorage.getItem('route_score_metric') || 'distance');


/* ===== ä¼‘æ†©å€™è£œçµ„ã¿åˆã‚ã›æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç¾¤ ===== */
// ç­‰é–“éš”è²ªæ¬² / ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ / DP / ç·å½“ãŸã‚Š ãªã©ã‚’ã“ã“ã«é›†ç´„

/* ===== ç­‰é–“éš”è²ªæ¬²æ³•ï¼ˆä¿®æ­£ç‰ˆï¼‰: å€™è£œãŒã‚ã‚‹å ´åˆã¯å¿…ãšæ¡ç”¨ ===== */
function greedyTopKCandidates(restGroups, cumTotals, K = 3) {
  const R = restGroups.length;
  const groups = [];

  for (let t = 0; t < R; t++) {
    const g = restGroups[t];
    const target = cumTotals.D * (t + 1) / (R + 1); // mï¼ˆè·é›¢åŸºæº–ï¼‰
    let pois = (g && Array.isArray(g.pois)) ? g.pois : [];

    if (!pois.length) {
      groups.push([null]); // ç‰©ç†çš„ã«å€™è£œã‚¼ãƒ­
      continue;
    }
    // â–¼ _proj ãŒç„¡ã„ POI ã«ã¯ã€ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼è·é›¢ã‚’æš«å®šã§å…¥ã‚Œã¦å€™è£œè½ã¡ã‚’é˜²ã
if (g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}
    // --- å°„å½±å€¤ _proj ãŒç„¡ã„å ´åˆã«è£œå®Œ ---
    const needProj = pois.some(p => p && (!p._proj || !Number.isFinite(p._proj.cumD)));
    if (needProj && window.__routeCums) {
      const { cum, coords } = window.__routeCums;
      pois.forEach(p => {
        if (p && (!p._proj || !Number.isFinite(p._proj.cumD))) {
          p._proj = projectToRoute(p.lat, p.lon, coords, cum);
        }
      });
    }

    // --- å°„å½±å€¤ãŒã‚ã‚‹ã‚‚ã®ã‚’å„ªå…ˆ ---
    const withProj = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    let ranked;

    const base = withProj.length ? withProj : pois;
 ranked = base
   .map(p => ({ p, c: nodeCost(p, target) }))
   .sort((a, b) => a.c - b.c)
   .slice(0, K)
   .map(x => x.p);

    // å€™è£œãŒã‚ã‚Œã°å¿…ãšæ¡ç”¨ã€‚ç©ºãªã‚‰ [null]
    groups.push(ranked.length ? ranked : [null]);
  }

  return groups;
}

/* ===== ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆã‚¼ãƒ­APIï¼‰ï¼šå€™è£œã‚ã‚Šã¯å¿…æ¡ç”¨ï¼‹æœªæ¡ç”¨è£œä¿® ===== */
function beamSearch(restGroups, cumTotals, width = 3, minRest = 1, nullPenalty = 1e6, forbidNullWhenCand = true) {
  // beams è¦ç´ : { picks: [...(p or null)], score, pickedCount }
  let beams = [{ picks: [], score: 0, pickedCount: 0 }];

  for (let i = 0; i < restGroups.length; i++){
    const g = restGroups[i];
let pois = (g?.pois || []).slice();

// â–¼ _proj ãŒç„¡ã„/ä¸å®Œå…¨ãª POI ã«ã¯ã€ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã® routeD ã‚’ä½¿ã£ã¦æš«å®šå°„å½±ã‚’ä»˜ä¸
if (pois.length && g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}

// ã“ã“ã‹ã‚‰å…ˆã¯å¾“æ¥ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯
const valid = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
const totalD = Number(cumTotals?.D) || 0;
const target = targetCumDForIndex(i, restGroups.length, totalD);
valid.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));

const cand = valid.length
  ? (forbidNullWhenCand ? valid : [...valid, null])
  : [null];


    const next = [];
    for (const b of beams){
      for (const p of cand){
        const picks = b.picks.concat([p]);

        // ã‚¼ãƒ­APIè¿‘ä¼¼è©•ä¾¡
        const ev = evalByCums(restGroups, picks, cumTotals);
        let s = ev.score;

        // â˜… å€™è£œãŒã‚ã‚‹ã®ã« null ã‚’é¸ã‚“ã å ´åˆã¯å¼·ãƒšãƒŠãƒ«ãƒ†ã‚£
        if (p === null && valid.length){
          s += nullPenalty;
        }

        next.push({
          picks,
          score: Number.isFinite(s) ? s : 0,
          pickedCount: b.pickedCount + (p ? 1 : 0)
        });
      }
    }

    // ã‚¹ã‚³ã‚¢ä¸Šä½ width ä»¶ã®ã¿ä¿æŒ
    next.sort((a,b)=>a.score - b.score);
    beams = next.slice(0, width);
  }

  // â˜… æœ€ä½æ¡ç”¨æ•°ã®åˆ¶ç´„ï¼ˆå€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼åˆ†ã‚’æ¡ç”¨ï¼‰
  let final = beams.filter(b => b.pickedCount >= minRest);
  if (!final.length) final = beams;

  // â˜… æœªæ¡ç”¨(null)ã®â€œè£œä¿®â€ã‚’ã‹ã‘ã¦ã‹ã‚‰æœ€çµ‚ã‚¹ã‚³ã‚¢å†è¨ˆç®—
  final = final.map(b => {
    const fixedPicks = repairNullPicks(restGroups, cumTotals, b.picks);
    const ev = evalByCums(restGroups, fixedPicks, cumTotals);
    return {
      picksByTrigger: fixedPicks,  // â† ä¿®æ­£å¾Œã® picks ã‚’è¿”ã™ï¼ˆä»¥å¾Œã®è¡¨ç¤ºã¯å¿…ãšæ¡ç”¨è¡¨ç¤ºã«ãªã‚‹ï¼‰
      score: ev.score,
      stats: ev.stats
    };
  }).sort((a,b)=>a.score - b.score);

  return final.slice(0, 3);
}

/* ===== DPï¼ˆå±¤ã‚°ãƒ©ãƒ•æœ€çŸ­è·¯ï¼‰ ===== */
// restGroups: [{rest, pois:[p...]}, ...], cumTotals: {D,T,E}
function dpSearch(restGroups, cumTotals){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;

  // å„å±¤ã®å€™è£œï¼ˆ_proj ãŒç„¡ã„ã‚‚ã®ã¯ routeD ã§æš«å®šè£œå®Œï¼‰
  const layers = restGroups.map((g, i) => {
    let pois = (g?.pois || []).slice();
    if (g?.rest && Number.isFinite(g.rest.routeD)) {
      pois.forEach(p => {
        if (!p._proj || !Number.isFinite(p._proj.cumD)) {
          p._proj = { cumD: Number(g.rest.routeD), perpM: Number(p.distFromTriggerM)||0 };
        }
      });
    }
    // ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã™ã‚‹å˜ç‚¹ã‚³ã‚¹ãƒˆï¼ˆä¸¦ã¹æ›¿ãˆã«ã‚‚ä½¿ã†ï¼‰
    const target = targetCumDForIndex(i, R, totalD);
    pois.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));
    return pois;
  });

  // DPãƒ†ãƒ¼ãƒ–ãƒ«
  // dp[i][j] = ç¬¬iå±¤ã§ jç•ªç›®POIã‚’é¸ã‚“ã æ™‚ã®æœ€å°ã‚³ã‚¹ãƒˆ
  // prev[i][j] = ä¸€ã¤å‰ã®å±¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const dp = [], prev = [];
  for (let i=0;i<R;i++) { dp[i] = []; prev[i] = []; }

  // åˆæœŸåŒ–ï¼šã‚¹ã‚¿ãƒ¼ãƒˆâ†’ç¬¬0å±¤ã®å„POIã®ã‚³ã‚¹ãƒˆï¼ˆå˜ç‚¹ã‚³ã‚¹ãƒˆã®ã¿ï¼‰
  const t0 = targetCumDForIndex(0, R, totalD);
  layers[0].forEach((p, j) => {
    dp[0][j] = nodeCost(p, t0);
    prev[0][j] = -1;
  });

  // é·ç§»ï¼šç¬¬i-1å±¤ â†’ ç¬¬iå±¤
  for (let i=1;i<R;i++){
    const ti = targetCumDForIndex(i, R, totalD);
    for (let j=0;j<layers[i].length;j++){
      let best = { cost: Infinity, k: -1 };
      const pj = layers[i][j];

      for (let k=0;k<layers[i-1].length;k++){
        const costPrev = dp[i-1][k];
        if (!Number.isFinite(costPrev)) continue;

        // ã‚¨ãƒƒã‚¸ã‚³ã‚¹ãƒˆï¼ˆåŒºé–“ã®ã€Œç­‰é–“éš”ã‚ºãƒ¬ã€è£œæ­£ã‚’å°‘ã—åŠ ç‚¹ï¼šç´¯ç©è·é›¢ã®å‰å¾Œå·®ãŒç‹­ã™ã/åºƒã™ãã‚’æŠ‘åˆ¶ï¼‰
        const pi = layers[i-1][k];
        const segD = Math.abs((pj?._proj?.cumD||0) - (pi?._proj?.cumD||0)); // m
        const ideal = totalD / (R + 1); // ç†æƒ³åŒºé–“é•·
        const intervalPenalty = Math.abs(segD - ideal) / 1000; // kmå·®åˆ†

        const edge = intervalPenalty * 0.5; // èª¿æ•´ä¿‚æ•°
        const node = nodeCost(pj, ti);

        const cand = costPrev + edge + node;
        if (cand < best.cost){ best = { cost: cand, k }; }
      }
      dp[i][j] = best.cost;
      prev[i][j] = best.k;
    }
  }

  // å¾©å…ƒï¼ˆç¬¬R-1å±¤ã®æœ€å°ã‚³ã‚¹ãƒˆçµ‚ç«¯ã‹ã‚‰è¾¿ã‚‹ï¼‰
  let endJ = -1, bestVal = Infinity;
  for (let j=0;j<layers[R-1].length;j++){
    if (dp[R-1][j] < bestVal){ bestVal = dp[R-1][j]; endJ = j; }
  }
  if (endJ < 0) {
    // ã©ã®å±¤ã«ã‚‚å€™è£œãŒç„¡ã„å ´åˆã®ä¿é™ºï¼šç©ºã§è¿”ã™
    return { picksByTrigger: Array(R).fill(null), stats:{dist:[],time:[],energy:[]}, score: 1e9 };
  }

  const picks = Array(R).fill(null);
  let i = R-1, j = endJ;
  while (i >= 0 && j >= 0){
    picks[i] = layers[i][j];
    j = prev[i][j];
    i--;
  }

  // æ—¢å­˜ã®è¿‘ä¼¼è©•ä¾¡ã§çµ±è¨ˆã‚’ä½œæˆï¼ˆå¯è¦–åŒ–ã®ãŸã‚ï¼‰
  const ev = evalByCums(restGroups, picks, cumTotals);
  return { picksByTrigger: picks, stats: ev.stats, score: ev.score };
}


  
/* ===== è¶…ã‚·ãƒ³ãƒ—ãƒ«ãƒ»ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ© ===== */
// --- PROFILER ã‚’ç„¡åŠ¹åŒ– ---
const PERF = { on:false, rows:[], max:0 };

function perfNow(){ return 0; }
function tStart(name){ return null; }
function tEnd(tok, info){}
function renderPerf(){}
function exportPerfCSV(){}
window.addEventListener('DOMContentLoaded', ()=>{
  const on=$('perfToggle'), reset=$('perfResetBtn'), exp=$('perfExportBtn');
  on && (on.onchange=()=>{ PERF.on = on.checked; });
  reset && (reset.onclick=()=>{ PERF.rows.length=0; renderPerf(); });
  exp && (exp.onclick=exportPerfCSV);
  renderPerf();
});

/* ===== API åˆ©ç”¨ï¼†å¾…æ©Ÿæ™‚é–“ã‚«ã‚¦ãƒ³ã‚¿ ===== */
const API_USED = {
  orsTotal: 0,             // ORS å‘¼ã³å‡ºã—å›æ•°
  orsAtSolveStart: 0,
  lastSolveOrs: 0,

  overpassTotal: 0,        // Overpass å‘¼ã³å‡ºã—å›æ•°
  overpassAtSolveStart: 0,
  lastSolveOverpass: 0,

  waitTotal: 0             // â˜…è¿½åŠ : APIåˆ¶é™ã«ã‚ˆã‚‹å¾…æ©Ÿæ™‚é–“ã®ç´¯è¨ˆ (ms)
};

// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚³ãƒ¼ãƒ‰ â†’ è¡¨ç¤ºç”¨ãƒ©ãƒ™ãƒ«
function algoLabel(code){
  switch(code){
    case 'greedy':     return 'ç­‰é–“éš”è²ªæ¬²ï¼ˆã‚¼ãƒ­APIï¼‰';
    case 'beam3':      return 'ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ãƒ»ã‚¼ãƒ­APIï¼‰';
    case 'bruteforce': return 'ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰';
    case 'dp':         return 'DPï¼ˆæœ€çŸ­è·¯ãƒ»ã‚¼ãƒ­APIï¼‰';
    default:           return code;
  }
}

// ç›´è¿‘ã®æ¢ç´¢çµæœã‚’ UI ã«åæ˜ 
function updateAlgoPerfSummary(algoCode){
  const box = $('algoPerfSummary');
  if (!box) return;

  const targetName = `æ¢ç´¢: ${algoCode}`;
  const rows = [...PERF.rows].reverse();
  const row = rows.find(r => r.name === targetName);
  const msText = row ? `${row.ms.toFixed(1)} ms` : 'ä¸æ˜';

  const ors  = API_USED.lastSolveOrs;
  const ovp  = API_USED.lastSolveOverpass;

  box.innerHTML =
    `ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : <b>${algoLabel(algoCode)}</b><br>` +
    `å‡¦ç†æ™‚é–“: <b>${msText}</b><br>` +
    `ã“ã®æ¢ç´¢ã§ä½¿ç”¨ã—ãŸ ORS Directions API: <b>${ors} å›</b><br>` +
    `ã“ã®æ¢ç´¢ã§ä½¿ç”¨ã—ãŸ Overpass API: <b>${ovp} å›</b><br>` +
    `<small style="color:#777">
      â€»å®Ÿéš›ã® API æ®‹ã‚Šã‚¯ã‚©ãƒ¼ã‚¿ã¯ OpenRouteService / Overpass ã®
      ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®šã«ä¾å­˜ã—ã¾ã™ã€‚ã“ã®ãƒ„ãƒ¼ãƒ«ã§ã¯ã€Œã“ã®ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ã‹ã‚‰
      ä½•å›å‘¼ã‚“ã ã‹ã€ã®æ¦‚ç®—ã®ã¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚
    </small>`;
}



// â–¼â–¼ ä¼‘æ†©ãƒªã‚¹ãƒˆç”¨å¤‰æ•° â–¼â–¼
let restList = []; // ä¼‘æ†©åœ°ç‚¹ã‚’ä¿å­˜
let restGroups = []; 

const ICON = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
const ICONS = {start:ICON('green'),via:ICON('blue'),goal:ICON('red')};

const OVERPASS_MIN_INTERVAL = 1800; // 1.8sï¼ˆå¿…è¦ãªã‚‰ 2000ï½2500 ã¾ã§ä¸Šã’ã¦OKï¼‰
let __overpassLastTs = 0;
const __overpassCache = new Map();  // key=queryæ–‡å­—åˆ—, value=JSON

function formatDist(m){return (m/1000).toFixed(2)+' km';}
function formatDur(s){const m=Math.round(s/60);return m<60? m+' åˆ†' : (Math.floor(m/60)+' æ™‚é–“ '+(m%60)+' åˆ†');}

/* ====== åˆæœŸåŒ– ====== */
window.addEventListener('DOMContentLoaded',()=>{
    const btnCmp = $('btnAlgoCompare');
  if (btnCmp) {
    btnCmp.onclick = runAlgoCompareDebug;
  }
  // â–¼ Excelç”¨CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ç´ä»˜ã‘
  const csvBtn = $('dbgAlgoCsv');
  if (csvBtn) {
    csvBtn.onclick = downloadAlgoCompareCsv;
  }
    // â–¼ ç·å½“ãŸã‚Š å…¨çµ„ã¿åˆã‚ã› CSV ãƒœã‚¿ãƒ³ã®ç´ä»˜ã‘
  const bfCsvBtn = $('btnDownloadBruteforceCsv');
  if (bfCsvBtn) {
    bfCsvBtn.onclick = downloadBruteforceCsv;
  }

  /* ===== è©•ä¾¡ã‚¦ã‚§ã‚¤ãƒˆ UI åˆæœŸåŒ– ===== */
  function reflectWeightsToInputs(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    if(!WA || !WP || !WT) return;
    WA.value = String(SCORE_WEIGHTS.wAlign);
    WP.value = String(SCORE_WEIGHTS.wPerp);
    WT.value = String(SCORE_WEIGHTS.wTrig);
  }

  // â–¼ ã‚¹ã‚³ã‚¢æŒ‡æ¨™ã‚»ãƒ¬ã‚¯ã‚¿ã®åˆæœŸåŒ–
const sm = document.getElementById('scoreMetricSelect');
if (sm) {
  sm.value = SCORE_METRIC;             // ä¿å­˜æ¸ˆã¿ã®é¸æŠã‚’åæ˜ 
  sm.addEventListener('change', ()=>{  // å¤‰æ›´æ™‚ã«ä¿å­˜
    setScoreMetric(sm.value);
    // â€»å¿…è¦ãªã‚‰ç›´è¿‘çµæœã®å†è¡¨ç¤ºã‚’å‘¼ã¶ï¼ˆä¾‹ï¼šæœ€å¾Œã®ãƒˆãƒƒãƒ—3ã‚’ä½œã‚Šç›´ã™ç­‰ï¼‰
  });
}


  function saveWeights(){
    localStorage.setItem('route_score_weights', JSON.stringify(SCORE_WEIGHTS));
  }

  function bindWeightsUI(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    const RB = document.getElementById('btnWeightsReset');

    if(WA){
      WA.addEventListener('input', ()=>{
        const v = Number(WA.value);
        SCORE_WEIGHTS.wAlign = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WP){
      WP.addEventListener('input', ()=>{
        const v = Number(WP.value);
        SCORE_WEIGHTS.wPerp = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WT){
      WT.addEventListener('input', ()=>{
        const v = Number(WT.value);
        SCORE_WEIGHTS.wTrig = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(RB){
      RB.addEventListener('click', ()=>{
        SCORE_WEIGHTS = { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
        saveWeights();
        reflectWeightsToInputs();
      });
    }
  }

  // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åæ˜ ï¼†ãƒã‚¤ãƒ³ãƒ‰
  reflectWeightsToInputs();
  bindWeightsUI();

  
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {attribution:'Â©OpenStreetMap'}).addTo(map);
  restBeamLayer = L.layerGroup().addTo(map);

  // æ¤œç´¢ãƒœã‚¿ãƒ³ï¼šæ¤œç´¢å¾Œã«å…¥åŠ›æ¬„ã‚¯ãƒªã‚¢
  $('searchBtn').onclick = () => {
    const val = $('placeInput').value.trim();
    if (!val) return;
    nomSearch(val);
    $('placeInput').value = ''; // å…¥åŠ›æ¬„ãƒªã‚»ãƒƒãƒˆ
  };
  $('drawBtn').onclick=drawRoutes;

  $('solveCombBtn').onclick = async () => {
     const algoCode = $('algoSelect').value;                // ã©ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‹
  const tkSolveAll = tStart(`æ¢ç´¢: ${algoCode}`);        // å…¨ä½“è¨ˆæ¸¬é–‹å§‹

  // â˜…ã“ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã® API ç´¯è¨ˆå€¤ã‚’è¨˜éŒ²ï¼ˆå·®åˆ†ã‚’è¦‹ã‚‹ãŸã‚ï¼‰
  const prevOrs = API_USED.orsTotal;
  const prevOv  = API_USED.overpassTotal;
  try {
    // 0) å‰æãƒã‚§ãƒƒã‚¯
    if (!routeData.fastest){
      alert('å…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    if (!Array.isArray(restGroups) || !restGroups.length){
      alert('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    if (poiGroups.every(a => !a.length)){
      alert('å„ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã«POIãŒã‚ã‚Šã¾ã›ã‚“ã€‚POIè¨­å®šï¼ˆã‚«ãƒ†ã‚´ãƒª/åŠå¾„/ä»¶æ•°ï¼‰ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    ensureProjections();
    injectAlgoDebugButtons(window.__cumTotals);

    // 1) å…¥åŠ›ï¼†å…±æœ‰ãƒ‡ãƒ¼ã‚¿å–å¾—
    const algo = $('algoSelect').value; // 'greedy' | 'beam3' | 'bruteforce'
    const start = pts.find(p=>p.type==='start') || pts[0];
    const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
    if (!start || !goal){
      alert('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }
    const cumTotals = window.__cumTotals; // drawRoutes() å®Ÿè¡Œå¾Œã« buildCums() ã§è¨­å®šæ¸ˆã¿ã®ç´¯ç©ç·é‡

   // 2) ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ åˆ†å²ï¼ˆâ˜… è¨ˆæ¸¬ãƒ•ãƒƒã‚¯è¿½åŠ ç‰ˆï¼‰
if (algo === 'greedy'){
  const tkG = tStart('æ¢ç´¢: ç­‰é–“éš”è²ªæ¬²');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    // ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¿‘ã„ã€Œä¸Šä½Kå€™è£œã€ã‚’å„ãƒˆãƒªã‚¬ãƒ¼ã‹ã‚‰é›†ã‚ã‚‹
    const K = 3; // ã“ã“ã‚’2ï½5ã§èª¿æ•´å¯
    const candGroups = greedyTopKCandidates(restGroups, cumTotals, K);

    // ç›´ç©ï¼ˆä¸Šé™ã‚’ã‹ã‘ã¦æš´èµ°é˜²æ­¢ï¼‰
    const combos = enumerateCombinations(candGroups, /*perGroupLimit=*/K, /*hardCap=*/60);
    if (!combos.length){
      alert('çµ„ã¿åˆã‚ã›å€™è£œãŒä½œã‚Œã¾ã›ã‚“ã§ã—ãŸï¼ˆå€™è£œä¸è¶³ï¼‰ã€‚');
      return;
    }

    // å…¨å€™è£œã‚’ã€Œç´¯ç©å·®åˆ†ã®è¿‘ä¼¼è©•ä¾¡ã€ã§æ¡ç‚¹ï¼ˆã‚¼ãƒ­APIï¼‰
    const scored = combos.map(cmb => {
      const picksByTrigger = cmb; // nullå«ã‚€ï¼ˆæœªæ¡ç”¨ã‚‚è¨±å®¹ï¼‰
      const ev = evalByCums(restGroups, picksByTrigger, cumTotals); // dist/time/energy ã®Ïƒåˆè¨ˆã§ã‚¹ã‚³ã‚¢
      return {
        score: ev.score,
        stats: ev.stats,
        picksByTrigger,
        picks: picksByTrigger.filter(Boolean)
      };
    });

    // ã‚¹ã‚³ã‚¢æ˜‡é †ã§ä¸Šä½3ä»¶ã‚’è¡¨ç¤º
    scored.sort((a,b)=>a.score-b.score);
    showTop3Combos(scored.slice(0,3));
  } finally {
    // info ã«ã¯ã€Œãƒˆãƒªã‚¬ãƒ¼æ•°ã€ã€Œå€™è£œã®ç·æ•°ã€ã€Œè©¦ã—ãŸã‚³ãƒ³ãƒœæ•°ã€ã‚’å…¥ã‚Œã‚‹ã¨è¦‹ã‚„ã™ã„
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkG, `R=${R}, cand=${totalCand}`);
  }
  return;
}

if (algo === 'beam3'){
  const tkB = tStart('æ¢ç´¢: ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    // ã€Œå€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼æ•°ã€ã¯å¿…ãšæ¡ç”¨ã™ã‚‹
    const triggersWithCand = (restGroups || []).reduce((n, g) => {
      const valid = (g?.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
      return n + (valid.length ? 1 : 0);
    }, 0);

    const width = 3; // ãƒ“ãƒ¼ãƒ å¹…
    const top = beamSearch(restGroups, cumTotals, /*width*/width, /*minRest*/triggersWithCand, /*nullPenalty*/1e6, /*forbidNullWhenCand*/true);
    top.forEach(t => t.picks = t.picksByTrigger.filter(Boolean));
    showTop3Combos(top);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkB, `R=${R}, cand=${totalCand}, width=3`);
  }
  return;
}

if (algo === 'bruteforce'){
  const tkBF = tStart('æ¢ç´¢: ç·å½“ãŸã‚Š');  // â† è¨ˆæ¸¬é–‹å§‹ï¼ˆå…¨ä½“ï¼‰
  try {
    // --- ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰---
    //const perGroupLimit = Math.max(1, Math.min(3, Number($('poiLimit').value)||3)); // å„ãƒˆãƒªã‚¬ãƒ¼æœ€å¤§ä»¶æ•°
    const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    const combos = enumerateCombinations(poiGroups, perGroupLimit, 60);             // ç·å½“ãŸã‚Šä¸Šé™60é€šã‚Š
    if (!combos.length){
      alert('çµ„ã¿åˆã‚ã›å€™è£œãŒä½œã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚');
      return;
    }

    const profile = 'cycling-road'; // ORSãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆcycling-road ç­‰ï¼‰
    const results = [];

    // é€æ¬¡ã§APIè² è·ã‚’æŠ‘ãˆã¤ã¤è©•ä¾¡
    let okCount = 0, failCount = 0;
    for (const cmb of combos){
      const picks = cmb.filter(Boolean); // nullé™¤å¤–
      const wps = [start, ...picks, goal].map(p=>({
        lat: p.lat, lon: p.lon, name: p.name || 'POI'
      }));

      // ï¼ˆä»»æ„ï¼‰1ã‚³ãƒ³ãƒœæ¯ã®è¨ˆæ¸¬ãŒæ¬²ã—ã„ãªã‚‰ã€ã“ã“ã§é–‹å§‹
      const tkOne = tStart('ç·å½“ãŸã‚Š: 1ã‚³ãƒ³ãƒœ');

      try {
        const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);
        const rawScore = comboScore(stats); // è·é›¢/æ™‚é–“/ã‚¨ãƒã®æ¨™æº–åå·®ã®åˆè¨ˆ
        const weights  = picks.map(p => Number(p?._w) || 1);
        const meanW    = weights.length ? (weights.reduce((a,b)=>a+b,0)/weights.length) : 1;
        const score    = rawScore / Math.max(0.1, meanW); // é‡ã¿ãŒé«˜ã„çµ„åˆã›ã‚’å„ªé‡
        results.push({ score, rawScore, feature, picks, picksByTrigger: cmb, stats });
        okCount++;
      } catch(e){
        console.warn('combo route fail', e);
        failCount++;
        // å¤±æ•—ã—ãŸçµ„åˆã›ã¯ã‚¹ã‚­ãƒƒãƒ—
      } finally {
        // 1ã‚³ãƒ³ãƒœã®çµŒéæ™‚é–“ã‚’æ®‹ã—ãŸã„å ´åˆï¼ˆãƒ­ã‚°ãŒå¤šã„ã¨æ„Ÿã˜ãŸã‚‰å¤–ã—ã¦OKï¼‰
        //tEnd(tone, `ok=${okCount}, fail=${failCount}`);
      }
    }

    // ã‚¹ã‚³ã‚¢æ˜‡é †ã«ä¸Šä½3ä»¶
    results.sort((a,b)=>a.score-b.score);
    showTop3Combos(results.slice(0,3));
    // â˜… è¿½åŠ ï¼šç·å½“ãŸã‚Šã®å…¨çµ„ã¿åˆã‚ã›ã‚’ä¿å­˜ï¼†ä¸€è¦§è¡¨ç¤º
    window.__bruteforceAllResults = results;
    renderBruteforceAllResults(results);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkBF, `R=${R}, cand=${totalCand}, cap=60`);
  }
  return;
}

if (algo === 'dp'){
  const tkDP = tStart('æ¢ç´¢: DP');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    const best = dpSearch(restGroups, cumTotals);
    best.picks = best.picksByTrigger.filter(Boolean);
    showTop3Combos([best]);  // DPã¯æœ€é©è§£1æœ¬ã‚’å‡ºã™
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkDP, `R=${R}, cand=${totalCand}`);
  }
  return;
}


    // æœªçŸ¥ã®å€¤ï¼ˆä¿é™ºï¼‰
    alert('æœªçŸ¥ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æŒ‡å®šã§ã™ã€‚');
    } catch (err){
    console.error(err);
    alert('ãƒ«ãƒ¼ãƒˆæ¢ç´¢ã§ã‚¨ãƒ©ãƒ¼: ' + (err.message || err));
  } finally {
    // â˜…ä»Šå›ã®æ¢ç´¢ã§ä½¿ã£ãŸ API å›æ•°ï¼ˆå·®åˆ†ï¼‰ã‚’è¨˜éŒ²
    API_USED.lastSolveOrs      = API_USED.orsTotal      - prevOrs;
    API_USED.lastSolveOverpass = API_USED.overpassTotal - prevOv;

    // è¨ˆæ¸¬çµ‚äº†ï¼ˆPERF ã«è¨˜éŒ²ï¼‰
    tEnd(tkSolveAll);

    // UI ã«åæ˜ 
    updateAlgoPerfSummary(algoCode);
  }
};


  new Sortable($('pointList'),{
    animation:150,
    onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li.dataset.idx]);fixType();drawList();}
  });
});

/* ====== åœ°ç‚¹ç®¡ç† ====== */
function addPoint(p){
  p.type=pts.length?'':'start';
  pts.forEach(d=>{if(d.type==='goal')d.type='via';});
  pts.push(p);
  if(pts.length>1) pts[pts.length-1].type='goal';
  drawList();
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li.dataset.idx=i;
    const name = p.name + (p.isRest? 'ï¼ˆä¼‘æ†©ï¼‰':'');
    li.innerHTML = `<span>${name}${p.isRest? ' <small>(' + p.lat.toFixed(5)+','+p.lon.toFixed(5)+')</small>':''}</span><button class="del">Ã—</button>`;
    li.querySelector('.del').onclick=()=>{pts.splice(i,1); fixType(); drawList();};
    ul.appendChild(li);
  });
}

/* ====== æ¤œç´¢å‡¦ç†ï¼ˆå€™è£œè¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰ ====== */
async function nomSearch(q){
  const url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  const arr=await (await fetch(url)).json();
  const sug=$('searchSuggestions');
  sug.innerHTML='';
  if(!arr.length){alert('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');return;}
  // å€™è£œã‚’ãƒªã‚¹ãƒˆè¡¨ç¤º
  arr.forEach(o=>{
    const li=document.createElement('li');
    li.textContent=o.display_name;
    li.style.cursor='pointer';
    li.style.padding='4px';
    li.onmouseenter=()=>li.style.background='#eee';
    li.onmouseleave=()=>li.style.background='';
    li.onclick=()=>{
      addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
      sug.innerHTML=''; // ã‚¯ãƒªãƒƒã‚¯å¾Œã‚¯ãƒªã‚¢
      $('placeInput').value='';
    };
    sug.appendChild(li);
  });
}


/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ORS API å‘¼ã³å‡ºã— (å¾…æ©Ÿæ™‚é–“è¨ˆæ¸¬å¯¾å¿œ)
   ========================================================== */
async function dir(body, profile) {
  // ç¾åœ¨æ™‚åˆ»ã¨å‰å›ã®å·®åˆ†ã‚’è¨ˆç®—
  const now = Date.now();
  const elapsed = now - lastDirTs;
  const wait = ORS_INTERVAL - elapsed;

  // ã¾ã æ™‚é–“ãŒçµŒã£ã¦ã„ãªã‘ã‚Œã°å¾…æ©Ÿ
  if (wait > 0) {
    // â˜…å¾…æ©Ÿæ™‚é–“ã‚’è¨˜éŒ²
    if (typeof API_USED !== 'undefined') API_USED.waitTotal += wait;
    await new Promise(r => setTimeout(r, wait));
  }

  // â˜… ORS å‘¼ã³å‡ºã—å›æ•°ã‚«ã‚¦ãƒ³ãƒˆ
  if (typeof API_USED !== 'undefined') {
    API_USED.orsTotal++;
  }

  try {
    const d = await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`, body);
    // æˆåŠŸã—ãŸã‚‰æ™‚åˆ»ã‚’æ›´æ–°
    lastDirTs = Date.now();
    return d;
  } catch (e) {
    // ã‚¨ãƒ©ãƒ¼ã§ã‚‚æ™‚åˆ»æ›´æ–°
    lastDirTs = Date.now();
    throw e;
  }
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘APIå‘¼ã³å‡ºã—é–¢æ•° (ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿæ™‚é–“è¨ˆæ¸¬å¯¾å¿œ)
   ========================================================== */
async function post(url, body) {
  const MAX_RETRIES = 5; 
  let delay = 5000;      

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': ORS_KEY
        },
        body: JSON.stringify(body)
      });

      if (r.ok) return await r.json();

      if (r.status === 429) {
        console.warn(`[API] 429 Rate Limit. Waiting ${delay/1000}s...`);
        // â˜…ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿæ™‚é–“ã‚’è¨˜éŒ²
        if (typeof API_USED !== 'undefined') API_USED.waitTotal += delay;
        
        await sleep(delay);
        delay *= 2; 
        continue;   
      }

      let errorMsg = `Error ${r.status}`;
      if (r.status === 403) {
        errorMsg += ': APIã‚­ãƒ¼ç„¡åŠ¹ã¾ãŸã¯ä¸Šé™è¶…é';
      } else {
        try {
          const txt = await r.text();
          errorMsg += `: ${txt}`;
        } catch (e) {}
      }
      throw new Error(errorMsg);

    } catch (e) {
      if (e.message.includes('Error 403')) throw e;
      
      console.warn(`[API] Network/Fetch error. Waiting ${delay/1000}s...`, e);
      // â˜…ã‚¨ãƒ©ãƒ¼ãƒªãƒˆãƒ©ã‚¤å¾…æ©Ÿæ™‚é–“ã‚’è¨˜éŒ²
      if (typeof API_USED !== 'undefined') API_USED.waitTotal += delay;

      await sleep(delay);
      delay *= 2;
    }
  }
  throw new Error(`API Retry limit exceeded after ${MAX_RETRIES} attempts.`);
}
  
/* ====== ãƒ«ãƒ¼ãƒˆè¡¨ç¤ºé–¢é€£ ====== */
function clearRouteLayers(){
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); });
  routeLayers={};
}
function setActiveButton(btn){
  document.querySelectorAll('#routeButtons button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
}
function showSingleRoute(type, noFit){
  clearRouteLayers();
  const colorMap = { shortest:'#ff0000', fastest:'#0066ff', slope:'#ff9900', arterial:'#00b26b' };
  const f = routeData[type];
  if(!f){ alert('ã¾ã è¨ˆç®—ã—ã¦ã„ã¾ã›ã‚“'); return; }
  routeLayers[type] = L.geoJSON(f, { style:{ color: colorMap[type], weight: 6 } }).addTo(map);
  if(!noFit) map.fitBounds(routeLayers[type].getBounds().pad(0.1));
}
function toggleSingleRoute(type, btn){
  showSingleRoute(type);
  setActiveButton(btn);
}

/* ====== ãƒ«ãƒ¼ãƒˆè¨ˆç®—ãƒ»ä¼‘æ†©ãƒ»POI ====== */
async function drawRoutes(){
  if(pts.length<2){alert('2åœ°ç‚¹ä»¥ä¸Šç™»éŒ²ã—ã¦ãã ã•ã„');return;}

  clearRouteLayers();
  if(markerLayer) map.removeLayer(markerLayer);

  markerLayer=L.layerGroup().addTo(map);
  
  pts.forEach(p=>markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ICONS[p.type||'via']}).bindTooltip(p.name)));

  const coords=pts.map(p=>[p.lon,p.lat]);
  const profile = 'cycling-road';
  const base={coordinates:coords,elevation:true,extra_info:['steepness']};

  try{
    const tkORS = tStart('ORS: æœ€çŸ­/æœ€é€Ÿ');
    const shortest = await dir({...base, preference:'shortest'}, profile);
    const fastest  = await dir({...base, preference:'fastest'},  profile);
    tEnd(tkORS, `pts=${pts.length}`);


    let slope = shortest.features[0];
    let arterial = fastest.features[0];
    if(coords.length===2){
      const tkAlt = tStart('ORS: ä»£æ›¿çµŒè·¯');
      const alt = await dir({...base, preference:'shortest',
        alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}, profile);
      tEnd(tkAlt, `alts=${(alt.features||[]).length}`);

      const feats = alt.features || [];
      if(feats.length){
        function steepSum(f){
          const vals=((f.properties||{}).extras||{}).steepness?.values||[];
          let s=0; for(const v of vals){ s+=Math.abs(v[2]||0); }
          return s;
        }
        slope = feats.reduce((a,b)=> steepSum(a)<steepSum(b)?a:b);
        // å¹¹ç·šå„ªå…ˆï¼ˆä»£æ›¿çµŒè·¯ï¼‹fastest ã®ä¸­ã‹ã‚‰ã‚¹ã‚³ã‚¢æœ€å¤§ï¼‰
        arterial = feats.concat(fastest.features || [])
        .reduce((best,cand)=> arterialScore(cand) > arterialScore(best) ? cand : best, arterial);
      }
    }

    routeData.shortest = shortest.features[0];
    routeData.fastest  = fastest.features[0];
    routeData.slope    = slope;
    routeData.arterial = arterial;

    const s1 = routeData.shortest.properties.summary;
    const s2 = routeData.fastest.properties.summary;
    const s3 = routeData.slope.properties.summary;
    $('routeInfo').innerHTML =
      `<b>æœ€çŸ­</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>æœ€é€Ÿ</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>å‹¾é…</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}<br>`+
      (routeData.arterial ? `<b>å¹¹ç·š</b> ${formatDist(routeData.arterial.properties.summary.distance)} / ${formatDur(routeData.arterial.properties.summary.duration)}` : '');
    $('distanceScore').textContent = 'è·é›¢å·®ï¼ˆæœ€é€Ÿ-æœ€çŸ­ï¼‰: '+(s2.distance - s1.distance).toFixed(0)+' m';

    /* ===== ä¼‘æ†©åœ°ç‚¹æŒ¿å…¥ ===== */
    const mass = 75; // ä½“é‡+ãƒã‚¤ã‚¯è³ªé‡(ä¾‹)
    const flat = 18; // å¹³å¦ä¿‚æ•°
    const baseFeature = routeData.arterial || routeData.fastest;
    const tkRest = tStart('ä¼‘æ†©ãƒˆãƒªã‚¬ç”Ÿæˆ');
    const rests = await makeRestPoints(baseFeature, mass, flat);
    tEnd(tkRest, `hits=${rests.length}`);


    restGroups = (rests || []).map(r => ({ rest: r, pois: [] }));

    restList = []; // å‰å›ã®ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ

    if (rests.length) {
      // ãƒªã‚¹ãƒˆã«æŒ¿å…¥ï¼ˆã‚´ãƒ¼ãƒ«ç›´å‰ï¼‰
      rests.forEach(r => {
        pts.splice(pts.length-1, 0,
                  { name:'ä¼‘æ†©', lat:r.lat, lon:r.lon, type:'via', isRest:true });
        // â–¼ r ãŒæœ‰åŠ¹ãªã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ push
        restList.push({distance:(r.routeD/1000).toFixed(2), lat:r.lat, lon:r.lon});
      });
      drawList();
      updateRestListPanel(); // ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆè¡¨ç¤ºæ›´æ–°

      // ä¼‘æ†©ãƒãƒ¼ã‚«ãƒ¼
      for (const r of rests) {
        L.marker([r.lat, r.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/yellow-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        }).bindTooltip('ä¼‘æ†©').addTo(markerLayer);
      }

      // POIæ¤œç´¢ï¼ˆåŠå¾„å›ºå®šãƒ»è¿‘ã„é †ã« n ä»¶ï¼‰
      if ($('poiToggle').checked) {
        const baseRadius = Number($('poiRadius').value) || 500;
        const limit = Math.max(1, Number($('poiLimit').value) || 5);
        // â˜… ã“ã“ã§ä»Šå›ã®ä¼‘æ†©å ´æ‰€æ¤œç´¢é–‹å§‹æ™‚ç‚¹ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨˜éŒ²
        const overpassBefore = OVERPASS_CALL_TOTAL;

        for (let idx = 0; idx < rests.length; idx++) {
          const r = rests[idx];
          
          // â˜…â˜…â˜… è¿½åŠ å¯¾ç­–ï¼šå‰ã®æ¤œç´¢ã‹ã‚‰å¿…ãš3ç§’ç©ºã‘ã‚‹ï¼ˆOverpassè² è·è»½æ¸›ï¼‰ â˜…â˜…â˜…
          if (idx > 0) {
             await new Promise(res => setTimeout(res, 3000));
          }

          try {
            const tkPOI = tStart(`POI#${idx+1}`);
            const pois = await fetchPoisAround(r.lat, r.lon, baseRadius, limit);
            tEnd(tkPOI, `found=${pois.length}`);

            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: åŠå¾„${baseRadius}m â†’ ${pois.length}ä»¶ï¼ˆè¿‘ã„é †ï¼‰`);

            // â–¼ è¿½åŠ ï¼šã“ã®ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã®POIã‚’ä¿å­˜
            if (restGroups[idx]) {
              restGroups[idx].pois = pois.map(p => ({ ...p, triggerIndex: idx }));
            }
              
            // æ—¢å­˜ï¼šãƒãƒƒãƒ—ã«æç”»
            pois.forEach(po => {
              L.marker([po.lat, po.lon], {
                icon: new L.Icon({
                  iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple.png',
                  iconSize: [24, 24],
                  iconAnchor: [12, 24]
                })
              }).bindTooltip(`${po.name}${typeof po.distFromTriggerM === 'number' ? ` (${formatDist(po.distFromTriggerM)})` : ''}`).addTo(markerLayer);
            });
          } catch (e) {
            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: å–å¾—å¤±æ•—`);
          }
        }

        //ãƒ‘ãƒãƒ«ã¸åæ˜ 
        ensureProjections();
        updateRestPoiPanel();
        // â˜… ã“ã“ã§ä»Šå›ä½¿ã£ãŸå›æ•°ã¨ç´¯è¨ˆã‚’ã€Œæœ€å¾Œã®è¡Œã€ã¨ã—ã¦å‡ºã™
        const usedThisTime = OVERPASS_CALL_TOTAL - overpassBefore;
        logRest(`--- Overpass API å‘¼ã³å‡ºã—: ä»Šå› ${usedThisTime} å› / ç´¯è¨ˆ ${OVERPASS_CALL_TOTAL} å› ---`);
      }

    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºã¯å¹¹ç·šå„ªå…ˆï¼ˆãªã‘ã‚Œã°æœ€é€Ÿï¼‰
    const prefer = routeData.arterial ? 'arterial' : 'fastest';
    showSingleRoute(prefer, true);
    setActiveButton(prefer === 'arterial' ? $('btnShowArterial') : $('btnShowFastest'));

  }catch(e){
    console.error(e);
    alert('ãƒ«ãƒ¼ãƒˆå–å¾—å¤±æ•—: '+e.message);
  }
}

/* ===== ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼é–¢é€£ ===== */
function logRest(msg){ $('restDebug').textContent += msg + "\n"; }
function energyStepKJ(dist,dz,mass,flat=18){
  return flat*(dist/1000)+Math.max(dz,0)*mass*9.80665/1000;
}
async function totalEnergyKJ(feature,mass,flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments||[];
  let tot=0;
  for(const s of segs){
    for(const st of s.steps||[]){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz = coords[i1].length>=3 ? (coords[i1][2]-coords[i0][2]) : 0;
      tot += energyStepKJ(d,dz,mass,flat);
    }
  }
  return tot;
}
/* ==========================================================
   ã€å®Œå…¨ä¿®æ­£ç‰ˆã€‘ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ç”Ÿæˆ
   â€»è¨ˆç®—çµæœãŒNaNã«ãªã£ãŸåœ°ç‚¹ã¯ã€ãƒªã‚¹ãƒˆã«è¿½åŠ ã›ãšå®Œå…¨ã«ç„¡è¦–ã—ã¾ã™ã€‚
   ========================================================== */
async function makeRestPoints(feature, mass, flat) {
  const coords = feature.geometry.coordinates;
  const totalD = feature.properties.summary.distance || 0; 
  const totalE = await totalEnergyKJ(feature, mass, flat); 

  // 1. ç´¯ç©è·é›¢ã®è¨ˆç®—
  const cumDist = [0];
  for(let i=1; i<coords.length; i++){
    // GeoJSONã¯ [lon, lat]
    const p1 = L.latLng(coords[i][1], coords[i][0]);
    const p2 = L.latLng(coords[i-1][1], coords[i-1][0]);
    cumDist[i] = cumDist[i-1] + p1.distanceTo(p2);
  }

  // 2. ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã‚‹åˆ†å‰²ç‚¹æ±ºå®š
  const mode = document.querySelector('input[name="restMode"]:checked')?.value || 'auto_unit';
  let triggerDistancesM = [];

  if (mode === 'interval') {
    const intervalKm = parseFloat(document.getElementById('restInterval').value) || 20;
    const intervalM = intervalKm * 1000;
    for (let d = intervalM; d < totalD - 500; d += intervalM) {
      triggerDistancesM.push(d);
    }
    logRest(`[åŸºæœ¬] è·é›¢å›ºå®š: ${intervalKm}kmã”ã¨ â†’ ${triggerDistancesM.length}ç®‡æ‰€`);

  } else {
    let count = 0;
    if (mode === 'count') {
      count = parseInt(document.getElementById('restCount').value) || 3;
      logRest(`[åŸºæœ¬] å›æ•°æŒ‡å®š: ${count}å› â†’ ç­‰é–“éš”é…ç½®`);
    } else {
      // è‡ªå‹•è¨ˆç®—ï¼ˆåŒºé–“æ•° - 1ï¼‰
      const totalKm = totalD / 1000;
      const unitVal = parseFloat(document.getElementById('autoUnitValue')?.value) || 20;
      const rawSegments = (unitVal > 0) ? (totalKm / unitVal) : 0;
      
      count = (typeof calcAutoTriggerCount === 'function') 
              ? calcAutoTriggerCount(totalKm) 
              : Math.max(1, Math.round(rawSegments) - 1);
      
      const actualSegments = count + 1;
      const actualInterval = totalKm / actualSegments;
      logRest(`[åŸºæœ¬] è‡ªå‹•è¨ˆç®—: ${totalKm.toFixed(1)}km / ${unitVal}km = ${rawSegments.toFixed(1)}åŒºé–“`);
      logRest(`      â†³ ${actualSegments}åŒºé–“ (ä¼‘æ†©${count}å›) / ç´„${actualInterval.toFixed(1)}kmé–“éš”`);
    }

    if (count > 0) {
      const legM = totalD / (count + 1);
      for (let i = 1; i <= count; i++) {
        triggerDistancesM.push(legM * i);
      }
    }
  }

  // 3. è¿½åŠ ãƒˆãƒªã‚¬ãƒ¼
  if (document.getElementById('optPercentTrigger')?.checked) {
    const step = parseFloat(document.getElementById('percentStep').value) || 25;
    let added = 0;
    for (let p = step; p < 100; p += step) {
      const ratio = p / 100.0;
      let targetM = totalD * ratio;
      if (targetM > 500 && targetM < totalD - 500) {
        triggerDistancesM.push(targetM);
        added++;
      }
    }
    if(added > 0) logRest(`[è¿½åŠ ] å‰²åˆãƒˆãƒªã‚¬ãƒ¼ (${step}%) â†’ +${added}ç®‡æ‰€`);
  }

  if (document.getElementById('optStatTrigger')?.checked) {
    const meanKm = parseFloat(document.getElementById('statMean').value) || 20;
    const meanM = meanKm * 1000;
    let added = 0;
    for (let d = meanM; d < totalD - 500; d += meanM) {
      triggerDistancesM.push(d);
      added++;
    }
    if(added > 0) logRest(`[è¿½åŠ ] çµ±è¨ˆãƒˆãƒªã‚¬ãƒ¼ (å¹³å‡${meanKm}km) â†’ +${added}ç®‡æ‰€`);
  }

  triggerDistancesM.sort((a, b) => a - b);
  
  const uniqueDistances = [];
  if (triggerDistancesM.length > 0) {
    uniqueDistances.push(triggerDistancesM[0]);
    for (let i = 1; i < triggerDistancesM.length; i++) {
      if (triggerDistancesM[i] - uniqueDistances[uniqueDistances.length-1] > 500) {
        uniqueDistances.push(triggerDistancesM[i]);
      }
    }
  }

  // 4. åº§æ¨™ç‰¹å®š & ã‚¨ãƒ©ãƒ¼æ’é™¤ (â˜…ã“ã“ãŒé‡è¦)
  const results = [];
  const skipGoalOn = document.getElementById('skipNearGoalToggle')?.checked;
  const skipNodeOn = document.getElementById('skipNearNodeToggle')?.checked;
  const skipGoalKm = parseFloat(document.getElementById('skipNearGoalKm')?.value) || 1.0;
  const skipNodeM  = parseFloat(document.getElementById('skipNearNodeM')?.value)  || 150;

  const isNearNode = (lat, lon) => {
    if (!pts || !pts.length) return false;
    const p1 = L.latLng(lat, lon);
    return pts.some(p => !p.isRest && p1.distanceTo([p.lat, p.lon]) < skipNodeM);
  };

  for (const distM of uniqueDistances) {
    if (skipGoalOn && (totalD - distM) < skipGoalKm * 1000) {
      logRest(`[ã‚¹ã‚­ãƒƒãƒ—] ã‚´ãƒ¼ãƒ«ã¾ã§ ${(totalD - distM).toFixed(0)}m`);
      continue;
    }

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç‰¹å®šï¼ˆç¯„å›²å¤–å‚ç…§ã‚’é˜²ãï¼‰
    let idx = cumDist.findIndex(d => d >= distM);
    if (idx === -1) idx = cumDist.length - 1; 
    if (idx < 1) idx = 1; // idx-1 ãŒ -1 ã«ãªã‚‹ã®ã‚’é˜²ã
    
    const prevD = cumDist[idx-1];
    const nextD = cumDist[idx];
    const segmentLen = nextD - prevD;
    
    let lat = coords[idx][1];
    let lon = coords[idx][0];

    // ç·šå½¢è£œé–“
    if (segmentLen > 0) {
      const ratio = (distM - prevD) / segmentLen;
      const prevLat = coords[idx-1][1];
      const prevLon = coords[idx-1][0];
      
      // è¨ˆç®—å‰ã«å€¤ã‚’ãƒã‚§ãƒƒã‚¯
      if (Number.isFinite(prevLat) && Number.isFinite(prevLon) && 
          Number.isFinite(lat) && Number.isFinite(lon)) {
        lat = prevLat + (lat - prevLat) * ratio;
        lon = prevLon + (lon - prevLon) * ratio;
      }
    }

    // â˜…â˜…â˜… æœ€çµ‚ãƒã‚§ãƒƒã‚¯: NaNãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰çµ¶å¯¾ã«è¿½åŠ ã—ãªã„ â˜…â˜…â˜…
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
      console.warn(`[makeRestPoints] è¨ˆç®—ã‚¨ãƒ©ãƒ¼(NaN)ã®ãŸã‚åœ°ç‚¹ã‚¹ã‚­ãƒƒãƒ—: ${distM}m`);
      continue; 
    }

    // æ—¢å­˜åœ°ç‚¹ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (skipNodeOn && isNearNode(lat, lon)) {
      logRest(`[ã‚¹ã‚­ãƒƒãƒ—] æ—¢å­˜åœ°ç‚¹ã®è¿‘ã`);
      continue;
    }

    results.push({ lat, lon, routeD: distM });
  }

  logRest(`æœ€çµ‚æ±ºå®šãƒˆãƒªã‚¬ãƒ¼æ•°: ${results.length}ç®‡æ‰€`);
  return results;
}

/* ===== åŒºé–“çµ±è¨ˆï¼ˆå„ãƒ«ãƒ¼ãƒˆï¼‰ ===== */
async function calcLegStats(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments || [];
  const hasEle = coords[0].length >= 3;

  const legDist = [], legTime = [], legEnergy = [];
  for (const s of segs) {
    for (const step of (s.steps || [])) {
      const [i0, i1] = step.way_points || [0, 0];
      const d  = step.distance || 0;  // m
      const t  = step.duration || 0;  // s
      const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
      legDist.push(d / 1000);
      legTime.push(t / 60);
      legEnergy.push(energyStepKJ(d, dz, mass, flat));
    }
  }
  return {dist:legDist, time:legTime, energy:legEnergy};
}

function summaryStats(arr){
  if(!arr.length) return {mean:0,var:0,std:0};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length;
  return {mean:m, var:v, std:Math.sqrt(v)};
}

/* ====== Overpass API å‘¼ã³å‡ºã—ï¼ˆå¼·åŒ–ç‰ˆï¼‰ ====== */

/* ==========================================================
   ã€ä¿®æ­£1ã€‘APIé€šä¿¡éƒ¨ (400ã‚¨ãƒ©ãƒ¼ã¯ãƒªãƒˆãƒ©ã‚¤ã—ãªã„)
   â€»æ—¢å­˜ã® overpassQuery ã¨ overpassRetry ã‚’ã“ã‚Œã§ä¸Šæ›¸ã
   ========================================================== */

// å¾…æ©Ÿç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ãƒªãƒˆãƒ©ã‚¤åˆ¶å¾¡
async function overpassRetry(query) {
  let delay = 3000; 

  for (let i = 0; i < 3; i++) { 
    try {
      return await overpassQuery(query);
    } catch (e) {
      const msg = String(e);
      // â˜…ä¿®æ­£: 400 (Bad Request) ã¯ãƒªãƒˆãƒ©ã‚¤ã—ã¦ã‚‚ç›´ã‚‰ãªã„ã®ã§å³throwã—ã¦çµ‚äº†
      if (msg.includes('Status 400') || msg.includes('Bad Request')) {
        console.error("[Overpass] Stop retrying due to syntax error (NaN?):", msg);
        throw e; 
      }
      
      console.warn(`[Overpass] Retry ${i+1}/3 after ${delay}ms...`, e);
      await sleep(delay);
      delay *= 2;
    }
  }
  return await overpassQuery(query);
}

// é€šä¿¡å®Ÿè¡Œ
/* ==========================================================
   ã€ãƒ‡ãƒãƒƒã‚°ç‰ˆã€‘APIé€šä¿¡ (ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚¯ã‚¨ãƒªè¡¨ç¤ºæ©Ÿèƒ½ä»˜ã)
   ========================================================== */
async function overpassQuery(query) {
  const endpoints = [
    'https://overpass-api.de/api/interpreter',
    'https://overpass.kumi.systems/api/interpreter'
  ];
  
  let lastError = null;

  for (const ep of endpoints) {
    try {
      await sleep(1000); 
      if (typeof API_USED !== 'undefined') API_USED.overpassTotal++;

      const r = await fetch(ep, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
        body: new URLSearchParams({ data: query }).toString()
      });

      if (r.ok) return await r.json();

      // â˜…ãƒ‡ãƒãƒƒã‚°: 400ã‚¨ãƒ©ãƒ¼ã®æ™‚ã€é€ã£ãŸã‚¯ã‚¨ãƒªã‚’ãƒ­ã‚°ã«å‡ºã™
      if (r.status === 400) {
        console.error(`[Overpass] 400 Bad Request! Query was:\n${query}`);
        throw new Error(`Status 400 (Bad Request)`);
      }
      
      if (r.status === 429) {
        console.warn(`[Overpass] 429 on ${ep}. Waiting...`);
        await sleep(5000); 
        continue; 
      }
      if (r.status === 504) {
        console.warn(`[Overpass] 504 Timeout on ${ep}.`);
        lastError = new Error("Gateway Timeout");
        continue;
      }
      throw new Error(`Status ${r.status}`);

    } catch (e) {
      if (String(e).includes('Status 400')) throw e;
      console.warn(`[Overpass] Error on ${ep}:`, e);
      lastError = e;
    }
  }
  throw lastError || new Error('[Overpass] All endpoints failed.');
}
/* ==========================================================
   ã€æœ€çµ‚æ‰‹æ®µã€‘POIæ¤œç´¢ (æ­£è¦è¡¨ç¾ãƒ»å®Œå…¨å»ƒæ­¢ç‰ˆ)
   â€»æ­£è¦è¡¨ç¾ã‚’ä½¿ã‚ãšã€å˜ç´”ãª [key=value] ã‚’åˆ—æŒ™ã—ã¾ã™ã€‚
   â€»ã“ã‚Œã§400ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã“ã¨ã¯è«–ç†çš„ã«ã‚ã‚Šå¾—ã¾ã›ã‚“ã€‚
   ========================================================== */
async function fetchPoisAround(latRaw, lonRaw, baseRadius, limit) {
  // 1. å…¥åŠ›å€¤ãƒã‚§ãƒƒã‚¯
  const lat = Number(latRaw);
  const lon = Number(lonRaw);
  const rad = Number(baseRadius);

  if (!Number.isFinite(lat) || !Number.isFinite(lon) || Math.abs(lat) > 90) {
    console.error(`[fetchPoisAround] åº§æ¨™ç•°å¸¸ã‚¹ã‚­ãƒƒãƒ—: lat=${latRaw}, lon=${lonRaw}`);
    return []; 
  }
  if (!Number.isFinite(rad) || rad <= 0) {
    console.error(`[fetchPoisAround] åŠå¾„ç•°å¸¸ã‚¹ã‚­ãƒƒãƒ—: radius=${baseRadius}`);
    return [];
  }

  // æ–‡å­—åˆ—åŒ–
  const sLat = lat.toFixed(6);
  const sLon = lon.toFixed(6);
  if (sLat.includes('NaN') || sLon.includes('NaN')) return [];

  const centerLL = L.latLng(lat, lon);
  const limitN = Math.max(1, Number(limit) || 5);

  const useConvenience = document.getElementById('chkConvenience')?.checked ?? true;
  const useSuper       = document.getElementById('chkSuper')?.checked ?? true;
  const useDrug        = document.getElementById('chkDrug')?.checked ?? true;

  // â˜…ã‚¿ã‚°ã‚’ {k, v} ã®ãƒªã‚¹ãƒˆã§ç®¡ç†
  const TARGETS = [];
  
  // 1. Shopç³»
  if (useConvenience) TARGETS.push({k:'shop', v:'convenience'});
  if (useSuper)       TARGETS.push({k:'shop', v:'supermarket'});
  if (useDrug) {
    TARGETS.push({k:'shop', v:'chemist'});
    TARGETS.push({k:'shop', v:'pharmacy'});
    TARGETS.push({k:'amenity', v:'pharmacy'});
  }

  // 2. Extra (ã“ã‚Œã‚‰ã¯å¸¸ã«å«ã‚ã‚‹ã‹ã€ãƒ’ãƒƒãƒˆæ•°ä¸è¶³æ™‚ã®ã¿æ¤œç´¢ã™ã‚‹ã‹ã¯ãƒ­ã‚¸ãƒƒã‚¯æ¬¡ç¬¬ã§ã™ãŒã€
  //    ã“ã“ã§ã¯ã€ŒPrimaryã§ä¸è¶³ã—ãŸã‚‰Extraã‚‚å«ã‚ã¦å†æ¤œç´¢ã€ã¨ã„ã†å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ã«å¾“ã„ã¾ã™)
  const EXTRAS = [
    {k:'amenity', v:'cafe'},
    {k:'amenity', v:'restaurant'},
    {k:'amenity', v:'fast_food'},
    {k:'amenity', v:'toilets'},
    {k:'amenity', v:'bench'},
    {k:'amenity', v:'vending_machine'}
  ];

  const radiusSteps = (() => {
    const base = Math.max(100, rad); 
    const steps = [1000, 3000, 5000, 10000]; 
    const s = [base, ...steps].filter((v, i, a) => a.indexOf(v) === i && v >= base).sort((a,b)=>a-b);
    return s;
  })();

  // â˜…ã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ (æ­£è¦è¡¨ç¾ãªã—ãƒ»å®Œå…¨åˆ—æŒ™)
  const buildQuery = (tagList, radius) => {
    if (!tagList.length) return null;
    const sRad = radius.toFixed(0);
    
    // (node...; way...; node...; way...;) ã®ä¸­èº«ã‚’ä½œã‚‹
    const parts = [];

    tagList.forEach(t => {
      // vending_machine ã®ç‰¹ä¾‹
      if (t.k === 'amenity' && t.v === 'vending_machine') {
        parts.push(`node(around:${sRad},${sLat},${sLon})["amenity"="vending_machine"]`);
        parts.push(`node(around:${sRad},${sLat},${sLon})["vending"="drinks"]`);
      } else {
        // é€šå¸¸ (nodeã¨wayä¸¡æ–¹)
        parts.push(`node(around:${sRad},${sLat},${sLon})["${t.k}"="${t.v}"]`);
        parts.push(`way(around:${sRad},${sLat},${sLon})["${t.k}"="${t.v}"]`);
      }
    });

    // çµåˆ
    return `[out:json][timeout:25];(${parts.join(';')};);out center;`;
  };

  const runOnce = async (tagList, radius) => {
    try {
      const q = buildQuery(tagList, radius);
      if (!q) return [];
      
      const data = await overpassRetry(q); 
      const elements = data.elements || [];
      const results = [];
      
      elements.forEach(e => {
        const ll = e.type === 'node' ? [e.lat, e.lon] : (e.center ? [e.center.lat, e.center.lon] : null);
        if (!ll) return;
        
        // åå‰å–å¾— (name:ja -> name -> brand -> operator)
        const tags = e.tags || {};
        const name = tags['name:ja'] || tags.name || tags.brand || tags.operator || 'POI';
        
        const dist = centerLL.distanceTo([ll[0], ll[1]]);
        results.push({ name, lat: ll[0], lon: ll[1], dist, distFromTriggerM: dist, distKm: dist/1000 });
      });
      
      results.sort((a,b)=>a.dist-b.dist);
      
      // é‡è¤‡æ’é™¤ (åº§æ¨™ã¨åå‰ã§)
      const seen = new Set();
      const uniq = [];
      for(const p of results){
          const k = `${p.lat.toFixed(5)},${p.lon.toFixed(5)}|${p.name}`;
          if(!seen.has(k)){ seen.add(k); uniq.push(p); }
      }
      return uniq;

    } catch (err) {
      console.warn(`[Overpass] Error at radius ${radius}`, err);
      return null; 
    }
  };

  let picked = [];
  
  // 1. Primary Search
  for (const r of radiusSteps) {
    const res = await runOnce(TARGETS, r);
    if (res === null) return []; // ã‚¨ãƒ©ãƒ¼åœæ­¢
    if (res.length >= limitN) {
      picked = res.slice(0, limitN);
      break;
    }
    if (res.length > picked.length) picked = res;
  }

  // 2. Extra Search (Primaryä¸è¶³æ™‚)
  if (picked.length < limitN) {
    // Primary + Extra ã‚’çµåˆã—ã¦å†æ¤œç´¢
    const MERGED = [...TARGETS, ...EXTRAS];
    for (const r of radiusSteps) {
      const res = await runOnce(MERGED, r);
      if (res === null) return [];
      if (res.length >= limitN) {
        picked = res.slice(0, limitN);
        break;
      }
      if (res.length > picked.length) picked = res;
    }
  }

  return picked.slice(0, limitN);
}
/* ====== ä¼‘æ†©ãƒªã‚¹ãƒˆè¡¨ç¤ºæ›´æ–° ====== */
function updateRestListPanel(){
  const ul = $('restListPanel');
  ul.innerHTML='';
  if (!restList.length){
    ul.innerHTML='<li>ä¼‘æ†©åœ°ç‚¹ã¯ã‚ã‚Šã¾ã›ã‚“</li>';
    return;
  }
  restList.forEach((r,i)=>{
    const li=document.createElement('li');
    li.style.padding='4px 0';
    li.innerHTML=`${i+1}. ${r.distance} kmåœ°ç‚¹
      <small>(${r.lat.toFixed(5)}, ${r.lon.toFixed(5)})</small>`;
    ul.appendChild(li);
  });
}

function updateRestPoiPanel(){
  const ol = document.getElementById('restPoiPanel');
  if (!ol) return;
  ol.innerHTML = '';

  // â˜…ã“ã“ã‚’è¿½åŠ ï¼šUIã«å‡ºã™ç›´å‰ã«ã€å…¨POIã¸å‘½åã‚’å¼·åˆ¶
  restGroups.forEach((g, ti) => {
    (g?.pois || []).forEach((p, pi) => ensurePoiName(p, ti, pi));
  });

  if (!restGroups.length){
    const li = document.createElement('li');
    li.textContent = 'ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“';
    ol.appendChild(li);
    return;
  }

  restGroups.forEach((g, i) => {
    const li = document.createElement('li');
    li.style.margin = '6px 0';

    // è¦‹å‡ºã—ï¼šä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼#Nï¼ˆkmåœ°ç‚¹ / ç·¯åº¦çµŒåº¦ï¼‰
    const km = (g.rest?.routeD ?? 0) / 1000;
    const head = document.createElement('div');
    head.innerHTML = `<b>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼ƒ${i+1}</b>ã€€<span style="color:#666">${km.toFixed(2)} kmåœ°ç‚¹</span>
      <small>(${(g.rest?.lat ?? 0).toFixed(5)}, ${(g.rest?.lon ?? 0).toFixed(5)})</small>`;
    li.appendChild(head);

    // å€™è£œPOIã®UL
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.margin = '4px 0 0';
    ul.style.padding = '0';

    if (!g.pois?.length){
      const x = document.createElement('li');
      x.textContent = 'ãƒ»ï¼ˆå€™è£œãªã—ï¼‰';
      ul.appendChild(x);
    } else {
      g.pois.forEach((p) => {
  const it = document.createElement('li');
  it.style.padding = '2px 0';
  const dTrigger = (typeof p.distFromTriggerM === 'number')
    ? ` / ãƒˆãƒªã‚¬ãƒ¼è·é›¢ ${formatDist(p.distFromTriggerM)}`
    : '';
  const dPerp = (p._proj && typeof p._proj.perpM === 'number')
    ? ` / ãƒ«ãƒ¼ãƒˆâŠ¥ <b>${formatDist(p._proj.perpM)}</b>`
    : '';
  it.innerHTML = `ãƒ»${p.name}ã€€${p.lat.toFixed(5)}ã€€${p.lon.toFixed(5)}${dTrigger}${dPerp}`;
  ul.appendChild(it);
});
    }

    li.appendChild(ul);
    ol.appendChild(li);
  });
  drawRestBeams();
  // â–¼â–¼ è¿½åŠ : æ‰‹å‹•æ¯”è¼ƒãƒ„ãƒ¼ãƒ«ã®UIã‚‚æ›´æ–°ã™ã‚‹ â–¼â–¼
  if (typeof updateManualRouteUI === 'function') {
    updateManualRouteUI();
  }
}
  
// ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã‚’ç·šã§çµã‚“ã§å¯è¦–åŒ–ã™ã‚‹
function drawRestBeams(){
  if (!restBeamLayer) return;

  // ã„ã£ãŸã‚“å‰å›ã®ç·šã‚’å…¨éƒ¨æ¶ˆã™
  restBeamLayer.clearLayers();

  if (!Array.isArray(restGroups) || !restGroups.length) return;

  restGroups.forEach(g => {
    const r = g && g.rest;
    if (!r || !Array.isArray(g.pois)) return;

    g.pois.forEach(p => {
      if (!p) return;
      // ãƒˆãƒªã‚¬ãƒ¼ â†’ POI ã‚’ç´°ã„ç ´ç·šã§å¼•ã
      const line = L.polyline(
        [[r.lat, r.lon], [p.lat, p.lon]],
        { weight: 2, dashArray: '4,4', color: '#999' }
      );
      restBeamLayer.addLayer(line);
    });
  });
}

// çµ„ã¿åˆã‚ã›è¡¨ç¤ºå°‚ç”¨ï¼šä½¿ç”¨åœ°ç‚¹ã ã‘ãƒ”ãƒ³ã‚’å‡ºã™
function setComboMarkers(start, picksArray, goal){
  // æ—¢å­˜ãƒ”ãƒ³ã‚’ã™ã¹ã¦æ¶ˆã™
  if (markerLayer) map.removeLayer(markerLayer);
  markerLayer = L.layerGroup().addTo(map);

  // ã‚¹ã‚¿ãƒ¼ãƒˆ
  if (start) {
    L.marker([start.lat, start.lon], {icon:ICONS.start})
      .bindTooltip(start.name || 'ã‚¹ã‚¿ãƒ¼ãƒˆ').addTo(markerLayer);
  }

  // æ¡ç”¨POIï¼ˆé †è·¯ï¼‰
  (picksArray || []).forEach((p, i) => {
    if (!p) return;
    L.marker([p.lat, p.lon], {
      icon: new L.Icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
        iconSize:[32,32], iconAnchor:[16,32]
      })
    }).bindTooltip(`${p.name || 'ä¼‘æ†©'} #${i+1}`).addTo(markerLayer);
  });

  // ã‚´ãƒ¼ãƒ«
  if (goal) {
    L.marker([goal.lat, goal.lon], {icon:ICONS.goal})
      .bindTooltip(goal.name || 'ã‚´ãƒ¼ãƒ«').addTo(markerLayer);
  }
}


function showTop3Combos(resultList){
  const box = document.getElementById('comboTop3');
  box.innerHTML = '';
  // ç›´è¿‘ã®ã€Œæ¢ç´¢: *ã€ã‚’æ‹¾ã£ã¦è¦‹å‡ºã—ã«è¡¨ç¤º
const last = [...PERF.rows].reverse().find(r=>String(r.name).startsWith('æ¢ç´¢:'));
if(last){
  const note = document.createElement('div');
  note.style.cssText='color:#555;margin-bottom:6px';
  note.innerHTML = `æ¢ç´¢æ™‚é–“: <b>${last.ms.toFixed(1)} ms</b> <small>(${last.name})</small>`;
  box.appendChild(note);
}

  if (!resultList.length){
    box.textContent = 'å€™è£œãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã‚„POIãŒä¸è¶³ï¼‰';
    return;
  }

  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const fmt = (n)=>Number(n).toFixed(5);

  resultList.slice(0,3).forEach((r, idx) => {
    const rank = idx+1;

    const wrap = document.createElement('div');
    wrap.style.border='1px solid #ddd';
    wrap.style.borderRadius='8px';
    wrap.style.padding='8px';
    wrap.style.marginBottom='8px';

    const header = document.createElement('div');
    const metric = getScoreMetric();
const sig = {
  dist: sd(r.stats.dist),
  time: sd(r.stats.time),
  energy: sd(r.stats.energy)
};
const metricLabel = (metric === 'time') ? 'æ™‚é–“Ïƒ'
                  : (metric === 'energy') ? 'ã‚¨ãƒãƒ«ã‚®ãƒ¼Ïƒ'
                  : 'è·é›¢Ïƒ';
const metricValue = (metric === 'time') ? sig.time
                   : (metric === 'energy') ? sig.energy
                   : sig.dist;

header.innerHTML = `
  <div style="font-weight:700;margin-bottom:4px">
    #${rank}ã€€ã‚¹ã‚³ã‚¢ï¼ˆ${metricLabel}ï¼‰: ${metricValue.toFixed(3)}
    ${Number.isFinite(r.score)
      ? `<span style="color:#777">ï¼ˆMSE=${Number(r.score).toFixed(3)}ï¼‰</span>`
      : ''
    }
  </div>
  <div style="margin-top:4px">
    è·é›¢Ïƒ=${sig.dist.toFixed(2)} kmã€€
    æ™‚é–“Ïƒ=${sig.time.toFixed(2)} åˆ†ã€€
    ã‚¨ãƒãƒ«ã‚®ãƒ¼Ïƒ=${sig.energy.toFixed(2)} kJ
  </div>
`;

    wrap.appendChild(header);

    const list = document.createElement('div');
    list.style.marginTop = '8px';
    list.innerHTML = `<div style="font-weight:600;margin-bottom:4px">æ¡ç”¨ã—ãŸä¼‘æ†©åœ°ç‚¹ï¼ˆãƒˆãƒªã‚¬ãƒ¼ã”ã¨ï¼‰</div>`;
    const ol = document.createElement('ol');
    ol.style.margin = '4px 0 0 1.1rem';
    ol.style.fontSize = '0.92rem';

    (restGroups || []).forEach((g, i) => {
      const li = document.createElement('li');
      const km = ((g?.rest?.routeD || 0) / 1000).toFixed(2);
      const head = document.createElement('div');
      head.innerHTML = `<b>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼ƒ${i+1}</b>ã€€<span style="color:#666">${km} kmåœ°ç‚¹</span>
        <small>(${fmt(g?.rest?.lat||0)}, ${fmt(g?.rest?.lon||0)})</small>`;
      li.appendChild(head);

      const chosen = (r.picksByTrigger && r.picksByTrigger[i]) ? r.picksByTrigger[i] : null;
      const ul = document.createElement('ul');
      ul.style.listStyle='none'; ul.style.margin='4px 0 0'; ul.style.padding='0';

      const row = document.createElement('li');
      row.style.padding='2px 0';

      if (chosen){
        row.style.cursor='pointer';
        const dtxt = (typeof chosen.distFromTriggerM === 'number')
          ? ` / ${formatDist(chosen.distFromTriggerM)}`
            : '';
        row.textContent = `ãƒ»${chosen.name}ã€€${fmt(chosen.lat)}ã€€${fmt(chosen.lon)}${dtxt}`;
        row.onclick = () => {
          map.flyTo([chosen.lat, chosen.lon], 17);
          L.popup().setLatLng([chosen.lat, chosen.lon]).setContent(chosen.name).openOn(map);
        };
      } else {
  // å€™è£œãŒä¸€ä»¶ã‚‚ç„¡ã„ã®ã‹ã€å˜ã«ãã®çµ„ã¿åˆã‚ã›ã§æœªæ¡ç”¨ãªã®ã‹ã‚’åˆ¤å®š
  const hasAny = Array.isArray(g?.pois) && g.pois.length > 0;

  // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  console.log('[showTop3Combos] trigger', i+1,
              'pois=', g?.pois?.length || 0,
              'chosen=', chosen,
              'label=', hasAny ? 'æœªæ¡ç”¨' : 'å€™è£œãªã—');

  row.textContent = hasAny ? 'ãƒ»ï¼ˆæœªæ¡ç”¨ï¼‰' : 'ãƒ»ï¼ˆå€™è£œãªã—ï¼‰';
  row.style.color = '#777';
}

      ul.appendChild(row);
      li.appendChild(ul);
      ol.appendChild(li);
    });

    list.appendChild(ol);
    wrap.appendChild(list);

    const btnWrap = document.createElement('div');
    btnWrap.style.marginTop='8px';
    const btn = document.createElement('button');
    btn.textContent = 'ã“ã®ãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤º';
    btn.onclick = async () => {
      btn.disabled = true;
      btn.textContent = 'ãƒ«ãƒ¼ãƒˆç”Ÿæˆä¸­...';
      try {
        let feature = r.feature;
        if (!feature) {
          const start = pts.find(p=>p.type==='start') || pts[0];
          const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
          if (!start || !goal) { alert('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'); return; }
          const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
            ? r.picksByTrigger.filter(Boolean)
            : (r.picks || []);
          const wps = [start, ...picksArray, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name || 'POI'}));
          const profile = 'cycling-road';
          const out = await routeLegStatsForWaypoints(wps, profile);
          feature = out.feature;
        }
        if (!feature) { alert('ãƒ«ãƒ¼ãƒˆã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

        clearRouteLayers();
        const color = '#00aa88';
        const layer = L.geoJSON(feature, { style:{ color, weight: 7 } }).addTo(map);
        routeLayers['combo#'+rank] = layer;

        const start = pts.find(p=>p.type==='start') || pts[0];
        const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
        const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
          ? r.picksByTrigger.filter(Boolean)
          : (r.picks || []);
        setComboMarkers(start, picksArray, goal);

        // ï¼ˆshowTop3Combos å†…ã®ä¸€éƒ¨ï¼‰
const bounds = layer.getBounds?.();
if (bounds && bounds.isValid && bounds.isValid()) {
  map.fitBounds(bounds.pad(0.1));
} else {
  const fallback = (r.picks && r.picks[0]) || pts[0];
  if (fallback) map.flyTo([fallback.lat, fallback.lon], 14);
}

        setActiveButton(null);
      } catch (e){
  console.error(e);
  const hints = [
    !ORS_KEY ? 'ORS_KEY ãŒæœªè¨­å®š' : null,
    !(pts && pts.length>=2) ? 'Start/Goal ãŒä¸æ­£' : null,
    !routeData.fastest ? 'æœ€é€Ÿãƒ«ãƒ¼ãƒˆæœªç”Ÿæˆï¼ˆå…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œï¼‰' : null
  ].filter(Boolean).join(' / ');
  alert('ãƒ«ãƒ¼ãƒˆæç”»ã§ã‚¨ãƒ©ãƒ¼: ' + (e.message || e) + (hints ? '\nãƒ’ãƒ³ãƒˆ: ' + hints : ''));
} finally {
        btn.disabled = false;
        btn.textContent = 'ã“ã®ãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤º';
      }
    };
    btnWrap.appendChild(btn);
    wrap.appendChild(btnWrap);

    box.appendChild(wrap);
  });
}

// 1ãƒ¬ã‚°ã®MSEï¼ˆè·é›¢ãƒ»æ™‚é–“ãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰
// function legMseCost(d, t, e, ideald, idealt, ideale){
//   const dd = d - ideald;
//   const tt = t - idealt;
//   const ee = e - ideale;
//   return dd*dd + tt*tt + ee*ee;
// }
  function legMseCost(d, t, e, ideald, idealt, ideale){
  const ee = e - ideale;
  return ee*ee;
}


// stats({dist[], time[], energy[]}) ã‹ã‚‰ãƒ«ãƒ¼ãƒˆå…¨ä½“ã®MSEã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
function routeMseScoreFromStats(stats, idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg){
  const dArr = stats?.dist   || [];
  const tArr = stats?.time   || [];
  const eArr = stats?.energy || [];

  const n = Math.min(dArr.length, tArr.length, eArr.length);
  if (!n) return NaN; // â† ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šç›´ç·šè·é›¢ãªã©ã€Œtime/energyãªã—ã€ã¯ MSE è¨ˆç®—ä¸å¯

  let sum = 0;
  for (let i = 0; i < n; i++){
    sum += legMseCost(
      dArr[i],
      tArr[i],
      eArr[i],
      idealDistPerLeg,
      idealTimePerLeg,
      idealEnergyPerLeg
    );
  }
  return sum; // å°ã•ã„ã»ã©ã€Œç†æƒ³ãƒšãƒ¼ã‚¹ã«è¿‘ã„ã€
}


/* ===== ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼ˆPOIè©•ä¾¡ï¼‰ ===== */
// ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒï¼ˆç„¡ã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
let SCORE_WEIGHTS = (()=>{
  try{
    const raw = localStorage.getItem('route_score_weights');
    if(!raw) return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
    const obj = JSON.parse(raw);
    // ä¸è¶³ã‚­ãƒ¼ã¯è£œå®Œ
    return {
      wAlign: Number.isFinite(obj?.wAlign) ? obj.wAlign : 1.0,
      wPerp:  Number.isFinite(obj?.wPerp)  ? obj.wPerp  : 1.0,
      wTrig:  Number.isFinite(obj?.wTrig)  ? obj.wTrig  : 0.5,
    };
  }catch(e){
    return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
  }
})();

function getScoreMetric(){
  const sel = document.getElementById('scoreMetricSelect');
  return sel ? sel.value : SCORE_METRIC;
}
function setScoreMetric(v){
  SCORE_METRIC = v;
  localStorage.setItem('route_score_metric', v);
}

function targetCumDForIndex(i, R, totalD){
  if (!Number.isFinite(totalD) || totalD<=0) return 0;
  return totalD * (i + 1) / (R + 1);
}

function nodeCost(p, targetCumD){
  if (!p) return 1e9;
  const perpM   = Number(p?._proj?.perpM) ?? 0;
  const trigM   = Number(p?.distFromTriggerM) ?? 0;
  const alignM  = Math.abs((Number(p?._proj?.cumD) ?? targetCumD) - targetCumD);
return (SCORE_WEIGHTS.wAlign * (alignM/1000)) +
       (SCORE_WEIGHTS.wPerp  * (perpM/1000))  +
       (SCORE_WEIGHTS.wTrig  * (trigM/1000));
}


/* ===== çµ„ã¿åˆã‚ã›ãƒ«ãƒ¼ãƒˆæ¢ç´¢ï¼†è©•ä¾¡ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */

/* ===== ç›´ç·šè·é›¢: å…¨çµ„ã¿åˆã‚ã›ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ã§1ä»¶ï¼‰ ===== */

// ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«å–å¾—ï¼ˆä¿é™ºã¤ãï¼‰
function getStartGoalPoints(){
  const start = pts.find(p=>p.type==='start') || pts[0];
  const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
  if(!start || !goal) throw new Error('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  return {start, goal};
}

// POIç¾¤ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ï¼‰ã‹ã‚‰ã€Œæœ€å¤§5ä»¶ã ã‘ã€å–ã‚Šå‡ºã™ï¼ˆå°„å½±ãŒç„¡ãã¦ã‚‚OKï¼‰
function topPoisPerTriggerForLinear(maxPer=5){
  if(!Array.isArray(restGroups) || !restGroups.length) throw new Error('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“');
  // ã¨ã‚Šã‚ãˆãšã€Œãƒˆãƒªã‚¬ãƒ¼ã‹ã‚‰ã®è·é›¢ + ãƒ«ãƒ¼ãƒˆç›´äº¤è·é›¢ã€ã®å°ã•ã„é †ã§åˆ‡ã‚Šå‡ºã—ï¼ˆç„¡ã‘ã‚Œã°ã‚ã‚‹æƒ…å ±ã ã‘ï¼‰
  return restGroups.map((g,i)=>{
    const arr = (g?.pois || []).slice();
    // ã€Œå€™è£œãªã—ã€ã®ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚‹ã¨çµ„ã¿åˆã‚ã›ãŒæˆç«‹ã—ãªã„ã®ã§ã€ã“ã“ã§å¼¾ã
    if(!arr.length) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã«å€™è£œPOIãŒã‚ã‚Šã¾ã›ã‚“`);
    const score = p=>{
      const a = Number(p?.distFromTriggerM) || 0;
      const b = Number(p?._proj?.perpM) || 0;
      return a + b;
    };
    arr.sort((x,y)=> score(x)-score(y));
    return arr.slice(0, Math.max(1, Math.min(maxPer, arr.length)));
  });
}



// 2ç‚¹é–“ã®åœ°ä¸Šè·é›¢ï¼ˆmï¼‰
function llDist(a,b){
  return L.latLng(a.lat, a.lon).distanceTo([b.lat, b.lon]);
}

// ã‚ã‚‹çµ„ã¿åˆã‚ã›ï¼ˆpicks: å„ãƒˆãƒªã‚¬ãƒ¼ã§1ä»¶ï¼‰ã«å¯¾ã—ã€
// start -> picks[0] -> picks[1] -> ... -> goal ã®ç›´ç·šåˆè¨ˆè·é›¢ï¼ˆmï¼‰ã‚’è¿”ã™
function comboLinearDistanceMeters(start, picks, goal){
  let sum = 0;
  let prev = start;
  for(const p of picks){
    sum += llDist(prev, p);
    prev = p;
  }
  sum += llDist(prev, goal);
  return sum;
}

// å…¨çµ„ã¿åˆã‚ã›ã‚’åˆ—æŒ™ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼1ä»¶å¿…ãšé¸ã¶ï¼‰
function enumerateAllOnePerTrigger(groups, hardCap=200000){
  // groups ã¯ [ [p,p,p...], [p,p...], ... ]
  const out = [];
  const idx = new Array(groups.length).fill(0);
  const lens = groups.map(g=>g.length);
  let total = lens.reduce((a,b)=>a*b,1);
  if(total>hardCap) total = hardCap; // çˆ†ç™ºé˜²æ­¢

  for(let n=0; n<total; n++){
    // ç¾åœ¨ã®é¸æŠã‚’ push
    out.push(groups.map((g,i)=> g[idx[i]]));
    // æ¬¡ã®çµ„ã¿åˆã‚ã›ã¸
    for(let i=groups.length-1;i>=0;i--){
      idx[i]++;
      if(idx[i] < lens[i]) break;
      idx[i]=0;
      if(i===0) return out; // å…¨æ¢ç´¢å®Œäº†
    }
  }
  return out;
}

// ç›´ç·šè·é›¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç”¨ã«ã€å…¨çµ„åˆã›ã‚’ã€Œè¡Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã«å¤‰æ›ã—ã¦è¿”ã™ãƒ˜ãƒ«ãƒ‘ãƒ¼
function buildLinearAlgoRows(start, goal, groups, hardCap = 200000) {
  const combos = enumerateAllOnePerTrigger(groups, hardCap);

  const rows = combos.map(picks => {
    const meters = comboLinearDistanceMeters(start, picks, goal);
    const km = meters / 1000;

    const idxes = picks.map((p, gi) => {
      const idx = groups[gi].indexOf(p);
      return idx >= 0 ? idx : null;
    });

    return {
      score: km,
      rawScore: meters,
      stats: {
        dist: [km],
        time: [],
        energy: []
      },
      picks,
      picksByTrigger: picks,
      km,
      idxes
    };
  });

  rows.sort((a, b) => (a.score ?? Infinity) - (b.score ?? Infinity));
  return rows;
}

// Viterbiï¼ˆAPIåˆ©ç”¨ç‰ˆï¼‰
// start, goal: {lat, lon} å½¢å¼
// restGroups: [ [POI, POI, ...], [POI, ...], ... ] å„ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã®å€™è£œPOI
// profile: 'cycling-road' ãªã©
/* ===== ã€ä¿®æ­£ç‰ˆã€‘runViterbiOnce_API (è·é›¢MSEå®Œå…¨å¯¾å¿œãƒ»ã‚¨ãƒ©ãƒ¼ä¿®æ­£æ¸ˆã¿) ===== */
async function runViterbiOnce_API(start, goal, restGroups, profile) {

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!Number.isInteger(T) || T <= 0) {
    console.warn('[Viterbi] restGroups ãŒç©º / ä¸æ­£ã§ã™:', restGroups);
    return [];
  }

  // â˜…è·é›¢ã®ç†æƒ³å€¤ã‚’å–å¾—
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => !Number.isInteger(k) || k <= 0)) {
    console.warn('[Viterbi] å€™è£œ0ä»¶ã®ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã™:', Klist);
    return [];
  }

  const dp   = [];
  const prev = [];
  for (let t = 0; t < T; t++) {
    dp[t]   = new Array(Klist[t]).fill(Infinity);
    prev[t] = new Array(Klist[t]).fill(-1);
  }

  // --- start â†’ æœ€åˆã®ãƒˆãƒªã‚¬ãƒ¼ ---
  for (let k = 0; k < Klist[0]; k++) {
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);

    // â˜…è·é›¢MSEã‚’è¨ˆç®—
    const mse = legDistMseCost(leg.distKm, idealDistPerLeg);
    dp[0][k] = mse;

    // â˜…ä¿®æ­£: ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—(de, idealEnergyPerLeg)ã‚’å‰Šé™¤
    recordViterbiEdge({
      t: 0,
      fromIdx: -1,
      toIdx: k,
      fromName: start.name || 'start',
      toName: poi.name || `g0[${k}]`,
      fromLat: start.lat, fromLon: start.lon,
      toLat: poi.lat,     toLon: poi.lon,
      distKm: leg.distKm,
      timeMin: leg.timeMin,
      energyKj: leg.energyKj,
      cost: mse,      // ã‚³ã‚¹ãƒˆã¨ã—ã¦MSEã‚’ä¿å­˜
      mseDist: mse
    });
  }

  // --- t-1 â†’ t ---
  for (let t = 1; t < T; t++) {
    const curGroup  = restGroups[t];
    const prevGroup = restGroups[t - 1];

    for (let j = 0; j < Klist[t]; j++) {
      const toPoi = curGroup[j];
      let bestCost = Infinity;
      let bestIdx  = -1;

      for (let i = 0; i < Klist[t - 1]; i++) {
        const fromPoi = prevGroup[i];
        if (!Number.isFinite(dp[t - 1][i])) continue;

        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);

        // â˜…è·é›¢MSEã‚’è¨ˆç®—
        const mse = legDistMseCost(leg.distKm, idealDistPerLeg);
        
        recordViterbiEdge({
          t,
          fromIdx: i,
          toIdx: j,
          fromName: fromPoi.name || `g${t-1}[${i}]`,
          toName: toPoi.name || `g${t}[${j}]`,
          fromLat: fromPoi.lat, fromLon: fromPoi.lon,
          toLat: toPoi.lat,     toLon: toPoi.lon,
          distKm: leg.distKm,
          timeMin: leg.timeMin,
          energyKj: leg.energyKj,
          cost: mse,
          mseDist: mse,
          prevDp: dp[t-1][i],
          candDp: dp[t-1][i] + mse
        });

        const cand = dp[t - 1][i] + mse;

        if (cand < bestCost) {
          bestCost = cand;
          bestIdx  = i;
        }
      }
      dp[t][j]   = bestCost;
      prev[t][j] = bestIdx;
    }
  }

  // --- æœ€å¾Œã®ãƒˆãƒªã‚¬ãƒ¼ â†’ goal ---
  const lastT = T - 1;
  let bestFinalCost = Infinity;
  let bestFinalIdx  = -1;

  for (let k = 0; k < Klist[lastT]; k++) {
    if (!Number.isFinite(dp[lastT][k])) continue;

    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApi(poi, goal, profile);

    // â˜…è·é›¢MSEã‚’è¨ˆç®—
    const mse = legDistMseCost(leg.distKm, idealDistPerLeg);

    recordViterbiEdge({
      t: lastT + 1,
      fromIdx: k,
      toIdx: -1,
      fromName: poi.name || `g${lastT}[${k}]`,
      toName: goal.name || 'goal',
      fromLat: poi.lat,  fromLon: poi.lon,
      toLat: goal.lat,   toLon: goal.lon,
      distKm: leg.distKm,
      timeMin: leg.timeMin,
      energyKj: leg.energyKj,
      cost: mse,
      mseDist: mse,
      prevDp: dp[lastT][k],
      candDp: dp[lastT][k] + mse
    });

    const cand = dp[lastT][k] + mse;

    if (cand < bestFinalCost) {
      bestFinalCost = cand;
      bestFinalIdx  = k;
    }
  }

  if (bestFinalIdx < 0 || !Number.isFinite(bestFinalCost)) {
    console.warn('[Viterbi] ã‚´ãƒ¼ãƒ«ã¾ã§åˆ°é”ã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
    return [];
  }

  // çµŒè·¯å¾©å…ƒ
  const picks = new Array(T);
  let curIdx  = bestFinalIdx;

  for (let t = lastT; t >= 0; t--) {
    picks[t] = restGroups[t][curIdx];
    curIdx   = prev[t][curIdx];

    if (t > 0 && curIdx < 0) {
      console.warn('[Viterbi] prev ã®è¾»è¤„ãŒåˆã„ã¾ã›ã‚“ t=', t);
      break;
    }
  }

  // æœ€çµ‚ã‚¹ã‚³ã‚¢è¨ˆç®—
  let feature = null;
  let stats   = { dist:[], time:[], energy:[] };
  let finalScore = bestFinalCost;

  try {
    const wps = [start, ...picks, goal].map(p => ({
      lat: p.lat,
      lon: p.lon,
      name: p.name || 'POI'
    }));

    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if (out?.stats) stats = out.stats;

    // â˜…æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚‚è·é›¢MSEã§è¨ˆç®—
    const exact = finalScoreFromStats(stats, ideals); 
    if (Number.isFinite(exact)) finalScore = exact;

  } catch (e) {
    console.warn('[Viterbi] çµ±è¨ˆè¨ˆç®—ç”¨ãƒ«ãƒ¼ãƒˆç”Ÿæˆã«å¤±æ•—', e);
  }

  return [{
    score:    finalScore,
    rawScore: bestFinalCost,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// è¡¨ç¤ºã¨CSVå‡ºåŠ›
function renderLinearResults(rows){
  const cont = document.getElementById('linearList');
  const sum  = document.getElementById('linearSummary');
  if(!cont || !sum) return;

  // --- ä¸Šä½3ä»¶ã®ã¿è¡¨ç¤º ---
  const SHOW = 3;
  const shown = rows.slice(0, SHOW);

  // CSVå…¨ä»¶ã¯ä¿æŒï¼ˆUIã¯3ä»¶ï¼‰
  window.__linear_rows_for_csv = rows;
  const csvBtn = document.getElementById('btnDownloadLinearCsv');
  if(csvBtn) csvBtn.disabled = rows.length===0;

  cont.innerHTML = ''; // ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã«å¤‰æ›´
  shown.forEach((r, i) => {
    const rank = i + 1;
    const names = r.picks.map(p=> p?.name || 'POI').join(' â†’ ');

    const wrap = document.createElement('div');
    wrap.style.border = '1px solid #ddd';
    wrap.style.borderRadius = '8px';
    wrap.style.padding = '8px';
    wrap.style.marginBottom = '8px';
    wrap.style.fontFamily = 'system-ui,ui-sans-serif';

    const head = document.createElement('div');
    head.style.fontWeight = '700';
    head.style.marginBottom = '4px';
    head.textContent = `#${rank}  åˆè¨ˆç›´ç·šè·é›¢: ${r.km.toFixed(2)} km`;
    wrap.appendChild(head);

    const meta = document.createElement('div');
    meta.style.color = '#555';
    meta.style.fontSize = '0.92rem';
    meta.textContent = `idx=${JSON.stringify(r.idxes)} | ${names}`;
    wrap.appendChild(meta);

    const btnRow = document.createElement('div');
    btnRow.style.marginTop = '6px';

    const btn = document.createElement('button');
    btn.textContent = 'ã“ã®çµ„ã¿åˆã‚ã›ã§ãƒ«ãƒ¼ãƒˆè¡¨ç¤º';
    btn.onclick = async () => {
      btn.disabled = true;
      const oldTxt = btn.textContent;
      btn.textContent = 'ç”Ÿæˆä¸­â€¦';
      try {
        await showLinearComboRoute(r);   // â† ä¸‹ã®æ–°é–¢æ•°ã§æç”»
      } catch (e) {
        const hints = [
          !ORS_KEY ? 'ORS_KEY æœªè¨­å®š' : null,
          !(pts && pts.length>=2) ? 'Start/Goal æœªè¨­å®š' : null
        ].filter(Boolean).join(' / ');
        alert('ãƒ«ãƒ¼ãƒˆæç”»ã«å¤±æ•—: ' + (e.message || e) + (hints ? '\nãƒ’ãƒ³ãƒˆ: ' + hints : ''));
        console.error(e);
      } finally {
        btn.disabled = false;
        btn.textContent = oldTxt;
      }
    };
    btnRow.appendChild(btn);
    wrap.appendChild(btnRow);

    cont.appendChild(wrap);
  });

  const msg = `ç·çµ„åˆã›æ•°: ${rows.length.toLocaleString()} ä»¶ï¼ˆä¸Šä½ ${Math.min(SHOW, rows.length)} ä»¶ã‚’è¡¨ç¤ºï¼CSVã¯å…¨ä»¶å‡ºåŠ›å¯èƒ½ï¼‰`;
  sum.textContent = msg;
}

function downloadLinearCsv(){
  const rows = window.__linear_rows_for_csv || [];
  if (!rows.length) return;

  const header = ['rank','total_km','indices_per_trigger','poi_names'];

  const bodyRows = rows.map((r, i)=>{
    const names = r.picks.map(p=> (p?.name ?? 'POI')).join(' -> ');
    return [
      String(i+1),
      r.km.toFixed(3),
      `"${csvEscape(JSON.stringify(r.idxes))}"`,
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'linear_combinations.csv');
}

// ãƒœã‚¿ãƒ³å‹•ä½œï¼šè¨ˆç®— â†’ ä¸¦ã¹æ›¿ãˆ â†’ è¡¨ç¤º
function bindLinearButtonsOnce(){
  const calcBtn = document.getElementById('btnCalcLinear');
  const csvBtn  = document.getElementById('btnDownloadLinearCsv');
  if(!calcBtn) return;
  if(calcBtn.__bound) return; // äºŒé‡ãƒã‚¤ãƒ³ãƒ‰é˜²æ­¢
  calcBtn.__bound = true;

  calcBtn.onclick = ()=>{
    try{
      const {start, goal} = getStartGoalPoints();
      const groups = makeCandGroupsFromRestGroups(restGroups, 5, defaultLinearSorter);
      // ç·çµ„åˆã›ãƒã‚§ãƒƒã‚¯ï¼ˆå¤šã™ãã‚‹å ´åˆã¯æ³¨æ„ã ã‘å‡ºã™ï¼‰
      const total = groups.reduce((a,b)=>a*b.length,1);
      if(total > 200000){
        if(!confirm(`çµ„åˆã›ãŒ ${total.toLocaleString()} ä»¶ã‚ã‚Šã¾ã™ã€‚ä¸Šé™20ä¸‡ä»¶ã¾ã§è¨ˆç®—ã—ã¾ã™ã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`)) return;
      }
      const combos = enumerateAllOnePerTrigger(groups, /*hardCap*/200000);

      // è·é›¢è¨ˆç®—
      const rows = combos.map(idxPicks=>{
        const meters = comboLinearDistanceMeters(start, idxPicks, goal);
        return {
          meters,
          km: meters/1000,
          picks: idxPicks,
          idxes: idxPicks.map((p, i)=> groups[i].indexOf(p)) // ã©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é¸ã‚“ã ã‹
        };
      });

      // åˆè¨ˆè·é›¢ãŒçŸ­ã„é †ã«ã‚½ãƒ¼ãƒˆ
      rows.sort((a,b)=>a.meters - b.meters);

      renderLinearResults(rows);
    }catch(e){
      alert('ç›´ç·šè·é›¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼: ' + (e.message || e));
      console.error(e);
    }
  };

  if(csvBtn){
    csvBtn.onclick = ()=> downloadLinearCsv();
  }
}

// åˆæœŸåŒ–æ™‚ã«ãƒã‚¤ãƒ³ãƒ‰
//window.addEventListener('DOMContentLoaded', bindLinearButtonsOnce);


// ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã«1åœ°ç‚¹ãšã¤é¸ã¶å…¨çµ„ã¿åˆã‚ã›ã‚’åˆ—æŒ™ï¼ˆä¸Šé™ã‚ã‚Šï¼‰
function enumerateCombinations(poiGroups, perGroupLimit = 3){
  const groups = poiGroups.map(arr => (arr || []).slice(0, perGroupLimit));
  const combos = [];

  function dfs(i, acc){
    if (i === groups.length){
      combos.push(acc.slice());
      return;
    }
    const g = groups[i];
    if (!g.length){
      acc.push(null);
      dfs(i+1, acc);
      acc.pop();
      return;
    }
    for (const p of g){
      acc.push(p);
      dfs(i+1, acc);
      acc.pop();
    }
  }

  dfs(0, []);
  return combos;
}

// çµ„ã¿åˆã‚ã›ãƒ«ãƒ¼ãƒˆã®ãƒ¬ã‚°çµ±è¨ˆã‚’å–å¾—ï¼ˆORSå‘¼ã³å‡ºã—ï¼‰
async function routeLegStatsForWaypoints(wps, profile){
  const body = { coordinates: wps.map(p=>[p.lon,p.lat]), elevation:true, extra_info:['steepness'], preference:'fastest' };
  const feature = (await dir(body, profile)).features[0];
  const mass=75, flat=18;
  const stats = await calcLegStats(feature, mass, flat);
  return { feature, stats };
}

// ãƒ«ãƒ¼ãƒˆã®ç´¯ç©è·é›¢[m]/æ™‚é–“[s]/ã‚¨ãƒãƒ«ã‚®ãƒ¼[kJ]ã‚’æ§‹ç¯‰
function buildCums(feature, mass=75, flat=18){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length>=3;
  const segs   = feature.properties.segments||[];
  const cum = { D:[0], T:[0], E:[0] };
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, t=st.duration||0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cum.D.push(cum.D.at(-1)+d);
      cum.T.push(cum.T.at(-1)+t);
      cum.E.push(cum.E.at(-1)+dE);
    }
  }
  return {cum, coords};
}

// POIã‚’ãƒ«ãƒ¼ãƒˆæŠ˜ã‚Œç·šã¸å°„å½±ã—ã€ãã®åœ°ç‚¹ã®ç´¯ç©å€¤ã‚’å†…æŒ¿ã§å–å¾—
function projectToRoute(lat,lon, coords, cum){
  let best={i0:0,i1:1,frac:0,dist:Infinity, stepIdx:1};
  let stepIdx=1;
  for(let i=1;i<coords.length;i++, stepIdx++){
    const A=L.latLng(coords[i-1][1],coords[i-1][0]);
    const B=L.latLng(coords[i][1],  coords[i][0]);
    const P=L.latLng(lat,lon);
    const AB=[B.lat-A.lat, B.lng-A.lng];
    const AP=[P.lat-A.lat, P.lng-A.lng];
    const ab2=AB[0]*AB[0]+AB[1]*AB[1]||1e-12;
    let t=(AP[0]*AB[0]+AP[1]*AB[1])/ab2; t=Math.max(0,Math.min(1,t));
    const Q=L.latLng(A.lat+AB[0]*t, A.lng+AB[1]*t);
    const d=P.distanceTo(Q);
    if(d<best.dist){ best={i0:i-1,i1:i,frac:t,dist:d, stepIdx:i}; }
  }
  const i = best.stepIdx;
  const lerp=(arr)=>{ const v0=arr[i-1], v1=arr[i]??v0; return v0 + (v1-v0)*best.frac; };
  return { cumD:lerp(cum.D), cumT:lerp(cum.T), cumE:lerp(cum.E), perpM: best.dist };
}

/* ===== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼šå€™è£œæ¤œæŸ»ï¼†æœªæ¡ç”¨ã®å¼·åˆ¶è£œä¿® ===== */

// iç•ªç›®ãƒˆãƒªã‚¬ãƒ¼ã«æœ‰åŠ¹å€™è£œ(_proj.cumDãŒæœ‰é™)ãŒã‚ã‚‹ã‹ï¼Ÿ
function hasValidCand(restGroups, i){
  const g = restGroups[i];
  if (!g) return false;
  const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
  return valid.length > 0;
}

// æœªæ¡ç”¨(null)ã‚’æ®‹ã•ãªã„ãŸã‚ã®è£œä¿®ï¼š
// å€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼ã§ã¯ã€ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«æœ€ã‚‚è¿‘ã„å€™è£œã§ç©´åŸ‹ã‚ã™ã‚‹
function repairNullPicks(restGroups, cumTotals, picks){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;
  if (!R || !Number.isFinite(totalD) || totalD <= 0) return picks;

  const out = picks.slice();
  for (let i = 0; i < R; i++){
    if (out[i]) continue;                        // æ—¢ã«æ¡ç”¨æ¸ˆã¿
    if (!hasValidCand(restGroups, i)) continue;  // ç‰©ç†çš„ã«å€™è£œãªã—ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—

    const g = restGroups[i];
    const target = totalD * (i + 1) / (R + 1);
    const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    if (!valid.length) continue;

    valid.sort((a,b)=>Math.abs(a._proj.cumD - target) - Math.abs(b._proj.cumD - target));
    out[i] = valid[0];
  }
  return out;
}

// ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒã‚’1å›å®Ÿè¡Œã—ã¦çµæœé…åˆ—ã‚’è¿”ã™ï¼ˆUIã«ã¯ã¾ã è¡¨ç¤ºã—ãªã„ï¼‰
function runBeamSearchOnce(restGroups, cumTotals) {
  const triggersWithCand = (restGroups || []).reduce((n, g) => {
    const valid = (g?.pois || []).filter(
      p => p && p._proj && Number.isFinite(p._proj.cumD)
    );
    return n + (valid.length ? 1 : 0);
  }, 0);

  const top = beamSearch(
    restGroups,
    cumTotals,
    /*width*/ 3,
    /*minRest*/ triggersWithCand,
    /*nullPenalty*/ 1e6,
    /*forbidNullWhenCand*/ true
  );

  // è¡¨ç¤ºç”¨ã« picks/picksByTrigger ã‚’æ•´å½¢ã—ã¦è¿”ã™
  return top.map(t => ({
    score: t.score,
    stats: t.stats,
    picksByTrigger: t.picksByTrigger,
    picks: t.picksByTrigger.filter(Boolean)
  }));
}

async function viterbiRouteCost(p1, p2, profile){
  const coords = [[p1.lon,p1.lat], [p2.lon,p2.lat]];
  const res = await orsDirections(coords, profile);

  const dist = res.features[0].properties.summary.distance;
  const time = res.features[0].properties.summary.duration;
  const elev = res.features[0].properties.ascent;  // æ¨™é«˜å·®

  const energy = energyFromRoute(res); // kJè¨ˆç®—

  return { dist, time, energy };
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ç·å½“ãŸã‚Š (ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å»ƒæ­¢ãƒ»ãƒªãƒŸãƒƒãƒˆç·©å’Œç‰ˆ)
   ========================================================== */
async function runBruteforceOnce(start, goal, restGroups, profile, onProgress){
  const sourceGroups = (restGroups && restGroups.length) ? restGroups : window.restGroups;
  if (!sourceGroups || !sourceGroups.length) throw new Error('RestGroups not found');
  const poiGroups = sourceGroups.map(g => Array.isArray(g.pois)?g.pois : (Array.isArray(g)?g:[]));
  
  // POIä»¶æ•°ä¸Šé™ã®è¨­å®šå€¤ã‚’å–å¾—
  const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
  const combos = enumerateCombinations(poiGroups, perGroupLimit);
  
  if (!combos.length) throw new Error('No combinations');

  // â˜…ä¿®æ­£: ãƒªãƒŸãƒƒãƒˆã‚’200ã‹ã‚‰å¤§å¹…ã«å¢—ã‚„ã—ã€confirmï¼ˆç¢ºèªç”»é¢ï¼‰ã‚’å‰Šé™¤
  // å®Ÿé¨“ç”¨ãªã®ã§ã€å¤šå°‘å¤šãã¦ã‚‚æ­¢ã¾ã‚‰ãšã«å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
  const HARD_LIMIT = 1000; 
  if (combos.length > HARD_LIMIT) {
    // ã•ã™ãŒã«å¤šã™ãã‚‹å ´åˆã®ã¿ã‚¨ãƒ©ãƒ¼ã§æ­¢ã‚ã‚‹ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥é˜²æ­¢ï¼‰
    throw new Error(`çµ„ã¿åˆã‚ã›ãŒå¤šã™ãã¾ã™ (${combos.length}ä»¶)ã€‚POIä»¶æ•°ä¸Šé™ã‚’æ¸›ã‚‰ã—ã¦ãã ã•ã„ã€‚`);
  } else if (combos.length > 1000) {
    console.warn(`[ç·å½“ãŸã‚Š] çµ„ã¿åˆã‚ã›æ•°ãŒ ${combos.length} ä»¶ã‚ã‚Šã¾ã™ã€‚æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ãŒå®Ÿè¡Œã—ã¾ã™ã€‚`);
  }

  // â€»ã“ã“ã¯å‚ç…§ã•ã‚Œãªããªã‚‹ãŒã€ä»–ã®æŒ‡æ¨™ç”¨ã«æ®‹ã—ã¦ãŠã
  const ideals = getIdealPerLegs(); 

  const results = [];
  const tStart = performance.now();
  const orsStart = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitStart = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  for (let i = 0; i < combos.length; i++){
    if (onProgress) onProgress(i, combos.length);
    const cmb = combos[i];
    const picks = cmb.filter(Boolean);
    const wps = [start, ...picks, goal].map(p => ({ lat: p.lat, lon: p.lon, name: p.name || 'POI' }));
    try {
      // APIè² è·è»½æ¸›ã®ãŸã‚ã®ã‚¦ã‚§ã‚¤ãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦èª¿æ•´ã—ã¦ãã ã•ã„ï¼‰
      await new Promise(r => setTimeout(r, 200)); 
      
      const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);
      
      // å‹•çš„ç†æƒ³è·é›¢ã§ã®MSEè¨ˆç®—
      const distScore = (typeof calcDistMseFromFeature === 'function') 
        ? calcDistMseFromFeature(feature, null) : 0;
        
      results.push({ score: distScore, rawScore: distScore, feature, picks, picksByTrigger: cmb, stats });
    } catch (e){
        // å€‹åˆ¥ã®ãƒ«ãƒ¼ãƒˆè¨ˆç®—å¤±æ•—ã¯ç„¡è¦–ã—ã¦æ¬¡ã¸
    }
  }

  results.sort((a, b) => (a.score ?? 1e9) - (b.score ?? 1e9));
  results.forEach((r, idx) => r.bfRank = idx + 1);

  const tEnd = performance.now();
  const orsEnd = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitEnd = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  results._breakdown = {
      searchOrs:  orsEnd - orsStart,
      searchWait: waitEnd - waitStart,
      searchTime: tEnd - tStart,
      drawOrs: 0, drawWait: 0, drawTime: 0,
      isCached: false
  };

  return results;
}
  
/* ===== ã€ä¿®æ­£ç‰ˆã€‘å°„å½±ãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰ ===== */
function ensureProjections() {
  const base = routeData.arterial || routeData.fastest;
  // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®ç¢ºèªï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚‚ãƒã‚§ãƒƒã‚¯ï¼‰
  const groups = (restGroups && restGroups.length) ? restGroups : window.restGroups;
  
  if (!base || !Array.isArray(groups) || !groups.length) return;

  // ãƒ«ãƒ¼ãƒˆä¸Šã®ç´¯ç©ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
  const { cum, coords } = buildCums(base);

  window.__routeCums = { cum, coords };
  window.__cumTotals = {
    D: cum.D.at(-1),
    T: cum.T.at(-1),
    E: cum.E.at(-1)
  };

  // å„ä¼‘æ†©ã‚°ãƒ«ãƒ¼ãƒ—ã® POI ã«å°„å½±ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜ã‘ã‚‹
  for (let ti = 0; ti < groups.length; ti++){
    // POIãƒªã‚¹ãƒˆã‚’å–ã‚Šå‡ºã—ï¼ˆæ§‹é€ åˆ¤å®šï¼‰
    let g = groups[ti];
    let arr = [];
    if (g && Array.isArray(g.pois)) arr = g.pois;
    else if (Array.isArray(g)) arr = g;

    for (let pi = 0; pi < arr.length; pi++){
      const p = arr[pi];
      if (!p) continue;

      // IDä»˜ä¸
      p._triggerId = ti;
      p._poiIdInTrigger = pi;
      
      // åå‰ãŒç„¡ã‘ã‚Œã°è‡ªå‹•ä»˜ä¸
      if (!p.name) {
        const type = (p.tags && p.tags.amenity) ? p.tags.amenity : 'POI';
        p.name = `${type}_${ti}_${pi}`;
      }

      // æ—¢ã« _proj ãŒã‚ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
      if (p._proj && Number.isFinite(p._proj.cumD)) continue;

      // å°„å½±è¨ˆç®—
      p._proj = projectToRoute(p.lat, p.lon, coords, cum);
    }
  }
  console.log("[ensureProjections] å°„å½±ã‚’å†è¨ˆç®—ã—ã¾ã—ãŸ");
}

// å¹¹ç·šåº¦ï¼ˆå¤§ãã„ã»ã©â€œå¹¹ç·šã£ã½ã„â€ï¼‰
// ã“ã“ã§ã¯ã€Œè·é›¢ãŒé•·ãã¦å¹³å‡é€Ÿåº¦ãŒé«˜ã„ï¼å¹¹ç·šã£ã½ã„ã€ã¨ã„ã†å˜ç´”ãªæŒ‡æ¨™ã«ã—ã¦ã„ã¾ã™ã€‚
function arterialScore(feature){
  if (!feature || !feature.properties || !feature.properties.summary) {
    return -Infinity;
  }

  const sum = feature.properties.summary;
  const distM = Number(sum.distance) || 0;   // m
  const timeS = Number(sum.duration) || 1;   // sï¼ˆ0é™¤ç®—ã‚’é¿ã‘ã‚‹ãŸã‚ 1 ã§ä¿é™ºï¼‰

  const distKm   = distM / 1000;
  const timeH    = timeS / 3600;
  const avgSpeed = distKm / timeH;           // km/h ç›¸å½“

  // ãƒ»å¹³å‡é€Ÿåº¦ãŒé«˜ã„ã»ã©ãƒ—ãƒ©ã‚¹
  // ãƒ»ã‚ã‚‹ç¨‹åº¦ã®è·é›¢ãŒã‚ã‚‹ã»ã©ãƒ—ãƒ©ã‚¹
  // â†’ å¹¹ç·šé“è·¯ã‚’é•·ãèµ°ã‚‹ãƒ«ãƒ¼ãƒˆã»ã©ã‚¹ã‚³ã‚¢ãŒå¤§ãããªã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸
  return avgSpeed * distKm;
}

// ä¸Šä½3ä»¶ã‚«ãƒ¼ãƒ‰ã®ã€Œã“ã®çµ„ã¿åˆã‚ã›ã§ãƒ«ãƒ¼ãƒˆè¡¨ç¤ºã€ã‹ã‚‰å‘¼ã°ã‚Œã‚‹
async function showLinearComboRoute(row){
  if (!row || !Array.isArray(row.picks)) {
    throw new Error('ä¸æ­£ãªè¡Œãƒ‡ãƒ¼ã‚¿');
  }

  const { start, goal } = getStartGoalPoints();
  const profile = document.getElementById('profileSelect')?.value || 'cycling-road';

  // çµŒç”±é †ã¯ã€Œãƒˆãƒªã‚¬ãƒ¼é †ã® picks ã‚’ãã®ã¾ã¾ã€
  const wps = [start, ...row.picks, goal].map(p => ({
    lat: p.lat,
    lon: p.lon,
    name: p.name || 'POI'
  }));

  // ORSã§ãƒ«ãƒ¼ãƒˆç”Ÿæˆï¼ˆæ—¢å­˜ãƒ˜ãƒ«ãƒ‘ã‚’å†åˆ©ç”¨ï¼‰
  const out = await routeLegStatsForWaypoints(wps, profile);
  const feature = out?.feature;
  if (!feature) {
    throw new Error('ORS ãƒ«ãƒ¼ãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  // æ—¢å­˜ãƒ¬ã‚¤ãƒ¤ã‚’ã‚¯ãƒªã‚¢ã—ã¦æç”»
  clearRouteLayers();
  const layer = L.geoJSON(feature, {
    style: { color: '#0096ff', weight: 7 }
  }).addTo(map);
  routeLayers['linearTopRoute'] = layer;

  // æ¡ç”¨POIï¼†Start/Goalã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¨­å®šï¼ˆæ—¢å­˜é–¢æ•°ï¼‰
  setComboMarkers(start, row.picks, goal);

  // åã¾ã‚Šèª¿æ•´ï¼ˆgetBounds ã¯ä¸€åº¦ã ã‘å‘¼ã‚“ã§ã‹ã‚‰ isValid() ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
  const bounds = layer.getBounds?.();
  if (bounds && bounds.isValid && bounds.isValid()) {
    map.fitBounds(bounds.pad(0.1));
  } else {
    const fallback = row.picks[0] || start;
    if (fallback) {
      map.flyTo([fallback.lat, fallback.lon], 14);
    }
  }

  // ãƒ«ãƒ¼ãƒˆç¨®åˆ¥ãƒœã‚¿ãƒ³ã®ã€Œactiveã€ã‚’å…¨éƒ¨å¤–ã—ã¦ãŠãï¼ˆä»»æ„ï¼‰
  setActiveButton(null);
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ãƒ‡ãƒ¼ã‚¿è“„ç©ãƒ»CSVå‡ºåŠ›é–¢æ•° (å®Ÿéš›ã«ä½¿ã£ãŸç†æƒ³è·é›¢ã‚’å‡ºåŠ›)
   ========================================================== */
function pushAlgoResultsForCsv(algoCode, label, resultList, elapsedMs, orsCalls, overpassCalls){
  if (!Array.isArray(resultList) || !resultList.length) return;
  if (!Array.isArray(window.__algoCompareRows)) window.__algoCompareRows = [];

  const sorted = resultList.slice().sort((a, b) => (a.score ?? 9e9) - (b.score ?? 9e9));
  
  const isFullOutput = (algoCode === 'bruteforce' || algoCode === 'dbg_bf' || algoCode === 'linear' || algoCode === 'dbg_linear');
  let outputList = isFullOutput ? sorted : sorted.slice(0, 3);

  // åˆæœŸå›ºå®šå€¤ï¼ˆViterbiç­‰ã®åŸºæº–ï¼‰
  const fixedIdeals = (typeof getIdealPerLegs === 'function') ? getIdealPerLegs() : { idealDistPerLeg: 0 };

  outputList.forEach((r, idx)=>{
    const rank = idx + 1;
    const stats = r.stats || { dist:[] };
    
    // â˜…ä¿®æ­£: ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚„è¨ˆç®—å®Ÿæ…‹ã«åˆã‚ã›ã¦ã€Œå®Ÿéš›ã«ä½¿ã£ãŸå¹³å‡è·é›¢ã€ã‚’ç®—å‡ºã™ã‚‹
    let usedIdealDist = fixedIdeals.idealDistPerLeg;

    if (algoCode === 'dbg_bf' || algoCode === 'bruteforce' || algoCode === 'dbg_linear') {
        // ç·å½“ãŸã‚Šç³»ã¯ã€Œè‡ªåˆ†è‡ªèº«ã®å¹³å‡ã€ã‚’ä½¿ã£ã¦ã„ã‚‹ã¯ãš
        if (stats.dist && stats.dist.length > 0) {
            const sum = stats.dist.reduce((a,b)=>a+(Number(b)||0), 0);
            usedIdealDist = sum / stats.dist.length;
        }
    } else if (r.score === r.displayScore && stats.dist && stats.dist.length) {
        // å†ãƒ©ãƒ³ã‚¯ç³»ãªã©ã§ã€ã‚¹ã‚³ã‚¢ãŒMSEè¨ˆç®—ã¨ä¸€è‡´ã™ã‚‹å ´åˆã€å¿µã®ãŸã‚å®Ÿæ¸¬å¹³å‡ã‚’ç¢ºèª
        // (Viterbiæ¢ç´¢ä¸­ã¯å›ºå®šå€¤ã ãŒã€æœ€çµ‚çµæœãƒªã‚¹ãƒˆã«å…¥ã£ã¦ã„ã‚‹ã‚¹ã‚³ã‚¢ãŒã€Œå†ãƒ©ãƒ³ã‚¯å¾Œã€ãªã‚‰å®Ÿæ¸¬å¹³å‡ã«ãªã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚)
        // ã“ã“ã§ã¯ã€Œå›ºå®šå€¤ã€ã¨ã€Œå®Ÿæ¸¬å¹³å‡ã€ã®ã©ã¡ã‚‰ãŒã‚¹ã‚³ã‚¢ã«è¿‘ã„ã‹ã§åˆ¤å®šã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚‚çµ„ã‚ã‚‹ãŒã€
        // ã‚·ãƒ³ãƒ—ãƒ«ã«ã€ŒViterbiæ¢ç´¢çµæœã€ã¨ã—ã¦ã¯å›ºå®šå€¤ã‚’è¡¨ç¤ºã—ã€
        // å†ãƒ©ãƒ³ã‚¯(rerank)æ¸ˆã¿ãªã‚‰å®Ÿæ¸¬å¹³å‡ã‚’è¡¨ç¤ºã™ã‚‹ã®ãŒè¦ªåˆ‡ã€‚
        
        if (algoCode.includes('rerank')) {
             const sum = stats.dist.reduce((a,b)=>a+(Number(b)||0), 0);
             usedIdealDist = sum / stats.dist.length;
        }
    }

    const sigmaDist   = stdDev(stats.dist || []);
    const sigmaTime   = stdDev(stats.time || []);
    const sigmaEnergy = stdDev(stats.energy || []);

    let poiList = (r.picks || r.picksByTrigger || []).filter(Boolean);
    if (Array.isArray(poiList[0])) poiList = poiList.flat().filter(Boolean);
    const poiNames = poiList.map(p => p.name || 'POI').join(' -> ');
    const poiIds   = (typeof getPoiId === 'function') ? poiList.map(p => getPoiId(p)).join(' -> ') : '';
    const poiLatLngs = poiList.map(p => `${(p.lat??0).toFixed(6)},${(p.lon??0).toFixed(6)}`).join(' | ');

    window.__algoCompareRows.push({
      algo: algoCode,
      label,
      rank,
      bfRank: (r.bfRank ?? '-'), 
      score: (typeof r.score === 'number') ? r.score.toFixed(4) : r.score,
      rawScore: (r.rawScore != null) ? Number(r.rawScore).toFixed(4) : '',
      
      sigmaDist: (typeof sigmaDist === 'number') ? sigmaDist.toFixed(4) : '',
      sigmaTime: (typeof sigmaTime === 'number') ? sigmaTime.toFixed(4) : '',
      sigmaEnergy: (typeof sigmaEnergy === 'number') ? sigmaEnergy.toFixed(4) : '',
      
      timeMs: elapsedMs ?? 0,
      orsCalls: orsCalls ?? 0,
      overpassCalls: overpassCalls ?? 0,
      
      idealDistKm: usedIdealDist, // â˜…ä¿®æ­£ã—ãŸå€¤ã‚’å‡ºåŠ›

      poiNames, poiIds, poiLatLngs
    });
  });
  console.log(`[pushAlgoResults] ${algoCode}: ${outputList.length} rows added.`);
}
  
/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘çµæœãƒªã‚¹ãƒˆè¡¨ç¤º (æ”¹è¡Œãƒ»æ•´å½¢å¯¾å¿œ)
   ========================================================== */
function showAlgoListInPanel(panel, list, algoCode){
  if (!panel) return;
  // é€²æ—ãƒãƒ¼ç­‰ã®ç›´å¾Œã«æ”¹è¡Œã‚’å…¥ã‚Œã‚‹
  // panel.textContent += '\n'; 

  if (!Array.isArray(list) || !list.length){
    panel.textContent += '(å€™è£œãªã—)\n';
    return;
  }
  
  const sorted = list.slice().sort((a, b) => {
    const sA = (typeof a.score === 'number') ? a.score : 999999;
    const sB = (typeof b.score === 'number') ? b.score : 999999;
    return sA - sB;
  });

  const top = sorted.slice(0, 3);

  top.forEach((r, idx)=>{
    const rank = idx + 1;
    const score    = r.score    ?? null;
    const stats    = r.stats || {};
    const sigDist = (stats.dist && stats.dist.length) ? stdDev(stats.dist) : null;
    const sigTime = (stats.time && stats.time.length) ? stdDev(stats.time) : null;
    const sigEn   = (stats.energy && stats.energy.length) ? stdDev(stats.energy) : null;

    const picksArr = (r.picks || r.picksByTrigger || []);
    const poiNames = picksArr.filter(Boolean).map(p => p.name || 'POI').join(' -> ');

    panel.textContent += `[#${rank}]\n`;
    if (score != null)    panel.textContent += `  score=${score.toFixed(4)}\n`;
    if (r.bfRank != null && r.bfRank !== '-') {
      panel.textContent += `  bf_rank=${r.bfRank}\n`;
    }
    if (sigDist != null) panel.textContent += `  Ïƒè·é›¢=${sigDist.toFixed(3)}\n`;
    if (sigTime != null) panel.textContent += `  Ïƒæ™‚é–“=${sigTime.toFixed(3)}\n`;
    if (sigEn   != null) panel.textContent += `  Ïƒã‚¨ãƒãƒ«ã‚®ãƒ¼=${sigEn.toFixed(3)}\n`;
    panel.textContent += `  POI: ${poiNames}\n\n`;
  });
}
  
/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒCSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ç†æƒ³è·é›¢åˆ—ã‚’è¿½åŠ )
   ========================================================== */
function downloadAlgoCompareCsv(){
  const rows = window.__algoCompareRows || [];
  if (!rows.length){
    alert('å…ˆã«ã€Œã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }

  const header = [
    'algo',
    'label',
    'rank',
    'bf_rank',
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'time_ms',
    'ors_calls',
    'overpass_calls',
    'ideal_dist_km',  // â˜…è¿½åŠ 
    'poi_names',
    'poi_ids',
    'poi_latlngs'
  ];

  const bodyRows = rows.map(r => [
    r.algo ?? '',
    `"${csvEscape(r.label ?? '')}"`,
    r.rank ?? '',
    r.bfRank ?? '',
    r.score ?? '',
    r.rawScore ?? '',
    r.sigmaDist ?? '',
    r.sigmaTime ?? '',
    r.sigmaEnergy ?? '',
    r.timeMs ?? '',
    r.orsCalls ?? '',
    r.overpassCalls ?? '',
    formatNum(r.idealDistKm, 3), // â˜…å‡ºåŠ› (ã“ã“ãŒæŠœã‘ã¦ã„ã¾ã—ãŸ)
    `"${csvEscape(r.poiNames ?? '')}"`,
    `"${csvEscape(r.poiIds ?? '')}"`,
    `"${csvEscape(r.poiLatLngs ?? '')}"`
  ]);

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'algo_compare_debug.csv');
}

function renderBruteforceAllResults(results){
  const box = $('bruteforceAllList');
  const btn = $('btnDownloadBruteforceCsv');
  if (!box) return;

  if (!results || !results.length){
    box.textContent = 'ï¼ˆç·å½“ãŸã‚Šã®çµæœãŒã‚ã‚Šã¾ã›ã‚“ï¼‰';
    if (btn) btn.disabled = true;
    return;
  }

  if (btn) btn.disabled = false;

  window.__bruteforceAllResults = results;
  
  const lines = [];
  results.forEach((r, idx) => {
    const rank = idx + 1;
    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };
    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    lines.push(
      `#${rank} score=${(r.score ?? 0).toFixed(4)} raw=${(r.rawScore ?? r.score ?? 0).toFixed(4)} ` +
      `Ïƒd=${sig.dist.toFixed(2)}km Ïƒt=${sig.time.toFixed(2)}min ÏƒE=${sig.energy.toFixed(1)}kJ`
    );
    lines.push(
      `   picks: ${names}`
    );
  });

  box.textContent = lines.join('\n');
}

function downloadBruteforceCsv(){
  const rows = window.__bruteforceAllResults || [];
  if (!rows.length){
    alert('ç·å½“ãŸã‚ŠãŒã¾ã å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“');
    return;
  }

  const header = [
    'rank',
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'poi_names'
  ];

  const bodyRows = rows.map((r, idx) => {
    const rank = idx + 1;

    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };

    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    return [
      rank,
      r.score ?? '',
      r.rawScore ?? '',
      sig.dist.toFixed(3),
      sig.time.toFixed(3),
      sig.energy.toFixed(3),
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'bruteforce_all_combos.csv');
}

// ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ãƒ“ãƒ¼ãƒ ã‚’å…¨éƒ¨æ¶ˆã™
function clearRestBeams() {
  if (restBeamLayer) {
    restBeamLayer.clearLayers();
  }
}

// restGroups ã‚’ã‚‚ã¨ã«ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ãƒ“ãƒ¼ãƒ ã‚’å¼•ã
function drawRestBeams() {
  if (!restBeamLayer) return;
  if (!window.restGroups || !Array.isArray(window.restGroups)) return;

  // ã„ã£ãŸã‚“å…¨éƒ¨æ¶ˆã™
  clearRestBeams();

  window.restGroups.forEach(group => {
    if (!group) return;

    // group.rest ã«ã€Œä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã®åœ°ç‚¹ã€ãŒå…¥ã£ã¦ã„ã‚‹æƒ³å®š
    const r = group.rest;
    const pois = group.pois || [];
    if (!r || !Array.isArray(pois) || !pois.length) return;

    const baseLat = Number(r.lat);
    const baseLon = Number(r.lon);
    if (!Number.isFinite(baseLat) || !Number.isFinite(baseLon)) return;

    const baseLL = L.latLng(baseLat, baseLon);

    pois.forEach(p => {
      if (!p) return;
      const lat = Number(p.lat);
      const lon = Number(p.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      const poiLL = L.latLng(lat, lon);

      // ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ç›´ç·šï¼ˆé“ã®ã‚Šãƒ“ãƒ¼ãƒ ï¼‰
      const line = L.polyline([baseLL, poiLL], {
        color: 'orange',     // ãŠå¥½ã¿ã§
        weight: 2,
        opacity: 0.7,
        dashArray: '4,4'     // ç‚¹ç·šã£ã½ã
      });

      line.addTo(restBeamLayer);
    });
  });
}

// â˜…è¿½åŠ ï¼šViterbi(DP)ã®åŒºé–“ã‚³ã‚¹ãƒˆã‚’ã€Œã‚¨ãƒãƒ«ã‚®ãƒ¼ã®ã¿(MSE)ã€ã«ã™ã‚‹
function legEnergyMseCost(energyKj, idealEnergyPerLeg){
  const e  = Number(energyKj);
  const ie = Number(idealEnergyPerLeg);
  if (!Number.isFinite(e) || !Number.isFinite(ie)) return Infinity;
  const de = e - ie;
  return de * de;
}

// 2. ã‚¨ãƒƒã‚¸é›†ç´„ (ç†æƒ³è·é›¢ã‚’ä¿æŒ)
function recordViterbiEdge(row){
  if (!window.__collectViterbiEdges) return;
  if (!window.__viterbiEdgeAgg) window.__viterbiEdgeAgg = new Map();

  const fromId = row.fromId || 'unknown';
  const toId   = row.toId   || 'unknown';
  const key = `${fromId}|${toId}`;

  const cur = window.__viterbiEdgeAgg.get(key) || {
    fromId, toId,
    fromName: row.fromName || '',
    toName:   row.toName   || '',
    count: 0,
    sumEnergyKj: 0,
    sumDistKm: 0,
    sumTimeMin: 0,
    sumCost: 0,
    idealEnergyKj: row.idealEnergyKj,
    // â˜…ç†æƒ³è·é›¢ã‚’ä¿æŒ
    idealDistKm: (row.distKm ? (getIdealPerLegs().idealDistPerLeg) : 0)
  };

  cur.count += 1;
  if (Number.isFinite(row.energyKj)) cur.sumEnergyKj += row.energyKj;
  if (Number.isFinite(row.distKm))   cur.sumDistKm   += row.distKm;
  if (Number.isFinite(row.timeMin))  cur.sumTimeMin  += row.timeMin;
  if (Number.isFinite(row.cost))     cur.sumCost     += row.cost;

  window.__viterbiEdgeAgg.set(key, cur);
}
  
// -------------------------------
// bf_rank ä»˜ä¸ç”¨ï¼šçµ„åˆã›ã‚­ãƒ¼ç”Ÿæˆ
//  - picksByTrigger ã‚’å‰æã«ã€Œãƒˆãƒªã‚¬ãƒ¼é †ã€ã‚’å›ºå®šã—ã¦æ¯”è¼ƒ
//  - POIåŒä¸€åˆ¤å®šã¯ lat/lon ã‚’ä¸¸ã‚ã¦æ–‡å­—åˆ—åŒ–ï¼ˆèª¤å·®å¸åï¼‰
// -------------------------------
function comboKeyFromPicksByTrigger(picksByTrigger, decimals = 6){
  const arr = Array.isArray(picksByTrigger) ? picksByTrigger : [];
  const f = (x)=> Number(x).toFixed(decimals);

  return arr.map(p=>{
    if(!p) return 'null';
    const lat = (p.lat ?? p.latitude);
    const lon = (p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼šPOIãƒªã‚¹ãƒˆã‹ã‚‰ä¸€æ„ãªã‚­ãƒ¼ã‚’ä½œã‚‹
   ãƒ»æ•°å€¤å¤‰æ›ã¨toFixed(5)ã§ã€è¡¨è¨˜æºã‚Œã¨è¨ˆç®—èª¤å·®ã‚’å®Œå…¨ã«å¸åã™ã‚‹
   ========================================================== */
function makeRouteKey(picks) {
  if (!Array.isArray(picks)) return '';
  return picks.map(p => {
    if (!p) return 'null';
    // å¼·åˆ¶çš„ã«æ•°å€¤åŒ–ã—ã€å°æ•°ç‚¹5æ¡ï¼ˆç´„1mç²¾åº¦ï¼‰ã§æ–‡å­—åˆ—åŒ–
    // ã“ã‚Œã§ "35.1" ã¨ "35.10000001" ã‚’åŒä¸€è¦–ã•ã›ã‚‹
    const lat = Number(p.lat).toFixed(5);
    const lon = Number(p.lon).toFixed(5);
    return `${lat},${lon}`;
  }).join('|');
}
  
/* ==========================================================
   bfListï¼ˆç·å½“ãŸã‚Šçµæœï¼‰ã‹ã‚‰ rank ãƒãƒƒãƒ—ã‚’ä½œã‚‹
   ========================================================== */
function buildBfRankMap(bfList) {
  const map = new Map();
  let count = 0;
  
  // ãƒªã‚¹ãƒˆã¯æ—¢ã« runBruteforceOnce å†…ã§æ­£ã—ãã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å‰æ
  (bfList || []).forEach((r, idx) => {
    const key = makeRouteKey(r.picks);
    
    // åŒã˜ãƒ«ãƒ¼ãƒˆãŒé‡è¤‡ã—ã¦ã„ãŸå ´åˆã¯ã€ã‚ˆã‚Šä¸Šä½ï¼ˆæœ€åˆã«å‡ºãŸæ–¹=ã‚¹ã‚³ã‚¢ãŒè‰¯ã„æ–¹ï¼‰ã‚’æ¡ç”¨
    if (!map.has(key)) {
      const rank = idx + 1;
      map.set(key, rank);
      
      // ãƒ‡ãƒãƒƒã‚°: 1ä½ã®æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºã™
      if (rank === 1) {
        console.log(`[BfRank] Rank 1 Key generated: ${key}`);
      }
      count++;
    }
  });
  console.log(`[BfRank] Map built with ${count} unique routes.`);
  return map;
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ãƒ©ãƒ³ã‚¯ä»˜ä¸é–¢æ•°ï¼ˆã‚½ãƒ¼ãƒˆæ©Ÿèƒ½ãªã—ï¼‰
   ãƒ»ä»–ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ä¸¦ã³é †ã‚’å£Šã•ãªã„ã‚ˆã†ã€å˜ã« bfRank ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä»˜ã‘ã‚‹ã ã‘ã«ã™ã‚‹
   ========================================================== */
function attachBfRank(resultList, bfRankMap) {
  if (!bfRankMap || !(bfRankMap instanceof Map)) return resultList;
  if (!Array.isArray(resultList)) return resultList;

  resultList.forEach(r => {
    // å…±é€šã®ã‚­ãƒ¼ç”Ÿæˆé–¢æ•°ã‚’ä½¿ã†
    const key = makeRouteKey(r.picks);
    
    if (bfRankMap.has(key)) {
      r.bfRank = bfRankMap.get(key); // æ•°å€¤ (ä¾‹: 1, 47)
    } else {
      r.bfRank = '-'; // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
    }
  });
  
  return resultList;
}

function routeEnergyMseFromStats(stats, idealEnergyPerLeg){
  const eArr = stats && Array.isArray(stats.energy) ? stats.energy : [];
  const n = eArr.length;
  if (!n) return NaN;

  let sum = 0;
  for (let i = 0; i < n; i++){
    const ei = Number(eArr[i]);
    const de = (Number.isFinite(ei) ? ei : 0) - idealEnergyPerLeg;
    sum += de * de;
  }
  return sum / n;
}

// ã€æ–°è¦è¿½åŠ ã€‘1åŒºé–“ã®è·é›¢ã‚³ã‚¹ãƒˆï¼ˆMSEï¼‰: (åŒºé–“è·é›¢ - ç†æƒ³è·é›¢)^2
function legDistMseCost(distKm, idealDistPerLeg){
  const d  = Number(distKm);
  const id = Number(idealDistPerLeg);
  if (!Number.isFinite(d) || !Number.isFinite(id)) return Infinity;
  const diff = d - id;
  return diff * diff;
}

/* ==========================================================
   ã€å¤‰æ›´ç‰ˆã€‘Statsç”¨ã‚³ã‚¹ãƒˆè¨ˆç®— (ãã®ãƒ«ãƒ¼ãƒˆã®å®Ÿæ¸¬ç·è·é›¢ã‚’åŸºæº–ã«ã™ã‚‹)
   ========================================================== */
function routeDistMseFromStats(stats, _unusedFixedIdeal) {
  const dArr = stats && Array.isArray(stats.dist) ? stats.dist : [];
  const n = dArr.length;
  if (!n) return NaN;

  // 1. ã“ã®ãƒ«ãƒ¼ãƒˆè‡ªä½“ã®ç·è·é›¢ã‚’è¨ˆç®—
  let totalKm = 0;
  for (let i = 0; i < n; i++) {
    totalKm += (Number(dArr[i]) || 0); // disté…åˆ—ã¯æ—¢ã«kmå˜ä½
  }

  // 2. å‹•çš„ç†æƒ³è·é›¢
  const dynamicIdealDist = totalKm / n;

  // 3. MSEè¨ˆç®—
  let sum = 0;
  for (let i = 0; i < n; i++) {
    const val = Number(dArr[i]) || 0;
    const diff = val - dynamicIdealDist;
    sum += diff * diff;
  }
  return sum / n;
}

function defaultLinearSorter(a, b){
  const score = p =>
    (Number(p?.distFromTriggerM) || 0) +
    (Number(p?._proj?.perpM) || 0);
  return score(a) - score(b);
}

function sumNums(arr){
  return (arr || []).reduce((a,b)=>a + (Number(b)||0), 0);
}

function finalScoreFromStats(stats, ideals){
  // â˜…å¤‰æ›´ï¼šè·é›¢ã®å‡ç­‰æ€§(MSE)ã‚’è¿”ã™
  return routeDistMseFromStats(stats, ideals.idealDistPerLeg);
}

/* ======================================================
   ã€ä¿®æ­£ç‰ˆã€‘ç†æƒ³ãƒ¬ã‚°ï¼ˆideal per legï¼‰ã‚’è¨ˆç®—
   ï¼ˆwindow.restGroups ã ã‘ã§ãªãã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã® restGroups ã‚‚ç¢ºèªã™ã‚‹ï¼‰
   ====================================================== */
function getIdealPerLegs(){
  const cumTotals = window.__cumTotals || {};
  const totalDkm  = (Number(cumTotals.D) || 0) / 1000;
  const totalTmin = (Number(cumTotals.T) || 0) / 60;
  const totalEkJ  = Number(cumTotals.E)  || 0;

  // â˜…ä¿®æ­£: window.restGroups ãŒæœªå®šç¾©ãªã‚‰ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã® restGroups ã‚’è¦‹ã«è¡Œã
  const groups = (typeof restGroups !== 'undefined' ? restGroups : window.restGroups) || [];
  
  const T = Array.isArray(groups) ? groups.length : 0;
  const R = T + 1;

  return {
    totalDkm, totalTmin, totalEkJ,
    T, R,
    idealDistPerLeg:   R > 0 ? totalDkm  / R : 0,
    idealTimePerLeg:   R > 0 ? totalTmin / R : 0,
    idealEnergyPerLeg: R > 0 ? totalEkJ  / R : 0,
  };
}

// ======================================================
// å…±é€šï¼šæ¯”è¼ƒç”¨ã®ã‚¹ã‚³ã‚¢ï¼ˆä¸¦ã³é †ãƒ»CSVãƒ»è¡¨ç¤ºã‚’ä¸€è‡´ã•ã›ã‚‹ï¼‰
// stats ãŒã‚ã‚Œã° energyMSE ã‚’æœ€å„ªå…ˆï¼ˆç·å½“ãŸã‚Šã¨åŒã˜åœŸä¿µï¼‰
// ======================================================
function unifiedScoreForCompare(r, _unused){ // ç¬¬2å¼•æ•°ã¯ä½¿ã„ã¾ã›ã‚“
  const ideals = getIdealPerLegs(); // ç†æƒ³å€¤ã‚’å†å–å¾—
  // â˜…å¤‰æ›´ï¼šè·é›¢MSEã‚’ä½¿ç”¨
  const e = (r && r.stats) ? routeDistMseFromStats(r.stats, ideals.idealDistPerLeg) : NaN;
  if (Number.isFinite(e)) return e;

  const s = Number(r && r.score);
  if (Number.isFinite(s)) return s;

  const rs = Number(r && r.rawScore);
  if (Number.isFinite(rs)) return rs;

  return Infinity;
}

// å…±é€šï¼šç ´å£Šã—ãªã„ã‚½ãƒ¼ãƒˆï¼ˆå…ƒé…åˆ—ã‚’å£Šã•ãªã„ï¼‰
function sortResultsByUnifiedScore(list, idealEnergyPerLeg){
  const arr = Array.isArray(list) ? list : [];
  return arr.slice().sort((a,b)=>{
    return unifiedScoreForCompare(a, idealEnergyPerLeg) - unifiedScoreForCompare(b, idealEnergyPerLeg);
  });
}

async function runViterbiTopK_Rerank_All_API_Dedupe(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: true
  });
}

function getAbViterbiOpt(){
  const auto = !!document.getElementById('abAutoParams')?.checked;

  const bw = Number(document.getElementById('abBeamWidth')?.value);
  const tk = Number(document.getElementById('abTopK')?.value);

  const opt = {};
  if (!auto){
    if (Number.isFinite(bw) && bw > 0) opt.beamWidth = Math.floor(bw);
    if (Number.isFinite(tk) && tk > 0) opt.topK      = Math.floor(tk);
  }
  return opt; // auto=true ã®ã¨ãã¯ {} ã‚’è¿”ã™ï¼ˆautoBeamParamsãŒåŠ¹ãï¼‰
}

// lat/lonæ­£è¦åŒ–ï¼ˆæºã‚Œå¸åï¼‰
function normLL(p){
  if(!p) return null;
  const lat = Number(p.lat ?? p.latitude ?? p.y);
  const lon = Number(p.lon ?? p.lng ?? p.longitude ?? p.x);
  if(!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
  return { lat, lon };
}

function distMeters(a, b){
  const A = normLL(a), B = normLL(b);
  if(!A || !B) return Infinity;

  if (window.L && L.latLng){
    return L.latLng(A.lat, A.lon).distanceTo(L.latLng(B.lat, B.lon));
  }
  // ç°¡æ˜“ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆé›‘ã§OKï¼‰
  const dx = (A.lat - B.lat) * 111320;
  const dy = (A.lon - B.lon) * 111320;
  return Math.hypot(dx, dy);
}

// start/goalã«è¿‘ã„ç«¯ãƒˆãƒªã‚¬ãƒ¼ã‚’waypointsã«å·®ã—è¾¼ã‚€ã‹åˆ¤æ–­
function maybeEndTriggersAsWaypoints(start, goal, restGroups, opt){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!T) return { addStartTrig:false, addGoalTrig:false, startTrig:null, goalTrig:null };

  const thr = Number(opt?.adjacentMeters) || 80;

  const startTrig = restGroups[0]?.rest || null;
  const goalTrig  = restGroups[T-1]?.rest || null;

  const addStartTrig = !!(opt?.includeEndTriggers && startTrig && distMeters(start, startTrig) <= thr);
  const addGoalTrig  = !!(opt?.includeEndTriggers && goalTrig  && distMeters(goal,  goalTrig)  <= thr);

  return { addStartTrig, addGoalTrig, startTrig, goalTrig };
}

// è¡¨ç¤ºãƒ»statsè¨ˆç®—ç”¨ã®waypointsã‚’ä½œã‚‹ï¼ˆå¿…è¦ãªã‚‰ç«¯ãƒˆãƒªã‚¬ãƒ¼ã‚’å·®ã—è¾¼ã‚€ï¼‰
function buildWaypointsForRoute(start, goal, picks, restGroups, opt){
  const ends = maybeEndTriggersAsWaypoints(start, goal, restGroups, opt);

  const wps = [];
  wps.push(start);

  if (ends.addStartTrig) wps.push(ends.startTrig);

  (picks || []).forEach(p=>{ if (p) wps.push(p); });

  if (ends.addGoalTrig) wps.push(ends.goalTrig);

  wps.push(goal);

  // ORSå…¥åŠ›ç”¨ã« lat/lon ã‚’ç¢ºå®ŸåŒ–
  return wps.map(p => {
    const ll = normLL(p) || {lat:NaN, lon:NaN};
    return {
      lat: ll.lat,
      lon: ll.lon,
      name: p?.name || 'POI'
    };
  });
}

// ======================================================
// NEW å¯¾ç­–Cï¼ˆç½®ãæ›ãˆæ¡ˆï¼‰:
//  - DPã§ã¯ãªã Beamï¼ˆè¿‘ä¼¼ï¼‰
//  - å„æ®µã§ã€Œstart + ã“ã‚Œã¾ã§ã®picks + æ¬¡å€™è£œ (+ goal)ã€ã‚’1å›ã®ORSã§è©•ä¾¡
//  - beamWidth æœ¬ã ã‘æ®‹ã™
//  - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§åŒã˜waypointsåˆ—ã®å†è¨ˆç®—ã‚’é¿ã‘ã‚‹
// ======================================================
function wpsKey(points, decimals = 6){
  const f = (x)=> Number(x).toFixed(decimals);
  return (points || []).map(p=>{
    if(!p) return 'null';
    const lat = Number(p.lat ?? p.latitude);
    const lon = Number(p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

async function orsRouteCached(wps, profile, cache){
  const key = wpsKey(wps, 6);
  if (cache && cache.has(key)) return cache.get(key);

  const out = await routeLegStatsForWaypoints(
    wps.map(p=>({ lat:p.lat, lon:p.lon, name:p.name || 'POI' })),
    profile
  );

  const packed = {
    key,
    feature: out?.feature || null,
    stats: out?.stats || null
  };

  if (cache) cache.set(key, packed);
  return packed;
}

function buildVitGroupsWithFixedRest(restGroups, capPerTrigger, variableCount, sorter){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  const out = [];

  for (let i = 0; i < T; i++){
    const g = restGroups[i];

    if (i < variableCount){
      // å ´åˆåˆ†ã‘ã™ã‚‹
      let pois = Array.isArray(g?.pois) ? g.pois.slice() : [];
      if (typeof sorter === 'function') pois.sort(sorter);
      pois = pois.slice(0, capPerTrigger);

      out.push(pois);
    } else {
      // å›ºå®šã™ã‚‹: ãƒˆãƒªã‚¬ãƒ¼åœ°ç‚¹ã‚’å€™è£œ1å€‹ã¨ã—ã¦å…¥ã‚Œã‚‹
      const r = g?.rest;
      out.push(r ? [r] : []);
    }
  }
  return out;
}

// åå‰ãŒç„¡ã„POIã« POI{triggerIndex}.{id} ã‚’ä»˜ã‘ã‚‹
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const raw = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();

  // â˜…ã€Œä¸æ˜æ‰±ã„ã€åˆ¤å®šã‚’è¿½åŠ ï¼šç©ºæ–‡å­—ã ã‘ã§ãªã 'POI' / 'poi' ã‚‚ç½®æ›å¯¾è±¡ã«ã™ã‚‹
  const isUnknown =
    !raw ||
    /^poi$/i.test(raw) ||                 // "POI" ã ã‘
    /^poi[_\-\s]*$/i.test(raw);           // "POI_" ã¿ãŸã„ãªã®ã‚‚ä¸€å¿œ

  if (!isUnknown) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // 0å§‹ã¾ã‚Š
  return poi;
}

// ======================================================
// 2ç‚¹åŒºé–“ORSã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåŒã˜from/to/profileãªã‚‰å†åˆ©ç”¨ï¼‰
// ======================================================
const __legCache = new Map();

function legKey(from, to, profile, decimals=6){
  const f = x => Number(x).toFixed(decimals);
  const aLat = from?.lat ?? from?.latitude ?? from?.y;
  const aLon = from?.lon ?? from?.lng ?? from?.longitude ?? from?.x;
  const bLat = to?.lat   ?? to?.latitude   ?? to?.y;
  const bLon = to?.lon   ?? to?.lng ?? to?.longitude ?? to?.x;
  return `${profile}::${f(aLat)},${f(aLon)}=>${f(bLat)},${f(bLon)}`;
}
  
function formatNum(x, digits=3){
  const n = Number(x);
  if (!Number.isFinite(n)) return '';
  return n.toFixed(digits);
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘Viterbiã‚¨ãƒƒã‚¸(é›†ç´„) CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ç†æƒ³è·é›¢åˆ—ã‚’è¿½åŠ )
   â€»downloadViterbiEdgesCsv: é›†ç´„ç”¨
   ========================================================== */
function downloadViterbiEdgesCsv(){
  if (window.__viterbiEdgeAgg) {
    // Mapã‹ã‚‰æœ€æ–°ãƒªã‚¹ãƒˆã‚’å†ç”Ÿæˆ
    window.__viterbiAllEdgeRows = Array.from(window.__viterbiEdgeAgg.values()).map(x => {
      const n = Math.max(1, x.count);
      return {
        fromId: x.fromId,
        toId:   x.toId,
        fromName: x.fromName,
        toName: x.toName,
        count: x.count,
        energyKj: x.sumEnergyKj / n,
        distKm: x.sumDistKm / n,
        timeMin: x.sumTimeMin / n,
        cost: x.sumCost / n,
        idealEnergyKj: x.idealEnergyKj,
        idealDistKm: x.idealDistKm // â˜…
      };
    });
  }
  
  const rows = window.__viterbiAllEdgeRows || [];
  if (!rows.length){
    alert('Viterbiã®ã‚¨ãƒƒã‚¸ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    return;
  }

  const esc = s => String(s ?? '').replace(/"/g,'""');

  const header = [
    'from_id', 'to_id', 
    'from_name', 'to_name',
    'count',
    'energy_kJ',
    'dist_km',
    'time_min',
    'cost',
    'ideal_dist_km',   // â˜…è¿½åŠ 
    'ideal_energy_kJ'
  ];

  const lines = [header.join(',')];

  for (const r of rows){
    lines.push([
      r.fromId ?? '',
      r.toId   ?? '',
      `"${esc(r.fromName)}"`,
      `"${esc(r.toName)}"`,
      r.count ?? 1,
      formatNum(r.energyKj, 2),
      formatNum(r.distKm, 3),
      formatNum(r.timeMin, 2),
      formatNum(r.cost, 3),
      formatNum(r.idealDistKm, 3),   // â˜…å‡ºåŠ›
      formatNum(r.idealEnergyKj, 2)
    ].join(','));
  }

  const bom = new Uint8Array([0xEF,0xBB,0xBF]);
  const blob = new Blob([bom, lines.join('\n')], {type:'text/csv;charset=utf-8'});
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `viterbi_edges_agg_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// å¤ã„é–¢æ•°åã§å‘¼ã‚“ã§ã„ã‚‹å ´åˆã®äº’æ›æ€§ç¶­æŒ
window.downloadViterbiLogCsv = downloadViterbiEdgesCsv;
function bindViterbiEdgeUi(){
  const btnShow = document.getElementById('btnShowViterbiEdges');
  const btnHide = document.getElementById('btnHideViterbiEdges');
  const btnDl   = document.getElementById('btnDlViterbiEdgesCsv');
  const pre     = document.getElementById('viterbiEdgePanel');

  if (btnShow) btnShow.onclick = () => {
    if (pre) pre.style.display = 'block';
    renderViterbiEdgePanel();
  };
  if (btnHide) btnHide.onclick = () => {
    if (pre) pre.style.display = 'none';
  };
  if (btnDl) btnDl.onclick = () => downloadViterbiEdgesCsv();
}

function bindViterbiEdgeButtons(){
  const $ = (id)=>document.getElementById(id);

  const btnShow = $('btnShowViterbiEdges');
  const btnHide = $('btnHideViterbiEdges');
  const btnCsv  = $('btnDlViterbiEdgesCsv');

  console.log('[bind] show=', !!btnShow, 'hide=', !!btnHide, 'csv=', !!btnCsv);

  // æ—¢ã«åŒã˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¤šé‡ç™»éŒ²ã—ãªã„ãŸã‚ã®ã‚¬ãƒ¼ãƒ‰ï¼ˆä»»æ„ã ãŒãŠã™ã™ã‚ï¼‰
  if (btnShow && !btnShow.dataset.bound) {
    btnShow.addEventListener('click', () => {
      console.log('[click] show viterbi edges');
      window.__collectViterbiEdges = true;        // åé›†ONï¼ˆã‚ãªãŸã®è¨­è¨ˆã«åˆã‚ã›ã¦ï¼‰
      renderViterbiEdgesPanel?.(true);            // UIæç”»ï¼ˆã‚ã‚‹ãªã‚‰ï¼‰
    });
    btnShow.dataset.bound = '1';
  }

  if (btnHide && !btnHide.dataset.bound) {
    btnHide.addEventListener('click', () => {
      console.log('[click] hide viterbi edges');
      window.__collectViterbiEdges = false;       // åé›†OFF
      renderViterbiEdgesPanel?.(false);
    });
    btnHide.dataset.bound = '1';
  }

  if (btnCsv && !btnCsv.dataset.bound) {
    btnCsv.addEventListener('click', () => {
      console.log('[click] download viterbi edges csv');
      downloadViterbiEdgesCsv();                  // CSV DLé–¢æ•°ï¼ˆå¾Œè¿°ã®å½¢ã§ç”¨æ„ï¼‰
    });
    btnCsv.dataset.bound = '1';
  }
}

// DOMãŒã§ãã¦ã‹ã‚‰ç¢ºå®Ÿã«bind
document.addEventListener('DOMContentLoaded', bindViterbiEdgeButtons);

/* =====================================================================
   ã€ä¿®æ­£ãƒ»çµ±åˆç‰ˆã€‘Viterbiã‚¨ãƒƒã‚¸ãƒ­ã‚°æ©Ÿèƒ½
   â€»ã“ã‚Œã‚’å…ƒã® bindViterbiEdgeButtons ã‚„ renderViterbi... ã®ä»£ã‚ã‚Šã«ä½¿ã£ã¦ãã ã•ã„
   ===================================================================== */

// 1. ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ï¼ˆèª­ã¿è¾¼ã¿æ™‚ã«å®Ÿè¡Œï¼‰
window.addEventListener('DOMContentLoaded', () => {
  const btnShow = document.getElementById('btnShowViterbiEdges');
  const btnHide = document.getElementById('btnHideViterbiEdges');
  const btnDl   = document.getElementById('btnDlViterbiEdgesCsv');

  // ãƒ‡ãƒ¼ã‚¿åé›†ç”¨ãƒ•ãƒ©ã‚°ã‚’ONã«ï¼ˆå¿…é ˆï¼‰
  window.__collectViterbiEdges = true;

  if (btnShow) {
    btnShow.onclick = () => {
      const panel = document.getElementById('viterbiEdgePanel');
      if(panel) {
        panel.style.display = 'block';
        renderViterbiLog();
      }
    };
  }
  
  if (btnHide) {
    btnHide.onclick = () => {
      const panel = document.getElementById('viterbiEdgePanel');
      if(panel) panel.style.display = 'none';
    };
  }
  
  if (btnDl) {
    btnDl.onclick = () => {
      downloadViterbiLogCsv();
    };
  }
});

// 2. ãƒ­ã‚°æç”»é–¢æ•°
function renderViterbiLog() {
  const panel = document.getElementById('viterbiEdgePanel');
  const stat  = document.getElementById('viterbiEdgeStat');
  if (!panel) return;

  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  const rows = window.__viterbiAllEdgeRows || [];
  
  if (stat) stat.textContent = `è¨˜éŒ²ä»¶æ•°: ${rows.length}ä»¶`;

  if (!rows.length) {
    panel.textContent = '(ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„)';
    return;
  }

  // æœ€æ–°500ä»¶ã‚’è¡¨ç¤º
  const slice = rows.slice(-500); 
  
  const header = 'From -> To\tDist(km)\tTime(min)\tEnergy(kJ)\tCost\tStatus';
  const lines = slice.map(r => {
    const status = r.ok ? 'OK' : 'ERR';
    const d = (r.distKm ?? 0).toFixed(2);
    const t = (r.timeMin ?? 0).toFixed(1);
    const e = (r.energyKj ?? 0).toFixed(0);
    const c = (r.cost ?? 0).toFixed(1); 
    
    return `${r.fromName} -> ${r.toName}\t${d}\t${t}\t${e}\t${c}\t${status}`;
  });

  panel.textContent = [header, ...lines].join('\n');
}

// 3. Edge CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (åˆ—ã‚’è¿½åŠ ã—ã¦å‡ºåŠ›)
function downloadViterbiLogCsv() {
  const rows = window.__viterbiAllEdgeRows || [];
  if (!rows.length) {
    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    return;
  }

  // â˜…ãƒ˜ãƒƒãƒ€ãƒ¼ã« Ideal_Dist_km ã‚’è¿½åŠ 
  const header = [
    'From_ID', 'To_ID', 
    'From_Name', 'To_Name', 
    'Dist_km', 'Time_min', 'Energy_kJ', 'Cost', 
    'Exec_ms', 'Status', 'Error_Msg',
    'Ideal_Dist_km',   // â˜…è¿½åŠ 
    'Ideal_Energy_kJ'  // â˜…è¿½åŠ 
  ];
  
  const csvLines = [header.join(',')];

  rows.forEach(r => {
    const esc = (s) => `"${String(s || '').replace(/"/g, '""')}"`;
    const line = [
      esc(r.fromId),
      esc(r.toId),
      esc(r.fromName),
      esc(r.toName),
      r.distKm ?? '',
      r.timeMin ?? '',
      r.energyKj ?? '',
      r.cost ?? '',
      r.ms ?? '',
      r.ok ? 'OK' : 'Error',
      esc(r.errMsg),
      formatNum(r.idealDistKm, 3),   // â˜…å€¤å‡ºåŠ›
      formatNum(r.idealEnergyKj, 2)
    ];
    csvLines.push(line.join(','));
  });

  const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
  const blob = new Blob([bom, csvLines.join('\r\n')], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `viterbi_edges_${new Date().toISOString().slice(0,19).replace(/[-:T]/g,'')}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

/* ==============================================
   æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒæ©Ÿèƒ½ï¼ˆå¼·åŠ›ç‰ˆï¼‰
   ============================================== */
let manualRouteLayerGroup = null;

// ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
function getGlobalRestGroups() {
  // window.restGroups ã‹ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã® restGroups ã‚’æ¢ã™
  if (typeof restGroups !== 'undefined' && Array.isArray(restGroups)) return restGroups;
  if (window.restGroups && Array.isArray(window.restGroups)) return window.restGroups;
  return [];
}

// 1. ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã®UIã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateManualRouteUI() {
  console.log('[ManualRoute] updateManualRouteUI called');
  
  const container = document.getElementById('manualRouteSelectors');
  if (!container) return;
  container.innerHTML = '';

  const groups = getGlobalRestGroups();
  console.log('[ManualRoute] restGroups count:', groups.length);

  if (!groups || !groups.length) {
    container.innerHTML = '<span style="color:red;">ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚<br>1. ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚<br>2. ãã‚Œã§ã‚‚å‡ºãªã„å ´åˆã¯ã“ã®ä¸Šã®ã€Œæ›´æ–°ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</span>';
    return;
  }

  // ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã«ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ä½œæˆ
  groups.forEach((g, idx) => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '8px';

    const label = document.createElement('span');
    label.textContent = `ãƒˆãƒªã‚¬ãƒ¼#${idx + 1}:`;
    label.style.minWidth = '70px';
    label.style.fontWeight = 'bold';

    const select = document.createElement('select');
    select.id = `manualSel_${idx}`;
    select.style.flex = '1';

    // å€™è£œPOIã‚’optionã«è¿½åŠ 
    const pois = Array.isArray(g.pois) ? g.pois : [];
    
    if (pois.length === 0) {
      const opt = document.createElement('option');
      opt.text = '(å€™è£œãªã—)';
      opt.value = -1;
      select.add(opt);
      select.disabled = true;
    } else {
      pois.forEach((p, pIdx) => {
        const name = p.name || `POI${idx}_${pIdx}`;
        const opt = document.createElement('option');
        opt.text = name;
        opt.value = pIdx;
        select.add(opt);
      });
      select.selectedIndex = 0;
    }

    row.appendChild(label);
    row.appendChild(select);
    container.appendChild(row);
  });
  
  console.log('[ManualRoute] UI updated successfully');
}
/* ==============================================
   ã€å†ã€…ä¿®æ­£ç‰ˆã€‘æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒæ©Ÿèƒ½ï¼ˆè©³ç´°ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»NaNå¯¾ç­–ãƒ»ãƒ­ã‚°ä»˜ãï¼‰
   ============================================== */
window.drawManualComparison = async function() {
  console.log('[ManualRoute] Start');
    
  const infoBox = document.getElementById('manualRouteInfo');
  const btn = document.getElementById('btnDrawManualRoute');
  const profile = document.getElementById('profileSelect')?.value || 'cycling-road'; 

  // æ•°å€¤ã‚’å®‰å…¨ã«å–ã‚Šå‡ºã™ãƒ˜ãƒ«ãƒ‘ãƒ¼
  const safeNum = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  // ç‰©ç†è¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆåŒºé–“ç”¨ï¼‰
  const calcSegEnergy = (seg, mass=75, flat=18) => {
    let e = 0;
    const steps = seg.steps || [];
    // ç°¡æ˜“çš„ã«é«˜ã•ã‚’å–å¾—ã™ã‚‹ã®ã¯é›£ã—ã„ã®ã§ã€flatä¿‚æ•°ã®ã¿ã§è¿‘ä¼¼ã™ã‚‹ã‹ã€
    // ã‚‚ã—Stepsã«elevationæƒ…å ±ãŒãªã‘ã‚Œã°è·é›¢ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ã€‚
    // ã“ã“ã§ã¯ã€å…¨ä½“ã®çµ±ä¸€æ€§ã‚’ä¿ã¤ãŸã‚ã€Œè·é›¢ä¿‚æ•°ã€ã ã‘ã§ç°¡æ˜“æ¯”è¼ƒã™ã‚‹å®‰å…¨ç­–ã‚’ã¨ã‚‹ã‹ã€
    // ã‚ã‚‹ã„ã¯ `energyStepKJ` ãŒä½¿ãˆã‚‹ãªã‚‰ä½¿ã†ã€‚
    // â€»ä»Šå›ã¯æ¯”è¼ƒç”¨ãªã®ã§ã€æ­£ç¢ºæ€§ã‚ˆã‚Šã€Œä¸€æ‹¬ã¨åˆ†å‰²ã®å·®ã€ã‚’è¦‹ã‚‹ãŸã‚ã«
    //   åŒã˜ãƒ­ã‚¸ãƒƒã‚¯(energyStepKJ)ã‚’é€šã™ã‚ˆã†ã«åŠªåŠ›ã™ã‚‹ã€‚
    steps.forEach(st => {
       const d = st.distance || 0;
       // heightæƒ…å ±ã¯ coordinates ã‹ã‚‰å–ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯stepã”ã¨ã®dzãŒä¸æ˜ãªã“ã¨ãŒå¤šã„ã€‚
       // ãã®ãŸã‚ã€Œå¹³åœ°æ›ç®—ã€ã¨ã—ã¦è¨ˆç®—ã™ã‚‹ï¼ˆã‚ºãƒ¬ã®åŸå› ç‰¹å®šã«ã¯ååˆ†ï¼‰
       e += flat * (d/1000); 
    });
    return e;
  };

  if (btn) {
    btn.disabled = true;
    btn.textContent = 'åˆæœŸåŒ–ä¸­...';
  }
  if (infoBox) infoBox.textContent = 'æº–å‚™ä¸­...';

  try {
    // 1. ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯
    let groups = [];
    if (typeof getGlobalRestGroups === 'function') groups = getGlobalRestGroups();
    else if (typeof restGroups !== 'undefined') groups = restGroups;
    else if (window.restGroups) groups = window.restGroups;

    if (!groups || !groups.length) throw new Error('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    if (typeof pts === 'undefined' || !Array.isArray(pts)) throw new Error('åœ°ç‚¹ãƒ‡ãƒ¼ã‚¿(pts)ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    
    const start = pts.find(p => p.type === 'start') || pts[0];
    const goal = pts.find(p => p.type === 'goal') || pts[pts.length - 1];
    if (!start || !goal) throw new Error('ã‚¹ã‚¿ãƒ¼ãƒˆã¾ãŸã¯ã‚´ãƒ¼ãƒ«åœ°ç‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');

    // 2. UIå›å
    const picks = [];
    for (let i = 0; i < groups.length; i++) {
      const sel = document.getElementById(`manualSel_${i}`);
      if (!sel || sel.disabled || sel.value == -1) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã®POIãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`);
      const p = groups[i].pois[Number(sel.value)];
      if (!p) throw new Error(`ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼: é¸æŠã•ã‚ŒãŸPOIãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
      picks.push(p);
    }

    // 3. åœ°å›³ãƒªã‚»ãƒƒãƒˆ
    if (typeof clearRouteLayers === 'function') clearRouteLayers();
    if (typeof markerLayer !== 'undefined') markerLayer.clearLayers();
    if (typeof clearRestBeams === 'function') clearRestBeams();
    if (typeof manualRouteLayerGroup === 'undefined' || manualRouteLayerGroup === null) {
      manualRouteLayerGroup = L.layerGroup().addTo(map);
    } else {
      manualRouteLayerGroup.clearLayers();
    }

    // 4. APIè¨ˆç®—
    if (btn) btn.textContent = 'ãƒ«ãƒ¼ãƒˆè¨ˆç®—ä¸­...';
    
    const showBatch = document.getElementById('chkManBatch')?.checked;
    const showSeg   = document.getElementById('chkManSeg')?.checked;
    
    // è©³ç´°æ¯”è¼ƒç”¨ã®é…åˆ—
    // { dist(km), time(min), energy(kJ) }
    const batchLegs = [];
    const segLegs   = [];

    // --- A. ä¸€æ‹¬ (Batch) ---
    if (showBatch) {
      const wps = [start, ...picks, goal].map(p => ({ lat: p.lat, lon: p.lon, name: p.name || 'WP' }));
      const out = await routeLegStatsForWaypoints(wps, profile);
      
      if (out && out.feature) {
        L.geoJSON(out.feature, {
          style: { color: '#0055aa', weight: 8, opacity: 0.6 }
        }).bindTooltip("ä¸€æ‹¬ãƒ«ãƒ¼ãƒˆ").addTo(manualRouteLayerGroup);
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆåŒºé–“ï¼‰ã”ã¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
        const segments = out.feature.properties.segments || [];
        
        // stats.energy ã¯ã€Œã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã€ã®é…åˆ—ãªã®ã§ã€åŒºé–“ã«åˆ‡ã‚Šåˆ†ã‘ã‚‹ã®ã¯é›£ã—ã„ã€‚
        // ã“ã“ã§ã¯ segments æƒ…å ±ã‹ã‚‰è·é›¢ã¨æ™‚é–“ã‚’ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯å…¨ä½“ã®æ¯”ç‡ç­‰ã§ç°¡æ˜“é…åˆ†ã™ã‚‹ã‹
        // ã‚‚ã—ãã¯ã€Œè·é›¢ãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“ã‚¨ãƒãƒ«ã‚®ãƒ¼ã€ã§æ¯”è¼ƒã™ã‚‹ã€‚
        // â˜…æ­£ç¢ºã‚’æœŸã™ãŸã‚ã€stats.energyï¼ˆç´¯ç©ï¼‰ã‚’ä½¿ã£ã¦åŒºé–“å·®åˆ†ã‚’ã¨ã‚‹
        
        let processedSteps = 0;
        let prevCumE = 0;
        
        segments.forEach((seg, idx) => {
           // ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«å«ã¾ã‚Œã‚‹ã‚¹ãƒ†ãƒƒãƒ—æ•°
           const stepCount = (seg.steps || []).length;
           
           // stats.energy ã‹ã‚‰ã“ã®åŒºé–“ã®çµ‚äº†åœ°ç‚¹ã®å€¤ã‚’å–å¾—
           // (stats.energyã¯ç´¯ç©é…åˆ—ã¨ä»®å®š)
           let currentLegE = 0;
           if (out.stats && Array.isArray(out.stats.energy) && out.stats.energy.length > 0) {
               // åŒºé–“ã‚¨ãƒãƒ«ã‚®ãƒ¼ = (åŒºé–“çµ‚ã‚ã‚Šã®ç´¯ç©E) - (åŒºé–“å§‹ã¾ã‚Šã®ç´¯ç©E)
               // stats.energyã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯å…¨ã‚¹ãƒ†ãƒƒãƒ—é€šã—ç•ªå·
               const endIndex = Math.min(processedSteps + stepCount - 1, out.stats.energy.length - 1);
               const cumAtEnd = safeNum(out.stats.energy[endIndex]);
               currentLegE = cumAtEnd - prevCumE;
               prevCumE = cumAtEnd;
               processedSteps += stepCount;
           } else {
               // statsãŒãªã„å ´åˆã¯ç°¡æ˜“è¨ˆç®—
               currentLegE = calcSegEnergy(seg);
           }

           batchLegs.push({
               dist: safeNum(seg.distance) / 1000,
               time: safeNum(seg.duration) / 60,
               energy: currentLegE
           });
        });
      }
    }

    // --- B. åŒºé–“ç©ä¸Š (Segmented) ---
    if (showSeg) {
      const points = [start, ...picks, goal];
      
      for (let i = 0; i < points.length - 1; i++) {
        const from = points[i];
        const to = points[i+1];
        
        let legRes = { dist:0, time:0, energy:0 };

        try {
          if (typeof calcLegCostWithApi === 'function') {
             const leg = await calcLegCostWithApi(from, to, profile);
             const e = leg.energyKj ?? leg.energy_kJ ?? leg.energy ?? 0;
             const d = leg.distKm   ?? leg.dist_km   ?? leg.dist   ?? 0;
             const t = leg.timeMin  ?? leg.time_min  ?? leg.time   ?? 0;

             legRes = { dist: safeNum(d), time: safeNum(t), energy: safeNum(e) };

             // æç”»
             const res = await dir({ coordinates: [[from.lon, from.lat], [to.lon, to.lat]], elevation:true }, profile);
             if (res?.features?.[0]) {
                 L.geoJSON(res.features[0], {
                   style: { color: '#aa0000', weight: 4, dashArray: '10, 10', opacity: 1.0 }
                 }).bindTooltip(`åŒºé–“ ${i+1}`).addTo(manualRouteLayerGroup);
             }
          }
        } catch(err) { console.error(err); }
        
        segLegs.push(legRes);
      }
    }

    // 5. çµæœè¡¨ç¤º (HTMLç”Ÿæˆ)
    const fmt = (n, d=1) => safeNum(n).toFixed(d);
    // å·®åˆ†ãŒ0.1ä»¥ä¸Šãªã‚‰èµ¤ãã™ã‚‹
    const diffColor = (a, b) => (Math.abs(safeNum(a) - safeNum(b)) > 0.1) ? '#d00' : '#888';
    
    // åˆè¨ˆè¨ˆç®—
    const sumBatch = batchLegs.reduce((a,b)=>({dist:a.dist+b.dist, time:a.time+b.time, energy:a.energy+b.energy}), {dist:0,time:0,energy:0});
    const sumSeg   = segLegs.reduce((a,b)=>({dist:a.dist+b.dist, time:a.time+b.time, energy:a.energy+b.energy}), {dist:0,time:0,energy:0});

    let html = '<div style="font-size:0.9rem; line-height:1.4;">';

    // --- åˆè¨ˆæ¯”è¼ƒ ---
    html += '<div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:8px;">';
    
    if (showBatch) {
      html += `
      <div style="padding:6px; border:1px solid #0055aa; border-radius:4px; background:#f0f8ff;">
        <div style="font-weight:bold; color:#0055aa; border-bottom:1px solid #cceeff; margin-bottom:4px;">â–  ä¸€æ‹¬ (Total)</div>
        D: ${fmt(sumBatch.dist, 2)} km<br>
        T: ${fmt(sumBatch.time, 1)} min<br>
        E: <b>${fmt(sumBatch.energy, 0)} kJ</b>
      </div>`;
    }
    if (showSeg) {
      html += `
      <div style="padding:6px; border:1px solid #aa0000; border-radius:4px; background:#fff5f5;">
        <div style="font-weight:bold; color:#aa0000; border-bottom:1px solid #ffcccc; margin-bottom:4px;">â–  ç©ä¸Š (Total)</div>
        D: ${fmt(sumSeg.dist, 2)} km<br>
        T: ${fmt(sumSeg.time, 1)} min<br>
        E: <b>${fmt(sumSeg.energy, 0)} kJ</b>
      </div>`;
    }
    html += '</div>';

    // --- è©³ç´°æ¯”è¼ƒãƒ†ãƒ¼ãƒ–ãƒ« ---
    if (showBatch && showSeg) {
        html += `<table style="width:100%; border-collapse:collapse; font-size:0.85rem; margin-top:8px;">
          <tr style="background:#eee; text-align:center;">
            <th style="border:1px solid #ddd; padding:2px;">åŒºé–“</th>
            <th style="border:1px solid #ddd; padding:2px;">é …ç›®</th>
            <th style="border:1px solid #ddd; padding:2px; color:#0055aa;">ä¸€æ‹¬</th>
            <th style="border:1px solid #ddd; padding:2px; color:#aa0000;">ç©ä¸Š</th>
            <th style="border:1px solid #ddd; padding:2px;">å·®åˆ†</th>
          </tr>`;

        const maxLen = Math.max(batchLegs.length, segLegs.length);
        for(let i=0; i<maxLen; i++){
            const b = batchLegs[i] || {dist:0, time:0, energy:0};
            const s = segLegs[i]   || {dist:0, time:0, energy:0};
            const label = (i===0) ? 'Start' : (i===maxLen-1 ? 'Goal' : `POI ${i}`);
            const nextLabel = (i===maxLen-1) ? '' : (i===maxLen-2 ? 'Goal' : `POI ${i+1}`);
            
            // è·é›¢è¡Œ
            html += `
            <tr>
              <td rowspan="3" style="border:1px solid #ddd; text-align:center; vertical-align:middle; background:#fafafa;">
                <b>Leg ${i+1}</b>
              </td>
              <td style="border:1px solid #ddd; padding:2px;">è·é›¢</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(b.dist,2)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(s.dist,2)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; color:${diffColor(s.dist, b.dist)}">
                ${fmt(s.dist - b.dist, 2)}
              </td>
            </tr>`;
            // æ™‚é–“è¡Œ
            html += `
            <tr>
              <td style="border:1px solid #ddd; padding:2px;">æ™‚é–“</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(b.time,1)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(s.time,1)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; color:${diffColor(s.time, b.time)}">
                ${fmt(s.time - b.time, 1)}
              </td>
            </tr>`;
            // ã‚¨ãƒãƒ«ã‚®ãƒ¼è¡Œ
            html += `
            <tr style="border-bottom:2px solid #ccc;">
              <td style="border:1px solid #ddd; padding:2px;">En(kJ)</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;"><b>${fmt(b.energy,0)}</b></td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;"><b>${fmt(s.energy,0)}</b></td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; font-weight:bold; color:${diffColor(s.energy, b.energy)}">
                ${fmt(s.energy - b.energy, 0)}
              </td>
            </tr>`;
        }
        html += `</table>`;
    }
    
    html += '</div>';
    if (infoBox) infoBox.innerHTML = html;

    // ãƒãƒ¼ã‚«ãƒ¼ãƒ»ã‚ºãƒ¼ãƒ 
    if (typeof setComboMarkers === 'function') setComboMarkers(start, picks, goal);
    if (typeof map !== 'undefined') {
       const allLayers = [];
       if (manualRouteLayerGroup) manualRouteLayerGroup.eachLayer(l => allLayers.push(l));
       if (typeof markerLayer !== 'undefined') markerLayer.eachLayer(l => allLayers.push(l));
       if (allLayers.length > 0) {
         const group = new L.featureGroup(allLayers);
         const b = group.getBounds();
         if (b.isValid()) map.fitBounds(b.pad(0.1));
       }
    }

  } catch (e) {
    console.error(e);
    alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n' + e.message);
    if (infoBox) infoBox.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + e.message;
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.textContent = 'é¸æŠã—ãŸPOIã§æ¯”è¼ƒæç”»';
    }
  }
};

/* =====================================================================
   ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ»çµ±åˆç‰ˆ (7ç¨®ç››ã‚Š)ã€‘
   è©•ä¾¡åŸºæº–ï¼šã™ã¹ã¦ã€Œè·é›¢ã®ã°ã‚‰ã¤ãï¼ˆMSEï¼‰ã€ã§çµ±ä¸€
   
   1. ç·å½“ãŸã‚Š (Ground Truth)
   2. ç´”ç²‹Viterbi (Goalç„¡è¦–, Startè€ƒæ…®)
   3. ç›´ç·šæ¯”è¼ƒ (Zero API)
   4. ç´”ç²‹ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ (Start/Goalè€ƒæ…®, BeamWidth=5)
   5. SGæ’é™¤ãƒ»ç´”ç²‹Viterbi (Start/Goalç„¡è¦–)
   6. ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯ (Start/Goalè€ƒæ…®)
   7. SGæ’é™¤ãƒ»ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯ (æ¢ç´¢æ™‚Startç„¡è¦– â†’ è©•ä¾¡æ™‚Start/Goalè€ƒæ…®)
   ===================================================================== */

/**
 * ã€æ±ç”¨Viterbiã‚½ãƒ«ãƒãƒ¼ã€‘
 * å¯¾ç­–2, 5, 6, 7 ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã“ã‚Œ1ã¤ã§å‡¦ç†ã—ã¾ã™ã€‚
 * * @param options.ignoreStart trueãªã‚‰Startã‚³ã‚¹ãƒˆã‚’0ã«ã™ã‚‹(æ¢ç´¢æ™‚)
 * @param options.ignoreGoalInRank trueãªã‚‰GoalåŒºé–“ã‚’é †ä½æ±ºå®šã«å«ã‚ãªã„(å†è©•ä¾¡æ™‚)
 */
/* ==========================================================
   ã€å®Œå…¨ä¿®æ­£ç‰ˆã€‘æ±ç”¨Viterbiã‚½ãƒ«ãƒãƒ¼ (ã‚³ã‚¹ãƒˆé…åˆ†ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…æ¸ˆã¿)
   ========================================================== */
async function solveViterbiGeneric(start, goal, groups, profile, options = {}) {
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  const ignoreStart = options.ignoreStart === true;
  // ignoreGoalInRank: trueãªã‚‰ã€Œé †ä½ã¯ç¢ºå®šæ¸ˆã¿(æç”»ã®ã¿)ã€ã€falseãªã‚‰ã€Œã“ã‚Œã‹ã‚‰é †ä½æ±ºå®š(å†ãƒ©ãƒ³ã‚¯)ã€
  const ignoreGoalInRank = options.ignoreGoalInRank === true;
  const ignoreGoalEdge = options.ignoreGoalEdge === true;
  const usePathAccumulation = (options.usePathAccumulation === true) && !ignoreStart;
  
  const saveToCache = options.saveToCache === true;
  const tryUseCache = options.tryUseCache === true;

  const apiFunc = calcLegCostWithApi; 
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg; 
  const currentCacheType = ignoreStart ? 'sg_excluded' : 'standard';

  // --- [Phase 1] å€™è£œæ¢ç´¢ (Candidates) ---
  const tStart = performance.now();
  const orsStart = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitStart = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  let candidates = null;
  let cachedBreakdown = null;

  // 1. ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨ãƒã‚§ãƒƒã‚¯
  if (tryUseCache && window.__viterbiIntermediateCache) {
      const c = window.__viterbiIntermediateCache;
      if (c.type === currentCacheType) {
          console.log(`[Viterbi] Using cached candidates (${c.type}).`);
          candidates = c.candidates;
          cachedBreakdown = c.breakdown; 
      }
  }

  // 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒãªã„å ´åˆ: æ¢ç´¢ãƒ«ãƒ¼ãƒ—å®Ÿè¡Œ
  if (!candidates) {
      const mergeStats = (s1, s2) => ({
          dist:   [...(s1?.dist||[]),   ...(s2?.dist||[])],
          time:   [...(s1?.time||[]),   ...(s2?.time||[])],
          energy: [...(s1?.energy||[]), ...(s2?.energy||[])]
      });
      const mergeCoords = (c1, c2) => {
          if (!c1 || !c1.length) return c2 || [];
          if (!c2 || !c2.length) return c1;
          return c1.concat(c2.slice(1));
      };
      const mergeSegments = (seg1, seg2) => [...(seg1||[]), ...(seg2||[])];

      // Step 0
      let currentPaths = new Array(groups[0].length).fill(null);
      for (let i = 0; i < groups[0].length; i++) {
        const firstPoi = groups[0][i];
        let initialCost = 0;
        let accStats={dist:[],time:[],energy:[]}, accCoords=[], accSegments=[];

        if (!ignoreStart) {
          try {
            const leg = await apiFunc(start, firstPoi, profile);
            const diff = leg.distKm - idealDistPerLeg;
            initialCost = diff * diff; 
            if (usePathAccumulation || saveToCache) {
                if(leg.rawStats) accStats = leg.rawStats;
                if(leg.rawFeature) {
                    accCoords = leg.rawFeature.geometry.coordinates;
                    accSegments = leg.rawFeature.properties.segments;
                }
            }
          } catch(e) {}
        }
        currentPaths[i] = {
          picks: [firstPoi],
          currentCost: initialCost,
          lastNode: firstPoi,
          valid: true,
          accStats, accCoords, accSegments
        };
      }

      // Step 1..T-1
      for (let t = 1; t < T; t++) {
        if (options.onProgress) options.onProgress(t, T);
        const nextGroup = groups[t];
        const nextPaths = new Array(nextGroup.length).fill(null);
        for (let j = 0; j < nextGroup.length; j++) {
          const nextPoi = nextGroup[j];
          let bestCost = Infinity, bestPath = null;
          for (let i = 0; i < currentPaths.length; i++) {
            const parent = currentPaths[i];
            if (!parent || !parent.valid) continue;
            try {
              await new Promise(r => setTimeout(r, 20)); 
              const leg = await apiFunc(parent.lastNode, nextPoi, profile);
              const diff = leg.distKm - idealDistPerLeg;
              const newCost = parent.currentCost + (diff * diff);
              if (newCost < bestCost) {
                bestCost = newCost;
                bestPath = {
                  picks: [...parent.picks, nextPoi],
                  currentCost: newCost,
                  lastNode: nextPoi,
                  valid: true,
                };
                if (usePathAccumulation || saveToCache) {
                   bestPath.accStats = mergeStats(parent.accStats, leg.rawStats);
                   bestPath.accCoords = mergeCoords(parent.accCoords, leg.rawFeature?.geometry?.coordinates);
                   bestPath.accSegments = mergeSegments(parent.accSegments, leg.rawFeature?.properties?.segments);
                }
              }
            } catch (e) {}
          }
          nextPaths[j] = bestPath;
        }
        currentPaths = nextPaths;
      }
      candidates = currentPaths.filter(p => p && p.valid);
  }

  // --- Phase 1 çµ‚äº†æ™‚ç‚¹ã®è¨ˆæ¸¬ ---
  const tPhase1End = performance.now();
  const orsPhase1End = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitPhase1End = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ç”¨ãƒ‡ãƒ¼ã‚¿ (Phase 1 ã®ã‚³ã‚¹ãƒˆã®ã¿)
  // ã‚‚ã—ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨ä¸­ãªã‚‰ã€ä¿å­˜ã•ã‚Œã¦ã„ãŸã‚³ã‚¹ãƒˆã‚’ãã®ã¾ã¾ä½¿ã†
  let phase1Breakdown = cachedBreakdown; 
  if (!phase1Breakdown) {
      phase1Breakdown = {
          ors: orsPhase1End - orsStart,
          wait: waitPhase1End - waitStart,
          time: tPhase1End - tStart
      };
  }

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
  if (saveToCache && candidates) {
      window.__viterbiIntermediateCache = {
          type: currentCacheType,
          candidates: candidates,
          breakdown: phase1Breakdown // Phase 1ã‚³ã‚¹ãƒˆã‚’ä¿å­˜
      };
      console.log(`[Viterbi] Candidates & breakdown cached (${currentCacheType}).`);
  }


  // --- [Phase 2] ä»•ä¸Šã’ (Finalize / Rerank / Draw) ---
  const finalResults = [];
  
  // Phase 2 é–‹å§‹
  const tPhase2Start = performance.now();
  const orsPhase2Start = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitPhase2Start = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  if (usePathAccumulation && candidates.length > 0) {
    // A. ãƒ‘ã‚¹ç´¯ç©ãƒ¢ãƒ¼ãƒ‰ (é€šå¸¸ã€é †ä½æ±ºå®šã«é–¢ã‚ã‚‹ã®ã§Decisionã«å«ã‚€)
    for (const cand of candidates) {
        try { 
          const leg = await apiFunc(cand.lastNode, goal, profile);
          
          const mergeStats = (s1, s2) => ({
             dist:   [...(s1?.dist||[]),   ...(s2?.dist||[])],
             time:   [...(s1?.time||[]),   ...(s2?.time||[])],
             energy: [...(s1?.energy||[]), ...(s2?.energy||[])]
          });
          const baseStats = cand.accStats || {dist:[],time:[],energy:[]};
          const baseCoords = cand.accCoords || [];
          const baseSegs = cand.accSegments || [];
          const finalStats = mergeStats(baseStats, leg.rawStats);
          const finalCoords = (baseCoords.length) ? baseCoords.concat((leg.rawFeature?.geometry?.coordinates||[]).slice(1)) : leg.rawFeature?.geometry?.coordinates;
          const finalSegments = [...baseSegs, ...(leg.rawFeature?.properties?.segments||[])];
          let sumSq=0, count=0;
          finalSegments.forEach(seg => {
             const d=(Number(seg.distance)||0)/1000;
             sumSq += Math.pow(d - idealDistPerLeg, 2);
             count++;
          });
          const totalMse = (count>0) ? sumSq/count : Infinity;
          const constructedFeature = {
              type: "Feature", properties: { summary: { distance: finalSegments.reduce((s,x)=>s+(x.distance||0),0), duration: finalSegments.reduce((s,x)=>s+(x.duration||0),0) }, segments: finalSegments },
              geometry: { type: "LineString", coordinates: finalCoords }
          };
          finalResults.push({
             rank: 0, score: totalMse, displayScore: totalMse,
             poi_names: cand.picks.map(p => p.name).join(' -> '),
             poi_latlngs: cand.picks.map(p => `${p.lat},${p.lon}`).join(' | '),
             sigmaEnergy: stdDev(finalStats.energy), dist: finalStats.dist, stats: finalStats,
             picks: cand.picks, feature: constructedFeature 
          });
        } catch(e) { console.error(e); }
    }
  } 
  else if (candidates.length > 0) {
     // B. å¾“æ¥ãƒ¢ãƒ¼ãƒ‰ (å†ãƒ©ãƒ³ã‚¯ or SGæ’é™¤)
     if (!ignoreGoalEdge) {
         for (const cand of candidates) {
             try { await apiFunc(cand.lastNode, goal, profile); } catch(e) {}
         }
     }
     const ranked = await finalizeAndRank(start, goal, candidates, idealDistPerLeg, profile, { 
        includeGoalScore: !ignoreGoalInRank,
        useAccumulatedCost: ignoreGoalInRank,
        onlyInternal: ignoreGoalInRank 
     });
     ranked.forEach(r => finalResults.push(r));
  }

  finalResults.sort((a, b) => (a.score ?? 1e9) - (b.score ?? 1e9));
  finalResults.forEach((r, idx) => r.rank = idx + 1);

  // --- æœ€çµ‚è¨ˆæ¸¬ & ã‚³ã‚¹ãƒˆæŒ¯ã‚Šåˆ†ã‘ ---
  const tEnd = performance.now();
  const orsEnd = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitEnd = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  // Phase 2 å˜ä½“ã®ã‚³ã‚¹ãƒˆ
  const p2Ors  = orsEnd - orsPhase2Start;
  const p2Wait = waitEnd - waitPhase2Start;
  const p2Time = tEnd - tPhase2Start;

  // â˜…æŒ¯ã‚Šåˆ†ã‘ãƒ­ã‚¸ãƒƒã‚¯ã®æ ¸å¿ƒ
  // Algo 6 (SGæ’é™¤) -> ignoreGoalInRank=true -> Phase 2ã¯ã€Œé †ä½ã«å½±éŸ¿ã—ãªã„æç”»ã€ -> Draw
  // Algo 7 (å†ãƒ©ãƒ³ã‚¯) -> ignoreGoalInRank=false -> Phase 2ã¯ã€ŒçœŸã®ã‚¹ã‚³ã‚¢è¨ˆç®—ã€ -> Search
  
  let finalSearchOrs, finalSearchWait, finalSearchTime;
  let finalDrawOrs, finalDrawWait, finalDrawTime;

  if (ignoreGoalInRank === true) {
      // 6. SGæ’é™¤: Phase 1ã ã‘ãŒæ¢ç´¢ã€Phase 2ã¯æç”»
      finalSearchOrs  = phase1Breakdown.ors;
      finalSearchWait = phase1Breakdown.wait;
      finalSearchTime = phase1Breakdown.time;
      
      finalDrawOrs  = p2Ors;
      finalDrawWait = p2Wait;
      finalDrawTime = p2Time;
  } else {
      // 7. å†ãƒ©ãƒ³ã‚¯ (ä»–): Phase 1ã‚‚Phase 2ã‚‚ã€Œæ±ºå®šã€ã«å¿…è¦ãªã‚³ã‚¹ãƒˆ
      finalSearchOrs  = phase1Breakdown.ors + p2Ors;
      finalSearchWait = phase1Breakdown.wait + p2Wait;
      finalSearchTime = phase1Breakdown.time + p2Time;
      
      finalDrawOrs  = 0;
      finalDrawWait = 0;
      finalDrawTime = 0;
  }

  // æˆ»ã‚Šå€¤ã«å†…è¨³ã‚’æ·»ä»˜
  finalResults._breakdown = {
      searchOrs:  finalSearchOrs,
      searchWait: finalSearchWait,
      searchTime: finalSearchTime,
      
      drawOrs:  finalDrawOrs,
      drawWait: finalDrawWait,
      drawTime: finalDrawTime,

      isCached: !!cachedBreakdown
  };

  return finalResults;
}

/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ç·å½“ãŸã‚Š (ãƒ‡ãƒ¼ã‚¿å½¢å¼ãƒã‚°ä¿®æ­£æ¸ˆã¿)
   ========================================================== */
async function solveMatrixBruteforce(start, goal, restGroups, profile, onProgress) {
    const T = Array.isArray(restGroups) ? restGroups.length : 0;
    if (!T) return [];

    // --- [Phase 1] å…¨ã‚¨ãƒƒã‚¸ã®APIè¨ˆç®— (Pre-calculation) ---
    // â˜…ä¿®æ­£: restGroups ãŒ [[poi...], [poi...]] (é…åˆ—ã®é…åˆ—) ã§æ¥ã¦ã‚‚
    //         [{pois:[...]}] (ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—) ã§æ¥ã¦ã‚‚å¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ä¿®æ­£
    const layers = [
        [start],
        ...restGroups.map(g => {
            if (Array.isArray(g)) return g;            // é…åˆ—ãªã‚‰ãã®ã¾ã¾ä½¿ã†
            if (g && Array.isArray(g.pois)) return g.pois; // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã‚‰ .pois ã‚’ä½¿ã†
            return [];
        }),
        [goal]
    ];

    // ã‚¨ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨
    const edgeMatrix = []; 
    
    // é€²æ—è¨ˆç®—ç”¨
    let totalEdges = 0;
    for(let i=0; i<layers.length-1; i++) {
        const len = layers[i].length * layers[i+1].length;
        totalEdges += len;
        // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: å„å±¤ã®ã¤ãªãŒã‚Šæ•°ã‚’ç¢ºèª
        // console.log(`Layer ${i}->${i+1}: ${layers[i].length} x ${layers[i+1].length} = ${len} edges`);
    }

    // â˜…ã‚‚ã—ã“ã“ã§ totalEdges ãŒ 0 ãªã‚‰ã€ãƒ‡ãƒ¼ã‚¿é€£æºãŒã†ã¾ãã„ã£ã¦ã„ãªã„
    if (totalEdges === 0) {
        console.warn("[MatrixBF] Edge count is 0. Check layers:", layers);
        return []; // æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
    }

    let computedEdges = 0;
    const apiFunc = calcLegCostWithApi;

    for (let i = 0; i < layers.length - 1; i++) {
        edgeMatrix[i] = [];
        const froms = layers[i];
        const tos   = layers[i+1];

        for (let f = 0; f < froms.length; f++) {
            edgeMatrix[i][f] = [];
            for (let t = 0; t < tos.length; t++) {
                if (onProgress) onProgress(computedEdges, totalEdges);
                
                try {
                    await new Promise(r => setTimeout(r, 20)); 
                    const leg = await apiFunc(froms[f], tos[t], profile);
                    
                    edgeMatrix[i][f][t] = {
                        dist: leg.distKm,
                        time: leg.timeMin,
                        energy: leg.energyKj,
                        valid: true
                    };
                } catch (e) {
                    edgeMatrix[i][f][t] = { valid: false };
                }
                computedEdges++;
            }
        }
    }

    // --- [Phase 2] è¨˜éŒ²ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ãŸç·å½“ãŸã‚Š (In-Memory) ---
    const results = [];
    
    function traverse(layerIdx, currentIndices, currentPicks, accStats) {
        if (layerIdx === layers.length - 1) {
            const dists = accStats.dist;
            const n = dists.length;
            if (n === 0) return;

            // å‹•çš„ç†æƒ³è·é›¢ (ã“ã®ãƒ«ãƒ¼ãƒˆã®å¹³å‡)
            const totalDist = dists.reduce((a,b)=>a+b, 0);
            const idealDist = totalDist / n;

            // åˆ†æ•£(MSE)è¨ˆç®—
            let sumSq = 0;
            dists.forEach(d => {
                const diff = d - idealDist;
                sumSq += diff * diff;
            });
            const score = sumSq / n;

            results.push({
                score: score,
                rawScore: score,
                picks: currentPicks.slice(),
                stats: {
                    dist: dists.slice(),
                    time: accStats.time.slice(),
                    energy: accStats.energy.slice()
                },
                feature: null 
            });
            return;
        }

        const currentIdx = currentIndices[currentIndices.length - 1];
        const nextLayerIdx = layerIdx + 1;
        const nextCandidates = layers[nextLayerIdx];

        for (let nextIdx = 0; nextIdx < nextCandidates.length; nextIdx++) {
            const edge = edgeMatrix[layerIdx][currentIdx][nextIdx];
            
            if (edge && edge.valid) {
                const nextStats = {
                    dist: [...accStats.dist, edge.dist],
                    time: [...accStats.time, edge.time],
                    energy: [...accStats.energy, edge.energy]
                };

                const nextPicks = [...currentPicks];
                // ä¸­é–“åœ°ç‚¹ã®ã¿ picks ã«è¿½åŠ  (Start/Goalã¯é™¤å¤–)
                if (nextLayerIdx > 0 && nextLayerIdx < layers.length - 1) {
                    nextPicks.push(nextCandidates[nextIdx]);
                }

                traverse(
                    nextLayerIdx, 
                    [...currentIndices, nextIdx], 
                    nextPicks, 
                    nextStats
                );
            }
        }
    }

    traverse(0, [0], [], { dist:[], time:[], energy:[] });

    results.sort((a, b) => a.score - b.score);
    results.forEach((r, i) => r.rank = i + 1);

    results._breakdown = {
        searchOrs: computedEdges,
        searchWait: 0,
        searchTime: 0,
        drawOrs: 0, drawWait: 0, drawTime: 0,
        isCached: false
    };

    return results;
}
/**
 * ã€ç´”ç²‹ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ (Beam Search)ã€‘
 * å¯¾ç­–4ï¼ˆå¯¾ç­–Gï¼‰ç›¸å½“ã€‚Start/Goalè€ƒæ…®ã€Beamå¹…æŒ‡å®šå¯ã€‚
 */
// /* ==========================================================
//    ã€ä¿®æ­£ç‰ˆã€‘ç´”ç²‹ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ (é€²æ—è¡¨ç¤ºå¯¾å¿œ)
//    ========================================================== */
// async function solveBeamSearch(start, goal, groups, profile, options = {}) {
//   const T = Array.isArray(groups) ? groups.length : 0;
//   if (!T) return [];

//   const BEAM_WIDTH = options.beamWidth || 5;
//   const ideals = getIdealPerLegs();
//   const idealDistPerLeg = ideals.idealDistPerLeg; 
//   const apiFunc = calcLegCostWithApi; 

//   // Step 0
//   let currentPaths = [];
//   for (let i = 0; i < groups[0].length; i++) {
//     const firstPoi = groups[0][i];
//     try {
//       const leg = await apiFunc(start, firstPoi, profile);
//       const diff = leg.distKm - idealDistPerLeg;
//       currentPaths.push({
//         picks: [firstPoi],
//         currentCost: diff * diff,
//         lastNode: firstPoi,
//         valid: true
//       });
//     } catch(e) {}
//   }
//   currentPaths.sort((a, b) => a.currentCost - b.currentCost);
//   currentPaths = currentPaths.slice(0, BEAM_WIDTH);

//   // Step 1..T-1
//   for (let t = 1; t < T; t++) {
//     // â˜…é€²æ—å ±å‘Š
//     if (options.onProgress) options.onProgress(t, T);

//     const nextGroup = groups[t];
//     let allCandidates = [];

//     for (let i = 0; i < currentPaths.length; i++) {
//       const parent = currentPaths[i];
//       for (let j = 0; j < nextGroup.length; j++) {
//         const nextPoi = nextGroup[j];
//         try {
//           await new Promise(r => setTimeout(r, 20));
//           const leg = await apiFunc(parent.lastNode, nextPoi, profile);
//           const diff = leg.distKm - idealDistPerLeg;
//           const newCost = parent.currentCost + (diff * diff);

//           allCandidates.push({
//             picks: [...parent.picks, nextPoi],
//             currentCost: newCost,
//             lastNode: nextPoi,
//             valid: true
//           });
//         } catch (e) {}
//       }
//     }
//     allCandidates.sort((a, b) => a.currentCost - b.currentCost);
//     currentPaths = allCandidates.slice(0, BEAM_WIDTH);
//   }

//   for (const cand of currentPaths) {
//       try { await apiFunc(cand.lastNode, goal, profile); } catch(e) {}
//   }

//   return finalizeAndRank(start, goal, currentPaths, idealDistPerLeg, profile, { 
//     includeGoalScore: true,
//     useAccumulatedCost: false
//   });
// }
/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘ç´”ç²‹ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ (è¨ˆæ¸¬å†…è¨³å¯¾å¿œç‰ˆ)
   ========================================================== */
async function solveBeamSearch(start, goal, groups, profile, options = {}) {
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  const BEAM_WIDTH = options.beamWidth || 5;
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg; 
  const apiFunc = calcLegCostWithApi; 

  const tStart = performance.now();
  const orsStart = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitStart = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  // Step 0
  let currentPaths = [];
  for (let i = 0; i < groups[0].length; i++) {
    const firstPoi = groups[0][i];
    try {
      const leg = await apiFunc(start, firstPoi, profile);
      const diff = leg.distKm - idealDistPerLeg;
      currentPaths.push({
        picks: [firstPoi], currentCost: diff * diff, lastNode: firstPoi, valid: true
      });
    } catch(e) {}
  }
  currentPaths.sort((a, b) => a.currentCost - b.currentCost);
  currentPaths = currentPaths.slice(0, BEAM_WIDTH);

  // Step 1..T-1
  for (let t = 1; t < T; t++) {
    if (options.onProgress) options.onProgress(t, T);
    const nextGroup = groups[t];
    let allCandidates = [];

    for (let i = 0; i < currentPaths.length; i++) {
      const parent = currentPaths[i];
      for (let j = 0; j < nextGroup.length; j++) {
        const nextPoi = nextGroup[j];
        try {
          await new Promise(r => setTimeout(r, 20));
          const leg = await apiFunc(parent.lastNode, nextPoi, profile);
          const diff = leg.distKm - idealDistPerLeg;
          const newCost = parent.currentCost + (diff * diff);
          allCandidates.push({
            picks: [...parent.picks, nextPoi], currentCost: newCost, lastNode: nextPoi, valid: true
          });
        } catch (e) {}
      }
    }
    allCandidates.sort((a, b) => a.currentCost - b.currentCost);
    currentPaths = allCandidates.slice(0, BEAM_WIDTH);
  }

  // --- æ¢ç´¢çµ‚äº† ---
  const tSearchEnd = performance.now();
  const orsSearchEnd = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitSearchEnd = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  // æç”»ãƒ•ã‚§ãƒ¼ã‚º
  for (const cand of currentPaths) {
      try { await apiFunc(cand.lastNode, goal, profile); } catch(e) {}
  }

  const results = await finalizeAndRank(start, goal, currentPaths, idealDistPerLeg, profile, { 
    includeGoalScore: true, useAccumulatedCost: false
  });

  // --- å…¨ä½“çµ‚äº† ---
  const tEnd = performance.now();
  const orsEnd = (typeof API_USED !== 'undefined') ? API_USED.orsTotal : 0;
  const waitEnd = (typeof API_USED !== 'undefined') ? API_USED.waitTotal : 0;

  results._breakdown = {
      searchOrs:  orsSearchEnd - orsStart,
      searchWait: waitSearchEnd - waitStart,
      searchTime: tSearchEnd - tStart,
      
      drawOrs:  orsEnd - orsSearchEnd,
      drawWait: waitEnd - waitSearchEnd,
      drawTime: tEnd - tSearchEnd,
      
      isCached: false
  };

  return results;
}
/**
 * ã€å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼: ãƒªãƒ©ãƒ³ã‚¯å‡¦ç†ã€‘
 * å€™è£œãƒ«ãƒ¼ãƒˆã«å¯¾ã—ã¦æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ã—ã€é †ä½ä»˜ã‘ã—ã¦è¿”ã—ã¾ã™ã€‚
 * * @param options.includeGoalScore trueãªã‚‰ã€Œå…¨åŒºé–“(Startï½Goal)ã€ã®MSEã‚’å†è¨ˆç®—ã—ã¦é †ä½ã«ã™ã‚‹
 * @param options.useAccumulatedCost trueãªã‚‰ã€Œæ¢ç´¢ä¸­ã®ç´¯ç©ã‚³ã‚¹ãƒˆã€ã‚’ãã®ã¾ã¾é †ä½ã«ä½¿ã†
 */
/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘finalizeAndRank (POIã®ã¿ãƒ«ãƒ¼ãƒˆå¯¾å¿œ)
   ========================================================== */
async function finalizeAndRank(start, goal, candidates, idealDist, profile, options = {}) {
  const includeGoalScore = options.includeGoalScore !== false;
  const useAccumulatedCost = options.useAccumulatedCost === true;
  // â˜…è¿½åŠ : POIé–“ã®ã¿ã®ãƒ«ãƒ¼ãƒˆã‚’å¼•ããƒ•ãƒ©ã‚°
  const onlyInternal = options.onlyInternal === true;

  const finalResults = [];

  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    
    // â˜…ãƒ«ãƒ¼ãƒˆæ§‹æˆç‚¹ã®ä½œæˆ
    let waypoints;
    if (onlyInternal) {
        // Start/Goalã‚’é™¤å¤–ã—ã€POIã®ã¿ã‚’ã¤ãªã
        waypoints = candidate.picks.filter(Boolean).map(p => ({
            lat: p.lat, lon: p.lon, name: p.name || 'POI'
        }));
        // POIãŒ2ã¤æœªæº€ã ã¨ãƒ«ãƒ¼ãƒˆãŒå¼•ã‘ãªã„ã®ã§ã€ã‚¬ãƒ¼ãƒ‰ï¼ˆStart/Goalã‚’å…¥ã‚Œã‚‹ã‹ã€ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹ï¼‰
        if (waypoints.length < 2) {
            // ä»•æ–¹ãªã„ã®ã§Start/Goalã‚’å…¥ã‚Œã‚‹ï¼ˆã¾ãŸã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
            waypoints = [start, ...candidate.picks, goal];
        }
    } else {
        // é€šå¸¸ï¼ˆStart -> POIs -> Goalï¼‰
        waypoints = [start, ...candidate.picks, goal];
    }

    try {
      await new Promise(r => setTimeout(r, 100)); 
      
      const out = await routeLegStatsForWaypoints(waypoints, profile);
      
      // MSEè¨ˆç®—
      // onlyInternalã®å ´åˆã€idealDistï¼ˆå…¨ä½“å¹³å‡ï¼‰ã¨æ¯”ã¹ã‚‹ã®ã¯ãƒ•ã‚§ã‚¢ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ãŒã€
      // ã€Œå…¨ä½“ã®ãƒªã‚ºãƒ ã€ã‚’ç¶­æŒã§ãã¦ã„ã‚‹ã‹è¦‹ã‚‹æŒ‡æ¨™ã¨ã—ã¦ãã®ã¾ã¾ä½¿ã†ã€‚
      const totalMse = calcDistMseFromFeature(out.feature, idealDist);

      let rankingScore;
      if (useAccumulatedCost) {
        rankingScore = candidate.currentCost;
      } else {
        rankingScore = totalMse;
      }

      finalResults.push({
        rank: 0,
        score: rankingScore, 
        displayScore: totalMse,
        poi_names: candidate.picks.map(p => p.name).join(' -> '),
        poi_latlngs: candidate.picks.map(p => `${p.lat},${p.lon}`).join(' | '),
        sigmaEnergy: stdDev(out.stats.energy),
        dist: out.stats.dist,
        picks: candidate.picks,
        stats: out.stats,
        feature: out.feature 
      });
    } catch (e) {
      console.warn("Ranking failed", e);
    }
  }

  finalResults.sort((a, b) => (a.score ?? 1e9) - (b.score ?? 1e9));
  finalResults.forEach((r, idx) => r.rank = idx + 1);
  
  return finalResults;
}

/* =====================================================================
   ã€æ•´ç†ç‰ˆã€‘ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ»çµ±åˆãƒ­ã‚¸ãƒƒã‚¯
   UI/æ©Ÿèƒ½ã¯ãã®ã¾ã¾ã«ã€å…±é€šå‡¦ç†ã‚’ã¾ã¨ã‚ã¦è¨˜è¿°é‡ã‚’å‰Šæ¸›
   ===================================================================== */

/* ===== ã€ä¿®æ­£ç‰ˆã€‘ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®šç¾© (6,7ç•ªã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»çœç•¥è¨­å®šã‚’è¿½åŠ ) ===== */
const ALGO_CONFIG = [
  // 1. ç·å½“ãŸã‚Š
  { id: 'dbg_bf', label: '1. ç·å½“ãŸã‚Š', func: runBruteforceOnce },

  // 2. ç´”ç²‹Viterbi (é«˜é€Ÿ) -> ä¿å­˜
  { id: 'dbg_vit_pure', label: '2. ç´”ç²‹Viterbi (é«˜é€Ÿ)', 
    func: (s,g,gr,p, cb) => solveViterbiGeneric(s,g,gr,p, { 
        usePathAccumulation: true, 
        saveToCache: true,      // ä¿å­˜
        onProgress: cb 
    }) 
  },

  // 3. ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯ -> åˆ©ç”¨
  { id: 'dbg_vit_pure_rerank', label: '3. ç´”ç²‹Viterbi + å†ãƒ©ãƒ³ã‚¯', 
    func: (s,g,gr,p, cb) => solveViterbiGeneric(s,g,gr,p, { 
        usePathAccumulation: false, 
        tryUseCache: true,      // åˆ©ç”¨
        onProgress: cb 
    }) 
  },

  // 4. ç›´ç·š
  { id: 'dbg_linear', label: '4. ç›´ç·šæ¯”è¼ƒ', type: 'linear' }, 

  // 5. ãƒ“ãƒ¼ãƒ 
  { id: 'dbg_beam', label: '5. ç´”ç²‹ãƒ“ãƒ¼ãƒ ', 
    func: (s,g,gr,p, cb) => solveBeamSearch(s,g,gr,p, { beamWidth:5, onProgress: cb }) },

  // 6. SGæ’é™¤Vit -> â˜…ä¿å­˜ & Goalè¨ˆç®—ã‚¹ã‚­ãƒƒãƒ—
  { id: 'dbg_vit_sg_excl', label: '6. SGæ’é™¤ãƒ»ç´”ç²‹Viterbi', 
    func: (s,g,gr,p, cb) => solveViterbiGeneric(s,g,gr,p, { 
        ignoreStart:true, 
        ignoreGoalInRank:true, 
        ignoreGoalEdge: true,   // â˜…APIç¯€ç´„ï¼šGoalåŒºé–“ã‚’è¨ˆç®—ã—ãªã„
        saveToCache: true,      // â˜…ä¿å­˜
        onProgress: cb 
    }) 
  },

  // 7. SGæ’é™¤+å†ãƒ©ãƒ³ã‚¯ -> â˜…åˆ©ç”¨ & å†è©•ä¾¡
  { id: 'dbg_vit_sg_excl_rerank', label: '7. SGæ’é™¤+å†ãƒ©ãƒ³ã‚¯', 
    func: (s,g,gr,p, cb) => solveViterbiGeneric(s,g,gr,p, { 
        ignoreStart:true, 
        ignoreGoalEdge: true,   // â˜…ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¡ä»¶ä¸€è‡´ã®ãŸã‚å¿…è¦
        tryUseCache: true,      // â˜…åˆ©ç”¨
        onProgress: cb 
    }) 
  },
{ 
    id: 'dbg_matrix_bf', 
    label: '8. ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ç·å½“ãŸã‚Š (æ¨å¥¨)', 
    func: (s,g,gr,p, cb) => solveMatrixBruteforce(s,g,gr,p, cb)
  },
];
  
function isAlgoEnabled(id){
  const el = document.getElementById(id);
  return !!(el && el.checked);
}
/* ======================================================
   ã€å®Œå…¨ä¿®æ­£ç‰ˆã€‘ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•° (è©³ç´°å†…è¨³è¡¨ç¤ºå¯¾å¿œ)
   ====================================================== */
async function runAlgoCompareDebug(){
  const panel = $('algoComparePanel');
  panel.textContent = '';
  window.__algoCompareRows = [];
  window.__viterbiIntermediateCache = null;

  const tTotalStart = performance.now();

  if (!routeData?.fastest) return panel.textContent = 'ãƒ«ãƒ¼ãƒˆãƒ»POIã‚’å…ˆã«æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚';
  if (!restGroups?.length) return panel.textContent = 'ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';

  ensureProjections(); 
  const start = pts.find(p => p.type === 'start') || pts[0];
  const goal  = pts.find(p => p.type === 'goal')  || pts[pts.length - 1];
  const profile = 'cycling-road';
  const cap = Math.max(1, Number($('poiLimit')?.value) || 5);
  const targetGroups = makeCandGroupsFromRestGroups(restGroups, cap);
  let bfRankMap = null; 

  panel.textContent += '====== ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒ (è©³ç´°å†…è¨³ç‰ˆ) ======\n\n';

  for (const cfg of ALGO_CONFIG) {
    if (!isAlgoEnabled(cfg.id)) continue;
    panel.textContent += `${cfg.label}...`; 
    
    const onProgress = (cur, total) => {
        if (total) panel.textContent += `..${cur}/${total}`; else panel.textContent += '.';
    };
    await new Promise(r => setTimeout(r, (cfg.id==='dbg_linear' ? 100 : 2000)));

    try {
      let list = [];
      if (cfg.type === 'linear') {
        const linGroups = topPoisPerTriggerForLinear(5);
        list = buildLinearAlgoRows(start, goal, linGroups);
        // ç›´ç·šã¯APIã‚’ä½¿ã‚ãªã„ã®ã§ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿
        list._breakdown = { searchOrs:0, drawOrs:0, searchTime:0, drawTime:0, searchWait:0, drawWait:0 };
      } else {
        list = await cfg.func(start, goal, targetGroups, profile, onProgress);
      }

      // ãƒ©ãƒ³ã‚¯ä»˜ä¸
      if (cfg.id === 'dbg_bf') {
        bfRankMap = buildBfRankMap(list);
        attachBfRank(list, bfRankMap);
        list.sort((a, b) => (a.bfRank || 999) - (b.bfRank || 999));
      } else {
        attachBfRank(list, bfRankMap);
      }

      // --- å†…è¨³è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ ---
      const bd = list._breakdown || { searchOrs:0, drawOrs:0, searchTime:0, drawTime:0, searchWait:0, drawWait:0 };
      
      // åˆè¨ˆå€¤
      const totalOrs  = bd.searchOrs + bd.drawOrs;
      const totalWait = bd.searchWait + bd.drawWait;
      const totalTime = bd.searchTime + bd.drawTime; // çµŒéæ™‚é–“ã®åˆè¨ˆ
      const activeTime = Math.max(0, totalTime - totalWait); // å®Ÿå‡¦ç†æ™‚é–“

      // ç§’å¤‰æ›
      const sTotal  = (totalTime / 1000).toFixed(1);
      const sActive = (activeTime / 1000).toFixed(1);
      const sWait   = (totalWait / 1000).toFixed(1);

      let logStr = `\n  API: ${totalOrs} (æ¢${bd.searchOrs}+æ${bd.drawOrs})`;
      logStr    += ` | Time: ${sTotal}s (å‡¦ç†${sActive}+å¾…${sWait})`;

      if (bd.isCached) {
          logStr += ` [Cacheåˆ©ç”¨]`;
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨æ™‚ã¯ã€ä»Šå›ã®å®Ÿæ¸¬æ™‚é–“(=æç”»æ™‚é–“)ã‚‚ä½µè¨˜ã™ã‚‹ã¨è¦ªåˆ‡
          const realSec = (bd.drawTime / 1000).toFixed(1);
          logStr += ` (ä»Šå›å®Ÿæ¸¬: ${realSec}s)`;
      }

      panel.textContent += logStr + '\n';

      // CSVå‡ºåŠ›ç”¨ (åˆè¨ˆå€¤ã§å‡ºåŠ›)
      pushAlgoResultsForCsv(cfg.id, cfg.label, list, totalTime, totalOrs, 0);

      if (list.length) {
        showAlgoListInPanel(panel, list.slice(0, 5), cfg.id);
      } else {
        panel.textContent += '(å€™è£œãªã—)\n';
      }

    } catch (e) {
      console.error(e);
      panel.textContent += `\n[ã‚¨ãƒ©ãƒ¼] ${e.message}\n`;
    }
  }

  const totalSec = (performance.now() - tTotalStart) / 1000;
  panel.textContent += `\n====== å®Œäº† (Total: ${totalSec.toFixed(2)}s) ======\n`;
}
  
/* ==========================================================
   ã€å¤‰æ›´ç‰ˆã€‘ã‚³ã‚¹ãƒˆè¨ˆç®— (ãã®ãƒ«ãƒ¼ãƒˆã®å®Ÿæ¸¬ç·è·é›¢ã‚’åŸºæº–ã«ã™ã‚‹)
   ========================================================== */
function calcDistMseFromFeature(feature, _unusedFixedIdeal) {
  const segments = feature?.properties?.segments || [];
  
  if (!segments || segments.length === 0) {
    return Infinity;
  }

  // 1. ã“ã®ãƒ«ãƒ¼ãƒˆè‡ªä½“ã®ç·è·é›¢ã‚’è¨ˆç®—
  let totalKm = 0;
  segments.forEach(seg => {
    totalKm += (Number(seg.distance) || 0) / 1000;
  });

  // 2. ã“ã®ãƒ«ãƒ¼ãƒˆã«ãŠã‘ã‚‹ã€Œç†æƒ³ã®åŒºé–“è·é›¢ã€ã‚’å‹•çš„ã«ç®—å‡º
  //    (ç·è·é›¢ Ã· åŒºé–“æ•°)
  const dynamicIdealDist = totalKm / segments.length;

  // 3. MSEè¨ˆç®— (å„åŒºé–“ã¨ã€å‹•çš„ç†æƒ³è·é›¢ã¨ã®å·®)
  let sumSq = 0;
  segments.forEach(seg => {
    const dKm = (Number(seg.distance) || 0) / 1000;
    const diff = dKm - dynamicIdealDist;
    sumSq += diff * diff;
  });

  return sumSq / segments.length;
}

/* ==========================================================
   ã€ä¿®æ­£çµ±åˆç‰ˆã€‘ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›ãƒ»ãƒ­ã‚°è¨˜éŒ²é–¢æ•°ã‚»ãƒƒãƒˆ
   â€»Excelã«ã€Œå‡¦ç†æ™‚é–“/APIå›æ•°ã€ã€Edgeã«ã€ŒPOI IDã€ã‚’è¿½åŠ 
   ========================================================== */

// 1. POI IDå–å¾—ãƒ˜ãƒ«ãƒ‘ãƒ¼ (é‡è¤‡å®šç¾©ãªã—)
function getPoiId(p) {
  if (!p) return 'null';
  // ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«
  if (p.type === 'start') return 'START';
  if (p.type === 'goal')  return 'GOAL';
  // å†…éƒ¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ã‚‹å ´åˆ (ä¾‹: T0_3)
  // â€» 0 ã‚‚ã‚ã‚Šå¾—ã‚‹ã®ã§ undefined ãƒã‚§ãƒƒã‚¯ãŒå¿…è¦
  if (p._triggerId !== undefined && p._poiIdInTrigger !== undefined) {
    return `T${p._triggerId}_${p._poiIdInTrigger}`;
  }
  // ãªã‘ã‚Œã°åº§æ¨™ã‚’IDä»£ã‚ã‚Šã«ã™ã‚‹
  const lat = (p.lat ?? p.latitude ?? 0);
  const lon = (p.lon ?? p.lng ?? 0);
  return `${Number(lat).toFixed(5)},${Number(lon).toFixed(5)}`;
}

// 2. ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒç”¨: CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ç†æƒ³è·é›¢åˆ—ã‚’è¿½åŠ )
function downloadAlgoCompareCsv(){
  const rows = window.__algoCompareRows || [];
  if (!rows.length){
    alert('å…ˆã«ã€Œã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }

  const header = [
    'algo',
    'label',
    'rank',
    'bf_rank',
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'time_ms',
    'ors_calls',
    'overpass_calls',
    'ideal_dist_km',  // â˜…è¿½åŠ 
    'poi_names',
    'poi_ids',
    'poi_latlngs'
  ];

  const bodyRows = rows.map(r => [
    r.algo ?? '',
    `"${csvEscape(r.label ?? '')}"`,
    r.rank ?? '',
    r.bfRank ?? '',
    r.score ?? '',
    r.rawScore ?? '',
    r.sigmaDist ?? '',
    r.sigmaTime ?? '',
    r.sigmaEnergy ?? '',
    r.timeMs ?? '',
    r.orsCalls ?? '',
    r.overpassCalls ?? '',
    formatNum(r.idealDistKm, 3), // â˜…è¿½åŠ 
    `"${csvEscape(r.poiNames ?? '')}"`,
    `"${csvEscape(r.poiIds ?? '')}"`,
    `"${csvEscape(r.poiLatLngs ?? '')}"`
  ]);

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'algo_compare_debug.csv');
}
// 4. Edge(Viterbi)ç”¨: APIå‘¼ã³å‡ºã—ï¼†IDãƒ­ã‚°è¨˜éŒ²
/* ==========================================================
   ã€ä¿®æ­£ç‰ˆã€‘APIå‘¼ã³å‡ºã—ï¼†ãƒ­ã‚°è¨˜éŒ² (ãƒ‘ã‚¹ç´¯ç©ç”¨ãƒ‡ãƒ¼ã‚¿è¿”å´å¯¾å¿œ)
   ========================================================== */
async function calcLegCostWithApi(from, to, profile){
  if (!from || !to) throw new Error('calcLegCostWithApi: from/to ãŒä¸æ­£ã§ã™');

  const t0 = performance.now();

  const fromLat = from.lat ?? from.latitude ?? from.y;
  const fromLon = from.lon ?? from.lng ?? from.longitude ?? from.x;
  const toLat   = to.lat   ?? to.latitude   ?? to.y;
  const toLon   = to.lon   ?? to.lng ?? to.longitude   ?? to.x;

  const fromId   = getPoiId(from);
  const toId     = getPoiId(to);
  const fromName = from.name || from.label || `(${fromId})`;
  const toName   = to.name   || to.label   || `(${toId})`;

  if (!Number.isFinite(fromLat) || !Number.isFinite(fromLon) ||
      !Number.isFinite(toLat)   || !Number.isFinite(toLon)) {
    throw new Error(`Invalid LatLon: ${fromId} -> ${toId}`);
  }

  const wps = [ { lat: fromLat, lon: fromLon }, { lat: toLat, lon: toLon } ];
  const ideals = (typeof getIdealPerLegs === 'function') ? getIdealPerLegs() : { idealDistPerLeg: 0, idealEnergyPerLeg: 0 };

  try {
    // APIå‘¼ã³å‡ºã—
    const out = await routeLegStatsForWaypoints(wps, profile);
    const summary = out?.feature?.properties?.summary || {};

    const distKm  = (Number(summary.distance) || 0) / 1000;
    const timeMin = (Number(summary.duration) || 0) / 60;
    
    const ene = out?.stats?.energy ?? out?.stats?.E ?? null;
    let energyKj = 0;
    if (Array.isArray(ene) && ene.length) {
      const last = Number(ene[ene.length - 1]);
      energyKj = (Number.isFinite(last) && last > 0) ? last : sumNums(ene);
    } else if (Number.isFinite(Number(ene))) {
      energyKj = Number(ene);
    }

    // ãƒ­ã‚°è¨˜éŒ²
    if (window.__collectViterbiEdges) {
      window.__viterbiAllEdgeRows = window.__viterbiAllEdgeRows || [];
      window.__viterbiAllEdgeRows.push({
        fromId, toId, fromName, toName,
        fromLat, fromLon, toLat, toLon,
        distKm, timeMin, energyKj,
        profile,
        ms: Math.round(performance.now() - t0),
        ok: true,
        errMsg: '',
        idealDistKm: ideals.idealDistPerLeg,
        idealEnergyKj: ideals.idealEnergyPerLeg
      });
    }

    return { 
        total: distKm, distKm, timeMin, energyKj,
        // â˜…è¿½åŠ : ç´¯ç©ç”¨ã«ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚‚è¿”ã™
        rawFeature: out.feature,
        rawStats: out.stats
    };

  } catch (e) {
    if (window.__collectViterbiEdges) {
      window.__viterbiAllEdgeRows = window.__viterbiAllEdgeRows || [];
      window.__viterbiAllEdgeRows.push({
        fromId, toId, fromName, toName,
        fromLat, fromLon, toLat, toLon,
        distKm: '', timeMin: '', energyKj: '',
        profile,
        ms: Math.round(performance.now() - t0),
        ok: false,
        errMsg: String(e?.message || e),
        idealDistKm: ideals.idealDistPerLeg,
        idealEnergyKj: ideals.idealEnergyPerLeg
      });
    }
    throw e;
  }
}
// 5. Edge(Viterbi)ç”¨: CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (IDåˆ—è¿½åŠ )
function downloadViterbiLogCsv() {
  const rows = window.__viterbiAllEdgeRows || [];
  if (!rows.length) {
    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    return;
  }

  // â˜…ãƒ˜ãƒƒãƒ€ãƒ¼ã®å…ˆé ­ã«IDåˆ—ã‚’è¿½åŠ 
  const header = [
    'From_ID', 'To_ID', 
    'From_Name', 'To_Name', 
    'Dist_km', 'Time_min', 'Energy_kJ', 'Cost', 
    'Exec_ms', 'Status', 'Error_Msg'
  ];
  
  const csvLines = [header.join(',')];

  rows.forEach(r => {
    const esc = (s) => `"${String(s || '').replace(/"/g, '""')}"`;
    const line = [
      esc(r.fromId),  // Aåˆ—: From ID
      esc(r.toId),    // Båˆ—: To ID
      esc(r.fromName),
      esc(r.toName),
      r.distKm ?? '',
      r.timeMin ?? '',
      r.energyKj ?? '',
      r.cost ?? '',
      r.ms ?? '',
      r.ok ? 'OK' : 'Error',
      esc(r.errMsg)
    ];
    csvLines.push(line.join(','));
  });

  const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
  const blob = new Blob([bom, csvLines.join('\r\n')], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `viterbi_edges_${new Date().toISOString().slice(0,19).replace(/[-:T]/g,'')}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// äº’æ›æ€§ç¶­æŒ
window.downloadViterbiEdgesCsv = downloadViterbiLogCsv;
</script>
</body>
</html>

