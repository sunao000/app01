<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>自転車ルート比較＋休憩（統合版 完全）</title>

<!-- ライブラリ -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map { height: 520px; width: 100%; }
html,body { height: 100%; margin: 0; padding: 0; }
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move;display:flex;justify-content:space-between;align-items:center;gap:8px}
#pointList li small{color:#666}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px;cursor:pointer}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
#routeButtons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
#routeButtons button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#f4f4f4;cursor:pointer}
#routeButtons button.active{background:#dfefff;border-color:#7aa7ff}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.92rem}
</style>
</head>
<body>

<!-- 操作パネル -->
<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="searchBtn">検索</button>
  <button id="locBtn">現在地追加</button>
  <button id="drawBtn">ルート計算</button>

  <label>プロファイル
    <select id="profileSelect">
      <option value="cycling-road" selected>ロードバイク</option>
      <option value="cycling-regular">自転車（一般）</option>
    </select>
  </label>
</div>

<!-- POI 検索設定 -->
<div class="section">
  <details open>
  <summary>休憩地点まわりのPOI</summary>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <label><input type="checkbox" id="poiToggle" checked> POI表示</label>
    <label>初期半径 <input id="poiRadius" type="number" value="300" min="50" step="50"> m</label>
    <label>件数上限（近い順） <input id="poiLimit" type="number" value="5" min="1" step="1"> 件</label>
    <label><input type="checkbox" id="chkConvenience" checked> コンビニ</label>
    <label><input type="checkbox" id="chkSuper" checked> スーパー</label>
    <label><input type="checkbox" id="chkDrug"  checked> ドラッグストア</label>
  </div>
</details>
</div>

<!-- 休憩設定パネル -->
<div class="section">
  <details open>
    <summary>休憩設定</summary>
    <div style="display:flex;flex-wrap:wrap;gap:10px">
      <label>基準
        <select id="restBasis">
          <option value="time">時間</option>
          <option value="energy" selected>kJ</option>
        </select>
      </label>
      <label>時間間隔 <input id="restMinutes" type="number" value="60" min="15" step="5"> 分</label>
      <label>kJしきい値 <input id="restKJ" type="number" value="500" min="100" step="50"> kJ</label>
    </div>

    <div style="margin-top:6px">
      <label><input type="checkbox" id="optAccum" checked> 積算トリガ</label><br>
      <label><input type="checkbox" id="optStatTrigger"> 統計トリガ</label>
      平均 <input id="statMean" type="number" value="20" step="1">km
      分散 <input id="statVar" type="number" value="9" step="0.5">km²<br>
      <label><input type="checkbox" id="optPercentTrigger"> 割合トリガ</label>
      %ごと <input id="percentStep" type="number" value="25" step="1"> %
      <select id="percentMetric">
        <option value="distance">距離</option>
        <option value="energy">エネルギー</option>
        <option value="time">時間</option>
      </select>
    </div>
  </details>
</div>

<!-- 休憩ログ表示 -->
<div class="section">
  <details open>
    <summary>休憩トリガ・ヒット状況</summary>
    <div id="restDebug" style="white-space:pre-wrap;font-size:0.9em"></div>
  </details>
</div>

<!-- 地点リストと地図 -->
<ul id="pointList"></ul>
<div id="map"></div>

<!-- ルート切替ボタン -->
<div id="routeButtons" class="section">
  <button id="btnShowShortest">最短ルート表示</button>
  <button id="btnShowFastest">最速ルート表示</button>
  <button id="btnShowSlope">勾配考慮ルート表示</button>
</div>

<!-- サマリー -->
<div id="summary">
  <div id="routeInfo">未計算</div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- 区間統計（各ルート） -->
<div class="section">
  <h3>区間統計（各ルート）</h3>
  <div id="legSummaryAll" style="font-size:0.9rem;"></div>
</div>

<!-- グラフ描画＆ダウンロード -->
<div id="charts" style="display:none;">
  <canvas id="energyChart"></canvas>
</div>
<div class="section">
  <button id="btnDownloadTime" disabled>PNG（時間×累積kJ）</button>
  <button id="btnDownloadDist" disabled>PNG（距離×累積kJ）</button>
</div>

<script>
/* ====== 設定 ====== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; // ←★OpenRouteService APIキーを入れてください
const ORS_ROOT = 'https://api.openrouteservice.org';

/* ====== ヘルパ ====== */
let map, pts=[], markerLayer, routeLayers={}, lastDirTs=0;
let routeData = { shortest:null, fastest:null, slope:null };

function $(id){return document.getElementById(id);}
function formatDist(m){return (m/1000).toFixed(2)+' km';}
function formatDur(s){const m=Math.round(s/60);return m<60? m+' 分' : (Math.floor(m/60)+' 時間 '+(m%60)+' 分');}

/* ====== 初期化 ====== */
window.addEventListener('DOMContentLoaded',()=>{
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {attribution:'©OpenStreetMap'}).addTo(map);

  // 検索ボタン：検索後に入力欄クリア
  $('searchBtn').onclick = () => {
    const val = $('placeInput').value.trim();
    if (!val) return;
    nomSearch(val);
    $('placeInput').value = ''; // 入力欄リセット
  };

  $('locBtn').onclick=()=>navigator.geolocation.getCurrentPosition(
      p=>addPoint({name:'現在地',lat:p.coords.latitude,lon:p.coords.longitude}),
      ()=>alert('現在地取得失敗'));
  $('drawBtn').onclick=drawRoutes;

  new Sortable($('pointList'),{
    animation:150,
    onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li.dataset.idx]);fixType();drawList();}
  });

  $('btnShowShortest').onclick = ()=> toggleSingleRoute('shortest', $('btnShowShortest'));
  $('btnShowFastest').onclick  = ()=> toggleSingleRoute('fastest',  $('btnShowFastest'));
  $('btnShowSlope').onclick    = ()=> toggleSingleRoute('slope',    $('btnShowSlope'));

  // グラフダウンロードボタン
  $('btnDownloadTime').onclick = ()=>{
    if(!routeData.fastest){alert('まずルート計算してください');return;}
    const s = buildEnergySeries(routeData.fastest,75,18,true);
    if(s.labels.length>1) downloadLineChart(s);
  };
  $('btnDownloadDist').onclick = ()=>{
    if(!routeData.fastest){alert('まずルート計算してください');return;}
    const s = buildEnergySeries(routeData.fastest,75,18,false);
    if(s.labels.length>1) downloadLineChart(s);
  };
});

/* ====== 地点管理 ====== */
function addPoint(p){
  p.type=pts.length?'':'start';
  pts.forEach(d=>{if(d.type==='goal')d.type='via';});
  pts.push(p);
  if(pts.length>1) pts[pts.length-1].type='goal';
  drawList();
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li.dataset.idx=i;
    const name = p.name + (p.isRest? '（休憩）':'');
    li.innerHTML = `<span>${name}${p.isRest? ' <small>(' + p.lat.toFixed(5)+','+p.lon.toFixed(5)+')</small>':''}</span><button class="del">×</button>`;
    li.querySelector('.del').onclick=()=>{pts.splice(i,1); fixType(); drawList();};
    ul.appendChild(li);
  });
}

/* ====== 検索 ====== */
async function nomSearch(q){
  const url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  const arr=await (await fetch(url)).json();
  if(!arr.length){alert('見つかりません');return;}
  const o=arr[0];
  addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
}

/* ====== ORS ====== */
async function post(url,body){
  const r=await fetch(url,{
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':ORS_KEY},
    body:JSON.stringify(body)
  });
  if(!r.ok) throw new Error(r.status);
  return r.json();
}
async function dir(body,profile){
  const wait=1100-(Date.now()-lastDirTs); if(wait>0) await new Promise(r=>setTimeout(r,wait));
  const d=await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`,body);
  lastDirTs=Date.now();
  return d;
}

/* ====== ルート表示関連 ====== */
function clearRouteLayers(){
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); });
  routeLayers={};
}
function setActiveButton(btn){
  document.querySelectorAll('#routeButtons button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
}
function showSingleRoute(type, noFit){
  clearRouteLayers();
  const colorMap = { shortest:'#ff0000', fastest:'#0066ff', slope:'#ff9900' };
  const f = routeData[type];
  if(!f){ alert('まだ計算していません'); return; }
  routeLayers[type] = L.geoJSON(f, { style:{ color: colorMap[type], weight: 6 } }).addTo(map);
  if(!noFit) map.fitBounds(routeLayers[type].getBounds().pad(0.1));
}
function toggleSingleRoute(type, btn){
  showSingleRoute(type);
  setActiveButton(btn);
}

/* ====== ルート計算・休憩・POI ====== */
async function drawRoutes(){
  if(pts.length<2){alert('2地点以上登録してください');return;}

  clearRouteLayers();
  if(markerLayer) map.removeLayer(markerLayer);

  markerLayer=L.layerGroup().addTo(map);
  const ICON = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
  const ICONS = {start:ICON('green'),via:ICON('blue'),goal:ICON('red')};
  pts.forEach(p=>markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ICONS[p.type||'via']}).bindTooltip(p.name)));

  const coords=pts.map(p=>[p.lon,p.lat]);
  const profile = $('profileSelect').value;
  const base={coordinates:coords,elevation:true,extra_info:['steepness']};

  try{
    const shortest = await dir({...base, preference:'shortest'}, profile);
    const fastest  = await dir({...base, preference:'fastest'},  profile);

    let slope = shortest.features[0];
    if(coords.length===2){
      const alt = await dir({...base, preference:'shortest',
        alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}, profile);
      const feats = alt.features || [];
      if(feats.length){
        function steepSum(f){
          const vals=((f.properties||{}).extras||{}).steepness?.values||[];
          let s=0; for(const v of vals){ s+=Math.abs(v[2]||0); }
          return s;
        }
        slope = feats.reduce((a,b)=> steepSum(a)<steepSum(b)?a:b);
      }
    }

    routeData.shortest = shortest.features[0];
    routeData.fastest  = fastest.features[0];
    routeData.slope    = slope;

    const s1 = routeData.shortest.properties.summary;
    const s2 = routeData.fastest.properties.summary;
    const s3 = routeData.slope.properties.summary;
    $('routeInfo').innerHTML =
      `<b>最短</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>最速</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>勾配</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}`;
    $('distanceScore').textContent = '距離差（最速-最短）: '+(s2.distance - s1.distance).toFixed(0)+' m';

    /* ===== 休憩地点挿入 ===== */
    const mass = 75; // 体重+バイク質量(例)
    const flat = 18; // 平坦係数
    const rests = await makeRestPoints(routeData.fastest, mass, flat);

    if (rests.length) {
      // リストに挿入（ゴール直前）
      rests.forEach(r => pts.splice(pts.length-1, 0,
        { name:'休憩', lat:r.lat, lon:r.lon, type:'via', isRest:true }));
      drawList();

      // 休憩マーカー
      for (const r of rests) {
        L.marker([r.lat, r.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        }).bindTooltip('休憩').addTo(markerLayer);
      }

      // POI検索（半径固定・近い順に n 件）
      if ($('poiToggle').checked) {
        const baseRadius = Number($('poiRadius').value) || 300;
        const limit = Math.max(1, Number($('poiLimit').value) || 5);
        for (const r of rests) {
          try {
            const pois = await fetchPoisAround(r.lat, r.lon, baseRadius, limit);
            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 半径${baseRadius}m → ${pois.length}件（近い順）`);
            pois.forEach(po => {
              L.marker([po.lat, po.lon], {
                icon: new L.Icon({
                  iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple.png',
                  iconSize: [24, 24],
                  iconAnchor: [12, 24]
                })
              }).bindTooltip(po.name).addTo(markerLayer);
            });
          } catch (e) {
            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 取得失敗`);
          }
        }
      }
    }

    // デフォルト表示は最速
    showSingleRoute('fastest', true);
    setActiveButton($('btnShowFastest'));

    // 区間統計を表示
    await showRouteLegSummary();

    // グラフボタン有効化
    $('btnDownloadTime').disabled = false;
    $('btnDownloadDist').disabled = false;

  }catch(e){
    console.error(e);
    alert('ルート取得失敗: '+e.message);
  }
}

/* ===== 休憩トリガー関連 ===== */
function logRest(msg){ $('restDebug').textContent += msg + "\n"; }
function energyStepKJ(dist,dz,mass,flat=18){
  return flat*(dist/1000)+Math.max(dz,0)*mass*9.80665/1000;
}
async function totalEnergyKJ(feature,mass,flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments||[];
  let tot=0;
  for(const s of segs){
    for(const st of s.steps||[]){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz = coords[i1].length>=3 ? (coords[i1][2]-coords[i0][2]) : 0;
      tot += energyStepKJ(d,dz,mass,flat);
    }
  }
  return tot;
}
async function makeRestPoints(feature,mass,flat){
  const coords=feature.geometry.coordinates;
  const segs=(feature.properties.segments||[]);
  const hasEle = coords[0].length>=3;
  const cumDist=[0];
  for(let i=1;i<coords.length;i++){
    cumDist[i]=cumDist[i-1]+L.latLng(coords[i][1],coords[i][0]).distanceTo([coords[i-1][1],coords[i-1][0]]);
  }

  const basis=$('restBasis').value;
  const thr=basis==='time' ? Number($('restMinutes').value)*60 : Number($('restKJ').value);
  let raw=[];

  // 積算トリガ
  if($('optAccum').checked){
    let acc=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0, t=st.duration||0;
        const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
        const dE = energyStepKJ(d,dz,mass,flat);
        acc += (basis==='time') ? t : dE;
        if(acc >= thr){
          raw.push({lat:coords[i1][1],lon:coords[i1][0],routeD:cumDist[i1]});
          logRest(`[ACCUM] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);
          acc=0;
        }
      }
    }
  }

  // 統計トリガ
  if($('optStatTrigger').checked){
    const mean=Number($('statMean').value), vari=Number($('statVar').value);
    const rng=()=>Math.random();
    const normal=()=>Math.sqrt(-2*Math.log(rng()))*Math.cos(2*Math.PI*rng());
    let target=mean + Math.sqrt(vari)*normal();
    let acc=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0;
        acc += d/1000;
        if(acc >= target){
          raw.push({lat:coords[i1][1],lon:coords[i1][0],routeD:cumDist[i1]});
          logRest(`[STAT] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);
          target = mean + Math.sqrt(vari)*normal();
          acc=0;
        }
      }
    }
  }

  // 割合トリガ
  if($('optPercentTrigger').checked){
    const stepPct=Number($('percentStep').value)/100;
    const metric=$('percentMetric').value;
    const totalDist = feature.properties.summary.distance;
    const totalTime = feature.properties.summary.duration;
    const totalEnergy = await totalEnergyKJ(feature,mass,flat);
    let passed=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0,t=st.duration||0;
        const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
        const dE = energyStepKJ(d,dz,mass,flat);
        if(metric==='distance') passed+=d;
        else if(metric==='time') passed+=t;
        else passed+=dE;
        const total = metric==='distance'? totalDist : metric==='time'? totalTime : totalEnergy;
        while(passed >= stepPct*total){
          raw.push({lat:coords[i1][1],lon:coords[i1][0],routeD:cumDist[i1]});
          logRest(`[PERCENT] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);
          passed = 0;
        }
      }
    }
  }
  return raw;
}

/* ===== 区間統計（各ルート） ===== */
async function calcLegStats(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments || [];
  const hasEle = coords[0].length >= 3;

  const legDist = [], legTime = [], legEnergy = [];
  for (const s of segs) {
    for (const step of (s.steps || [])) {
      const [i0, i1] = step.way_points || [0, 0];
      const d  = step.distance || 0;  // m
      const t  = step.duration || 0;  // s
      const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
      legDist.push(d / 1000);
      legTime.push(t / 60);
      legEnergy.push(energyStepKJ(d, dz, mass, flat));
    }
  }
  return {dist:legDist, time:legTime, energy:legEnergy};
}
function summaryStats(arr){
  if(!arr.length) return {mean:0,var:0,std:0};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length;
  return {mean:m, var:v, std:Math.sqrt(v)};
}
async function showRouteLegSummary(){
  const mass = 75, flat = 18;
  const outDiv = document.getElementById('legSummaryAll');
  outDiv.innerHTML = '';
  for (const key of ['shortest','fastest','slope']){
    const feat = routeData[key];
    if(!feat) continue;
    const s = await calcLegStats(feat, mass, flat);
    const ds = summaryStats(s.dist);
    const ts = summaryStats(s.time);
    const es = summaryStats(s.energy);
    const label = key==='shortest'?'最短':key==='fastest'?'最速':'勾配';
    const html = `
      <details open style="margin-bottom:8px">
        <summary><b>${label}</b> 区間統計（平均 / 分散 / 標準偏差）</summary>
        距離: ${ds.mean.toFixed(2)} km / ${ds.var.toFixed(2)} km² / σ=${ds.std.toFixed(2)} km<br>
        時間: ${ts.mean.toFixed(2)} 分 / ${ts.var.toFixed(2)} 分² / σ=${ts.std.toFixed(2)} 分<br>
        エネルギー: ${es.mean.toFixed(1)} kJ / ${es.var.toFixed(1)} kJ² / σ=${es.std.toFixed(1)} kJ
      </details>`;
    outDiv.innerHTML += html;
  }
}

/* ===== グラフ出力 ===== */
function tempShowChartsContainer(show){
  const c = document.getElementById('charts');
  if(show){
    c.style.display='block';
    c.style.position='absolute';
    c.style.left='-99999px';
    c.style.visibility='hidden';
  }else{
    c.removeAttribute('style');
    c.style.display='none';
  }
}
function prepareCanvasSize(canvas,w,h){
  canvas.width=w||1600;
  canvas.height=h||900;
}
async function downloadLineChart(obj){
  tempShowChartsContainer(true);
  const ec = document.getElementById('energyChart');
  prepareCanvasSize(ec,1600,900);

  const chart = new Chart(ec,{
    type:'line',
    data:{labels:obj.labels,
          datasets:[{label:obj.ylabel,data:obj.values,borderWidth:2,pointRadius:0}]},
    options:{
      animation:false,
      plugins:{legend:{display:false}},
      scales:{ x:{title:{display:true,text:obj.xlabel}},
               y:{title:{display:true,text:obj.ylabel}} }
    }
  });

  await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));

  ec.toBlob(blob=>{
    if(blob){
      const u = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = u; a.download = obj.filename; a.click();
      setTimeout(()=>{ URL.revokeObjectURL(u); chart.destroy(); tempShowChartsContainer(false); },300);
    }else{
      chart.destroy(); tempShowChartsContainer(false);
    }
  });
}
function buildEnergySeries(feature,mass,flat,byTime=true){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length >= 3;
  const segs   = feature.properties.segments || [];
  let cumT=0, cumD=0, cumE=0;
  const labels=[], values=[];
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d  = st.distance || 0;
      const t  = st.duration || 0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      cumE += energyStepKJ(d,dz,mass,flat);
      cumD += d;
      cumT += t;
      labels.push(byTime? (cumT/60).toFixed(2) : (cumD/1000).toFixed(2));
      values.push(+cumE.toFixed(1));
    }
  }
  return {
    labels,
    values,
    xlabel: byTime?'時間 (分)':'距離 (km)',
    ylabel:'累積エネルギー (kJ)',
    filename: byTime?'energy_over_time.png':'energy_over_distance.png'
  };
}

/* ===== Overpass（保守的実装） ===== */
async function overpassQuery(query) {
  const endpoints = [
    'https://overpass-api.de/api/interpreter',
    'https://overpass.kumi.systems/api/interpreter'
  ];
  let lastStatus = 0, lastText = '';

  for (const ep of endpoints) {
    try {
      const r = await fetch(ep, {
        method: 'POST',
        headers: {
          'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8',
          'Accept': 'application/json,text/plain,*/*'
        },
        body: new URLSearchParams({ data: query }).toString()
      });
      lastStatus = r.status;
      if (r.ok) return r.json();
      lastText = await r.text();
      if (r.status === 400) {
        console.warn('[Overpass] 400 detected.\n---QUERY START---\n' + query + '\n---QUERY END---\n' +
                     '---RESPONSE START---\n' + lastText + '\n---RESPONSE END---');
      }
    } catch (e) {
      lastText = e.message || String(e);
    }
  }
  throw new Error(`[Overpass] all attempts failed. Last status=${lastStatus}. Snippet=${(lastText||'').slice(0,1200)}`);
}
async function overpassRetry(query) {
  let delay = 800;
  for (let i=0;i<5;i++) {
    try {
      return await overpassQuery(query);
    } catch (e) {
      if (String(e).includes('status=400')) throw e; // 構文系は打ち切り
      await new Promise(res=>setTimeout(res, delay));
      delay = Math.min(6000, Math.round(delay*1.8));
    }
  }
  return await overpassQuery(query);
}

/* ===== POI取得：半径固定・近い順に n 件 ===== */
async function fetchPoisAround(latRaw, lonRaw, baseRadius, limit) {
  const useConvenience = document.getElementById('chkConvenience')?.checked ?? true;
  const useSuper       = document.getElementById('chkSuper')?.checked ?? true;
  const useDrug        = document.getElementById('chkDrug')?.checked ?? true;
  if (!useConvenience && !useSuper && !useDrug) return [];

  const round6 = v => Math.round(Number(v) * 1e6) / 1e6;
  const lat = round6(latRaw), lon = round6(lonRaw);
  const radius = Math.max(30, Number(baseRadius) || 300);
  const centerLL = L.latLng(lat, lon);

  // 統合クエリ（node/way を明示）
  const unifiedQuery = (() => {
    const clauses = [];
    const shopVals = [];
    if (useConvenience) shopVals.push('convenience');
    if (useSuper)       shopVals.push('supermarket');
    if (useDrug)        shopVals.push('chemist','pharmacy');
    if (shopVals.length) {
      const re = '(' + shopVals.join('|') + ')';
      clauses.push(`node(around:${radius},${lat},${lon})["shop"~"${re}"]`);
      clauses.push(`way(around:${radius},${lat},${lon})["shop"~"${re}"]`);
    }
    if (useDrug) {
      clauses.push(`node(around:${radius},${lat},${lon})["amenity"="pharmacy"]`);
      clauses.push(`way(around:${radius},${lat},${lon})["amenity"="pharmacy"]`);
    }
    if (!clauses.length) return null;
    return `[out:json][timeout:25];
(
  ${clauses.join(';\n  ')};
);
out center;`;
  })();

  // 400時の分割クエリ
  const splitSpecs = [];
  if (useConvenience) splitSpecs.push(['shop','convenience']);
  if (useSuper)       splitSpecs.push(['shop','supermarket']);
  if (useDrug) {
    splitSpecs.push(['shop','chemist'], ['shop','pharmacy'], ['amenity','pharmacy']);
  }
  const runSplitQueries = async () => {
    const acc = [];
    for (const [k,v] of splitSpecs) {
      const q = `[out:json][timeout:25];
(
  node(around:${radius},${lat},${lon})["${k}"="${v}"];
  way(around:${radius},${lat},${lon})["${k}"="${v}"];
);
out center;`;
      try {
        const data = await overpassRetry(q);
        (data.elements || []).forEach(e => acc.push(e));
        await new Promise(r=>setTimeout(r,150));
      } catch (err) {
        console.warn('[Overpass split] fail', k, v, err);
      }
    }
    return acc;
  };

  let elements = [];
  if (unifiedQuery) {
    try {
      const data = await overpassRetry(unifiedQuery);
      elements = data.elements || [];
    } catch (err) {
      if (String(err).includes('status=400')) {
        elements = await runSplitQueries();
      } else {
        throw err;
      }
    }
  }

  // elements → results（距離を付与）
  const resultsRaw = [];
  elements.forEach(e => {
    const ll = e.type === 'node'
      ? [e.lat, e.lon]
      : (e.center ? [e.center.lat, e.center.lon] : null);
    if (!ll) return;
    const name = (e.tags && (e.tags['name:ja'] || e.tags.name || e.tags.brand)) || 'POI';
    const dist = centerLL.distanceTo([ll[0], ll[1]]); // m
    resultsRaw.push({ name, lat: ll[0], lon: ll[1], dist });
  });

  // 近い順にソート → 上位 n 件
  resultsRaw.sort((a,b)=>a.dist-b.dist);
  const limitN = Math.max(1, Number(limit) || 5);
  const topN = resultsRaw.slice(0, limitN);

  // 同名・同座標重複の軽い除去
  const seen = new Set();
  const results = [];
  for (const p of topN) {
    const key = `${p.name}|${p.lat.toFixed(5)},${p.lon.toFixed(5)}`;
    if (seen.has(key)) continue;
    seen.add(key);
    results.push(p);
  }
  return results;
}

/* ===== 小ユーティリティ ===== */
function sanitizeCoord(n, fallback) {
  const v = Number(n);
  if (!isFinite(v)) return Number(fallback);
  return Math.round(v * 1e6) / 1e6;
}
</script>
</body>
</html>
