<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>è‡ªè»¢è»Šãƒ«ãƒ¼ãƒˆæ¯”è¼ƒï¼‹ä¼‘æ†©ï¼ˆçµ±åˆç‰ˆ å®Œå…¨ï¼‰</title>

<!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map { height: 520px; width: 100%; }
html,body { height: 100%; margin: 0; padding: 0; }
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move;display:flex;justify-content:space-between;align-items:center;gap:8px}
#pointList li small{color:#666}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px;cursor:pointer}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
#routeButtons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
#routeButtons button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#f4f4f4;cursor:pointer}
#routeButtons button.active{background:#dfefff;border-color:#7aa7ff}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.92rem}
</style>
</head>
<body>

<!-- æ“ä½œãƒ‘ãƒãƒ« -->
<div id="controls">
  <input id="placeInput" placeholder="åœ°åãƒ»ä½æ‰€" style="width:260px">
  <button id="searchBtn">æ¤œç´¢</button>
  <button id="drawBtn">ä¼‘æ†©å ´æ‰€æ¤œç´¢</button>
  <button id="solveCombBtn">ãƒ«ãƒ¼ãƒˆæ¤œç´¢</button>

</div>

<!-- â–¼â–¼ åœ°åæ¤œç´¢å€™è£œãƒªã‚¹ãƒˆ â–¼â–¼ -->
<ul id="searchSuggestions"
    style="list-style:none;margin:4px 0;padding:0 8px;background:#fff;
           border:1px solid #ccc;max-height:150px;overflow:auto;">
</ul>

<!-- POI æ¤œç´¢è¨­å®š -->
<div class="section">
  <details open>
  <summary>ä¼‘æ†©åœ°ç‚¹ã¾ã‚ã‚Šã®POI</summary>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <label><input type="checkbox" id="poiToggle" checked> POIè¡¨ç¤º</label>
    <label>åˆæœŸåŠå¾„ <input id="poiRadius" type="number" value="500" min="50" step="50"> m</label>
    <label>ä»¶æ•°ä¸Šé™ï¼ˆè¿‘ã„é †ï¼‰ <input id="poiLimit" type="number" value="5" min="1" step="1"> ä»¶</label>
    <label><input type="checkbox" id="chkConvenience" checked> ã‚³ãƒ³ãƒ“ãƒ‹</label>
    <label><input type="checkbox" id="chkSuper" checked> ã‚¹ãƒ¼ãƒ‘ãƒ¼</label>
    <label><input type="checkbox" id="chkDrug"  checked> ãƒ‰ãƒ©ãƒƒã‚°ã‚¹ãƒˆã‚¢</label>
  </div>
</details>
</div>

<!-- ä¼‘æ†©è¨­å®šãƒ‘ãƒãƒ« -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©è¨­å®š</summary>
    <div style="display:flex;flex-wrap:wrap;gap:10px">
      <label>åŸºæº–
        <select id="restBasis">
          <option value="time">æ™‚é–“</option>
          <option value="energy" selected>kJ</option>
        </select>
      </label>
      <label>æ™‚é–“é–“éš” <input id="restMinutes" type="number" value="60" min="15" step="5"> åˆ†</label>
      <label>kJã—ãã„å€¤ <input id="restKJ" type="number" value="500" min="100" step="50"> kJ</label>
    </div>

    <div style="margin-top:6px">
      <label><input type="checkbox" id="optAccum"> ç©ç®—ãƒˆãƒªã‚¬</label><br>
      <label><input type="checkbox" id="optStatTrigger"> çµ±è¨ˆãƒˆãƒªã‚¬</label>
      å¹³å‡ <input id="statMean" type="number" value="20" step="1">km
      åˆ†æ•£ <input id="statVar" type="number" value="9" step="0.5">kmÂ²<br>
      <label><input type="checkbox" id="optPercentTrigger" checked> å‰²åˆãƒˆãƒªã‚¬</label>
%ã”ã¨ <input id="percentStep" type="number" value="25" step="1"> %
<select id="percentMetric">
  <option value="distance">è·é›¢</option>
  <option value="energy" selected>ã‚¨ãƒãƒ«ã‚®ãƒ¼</option>
  <option value="time">æ™‚é–“</option>
</select>
    </div>
    
    <!-- ã‚´ãƒ¼ãƒ«ï¼æ—¢å­˜åœ°ç‚¹ è¿‘æ¥ã‚¹ã‚­ãƒƒãƒ—è¨­å®š -->
<div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:6px">
  <label><input type="checkbox" id="skipNearGoalToggle" checked> ã‚´ãƒ¼ãƒ«æ‰‹å‰ã¯ä¼‘æ†©ã‚’ä½œã‚‰ãªã„</label>
  <label>ã‚¹ã‚­ãƒƒãƒ—è·é›¢ï¼ˆã‚´ãƒ¼ãƒ«æ‰‹å‰ï¼‰
    <input id="skipNearGoalKm" type="number" value="1.0" min="0" step="0.1"> km
  </label>
  <label><input type="checkbox" id="skipNearNodeToggle" checked> æ—¢å­˜åœ°ç‚¹ã®è¿‘æ¥ã¯ä¼‘æ†©ã‚’ä½œã‚‰ãªã„</label>
  <label>è¿‘æ¥åˆ¤å®š
    <input id="skipNearNodeM" type="number" value="150" min="0" step="10"> m
  </label>
</div>

  </details>
</div>

<!-- ä¼‘æ†©ãƒ­ã‚°è¡¨ç¤º -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ»ãƒ’ãƒƒãƒˆçŠ¶æ³</summary>
    <div id="restDebug" style="white-space:pre-wrap;font-size:0.9em"></div>
  </details>
</div>

<!-- â–¼â–¼ ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆè¡¨ç¤º â–¼â–¼ -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆ</summary>
    <ul id="restListPanel"
        style="list-style:none;margin:0;padding:0;font-size:0.9rem"></ul>
  </details>
</div>

<div class="section" style="background:#f0f8ff;">
  <details>
    <summary>æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒï¼ˆä¸€æ‹¬ vs åŒºé–“ç©ä¸Šï¼‰</summary>
    <div style="padding:8px; font-size:0.9rem;">
      <p style="margin:0 0 8px 0;color:#666">å„ãƒˆãƒªã‚¬ãƒ¼ã§çµŒç”±ã™ã‚‹POIã‚’é¸ã‚“ã§æç”»ã—ã¾ã™ã€‚</p>
      
      <button onclick="updateManualRouteUI()" style="margin-bottom:8px;font-size:12px;">ğŸ”„ ãƒªã‚¹ãƒˆãŒç©ºã®å ´åˆã¯ã“ã“ã‚’æŠ¼ã—ã¦æ›´æ–°</button>

      <div id="manualRouteSelectors" style="display:flex;flex-direction:column;gap:6px;margin-bottom:8px;">
        (ä¼‘æ†©å ´æ‰€æ¤œç´¢ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„)
      </div>

      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:8px;">
        <label style="color:#0055aa;font-weight:bold;">
          <input type="checkbox" id="chkManBatch" checked> ä¸€æ‹¬ (API1å›/é’)
        </label>
        <label style="color:#aa0000;font-weight:bold;">
          <input type="checkbox" id="chkManSeg" checked> åŒºé–“ç©ä¸Š (APIè¤‡æ•°å›/èµ¤)
        </label>
      </div>
      
      <button id="btnDrawManualRoute" onclick="drawManualComparison()" style="width:100%;padding:6px;">é¸æŠã—ãŸPOIã§æ¯”è¼ƒæç”»</button>
      <div id="manualRouteInfo" style="margin-top:6px;font-size:0.85rem;white-space:pre-wrap;"></div>
    </div>
  </details>
</div>

<!-- ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼åˆ¥ã®å€™è£œPOI -->
<div class="section">
  <details open>
    <summary>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼åˆ¥ã®å€™è£œPOI</summary>
    <ol id="restPoiPanel" style="margin:0;padding-left:1.1rem;font-size:0.9rem"></ol>
  </details>
</div>

<!-- åœ°ç‚¹ãƒªã‚¹ãƒˆã¨åœ°å›³ -->
<ul id="pointList"></ul>
<div id="map"></div>

<!-- ãƒ«ãƒ¼ãƒˆæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  -->
<!-- ç›´ç·šè·é›¢ï¼ˆå…¨çµ„ã¿åˆã‚ã›ï¼‰ -->
<div class="section">
  <h3>ç›´ç·šè·é›¢ï¼ˆå…¨çµ„ã¿åˆã‚ã›ï¼‰</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px">
    <button id="btnCalcLinear">ç›´ç·šè·é›¢ã‚’è¨ˆç®—ï¼ˆ1ãƒˆãƒªã‚¬ãƒ¼1ä»¶ Ã— å…¨çµ„åˆã›ï¼‰</button>
    <button id="btnDownloadLinearCsv" disabled>CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  </div>
  <div id="linearSummary" style="font-size:0.9rem;color:#555"></div>
  <div id="linearList" style="font-family:ui-monospace,monospace;white-space:pre;max-height:260px;overflow:auto;border:1px solid #eee;padding:6px"></div>
</div>

<div class="section">
  <label>æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
    <select id="algoSelect">
      <option value="greedy" selected>ç­‰é–“éš”è²ªæ¬²ï¼ˆé«˜é€Ÿãƒ»ã‚¼ãƒ­APIï¼‰</option>
      <option value="beam3">ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ãƒ»ã‚¼ãƒ­APIï¼‰</option>
      <option value="bruteforce">ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰</option>
      <option value="dp">DPï¼ˆæœ€çŸ­è·¯ãƒ»ã‚¼ãƒ­APIï¼‰</option>
    </select>
  </label>
  <small style="color:#666;margin-left:8px">â€»ç·å½“ãŸã‚Šã¯APIåˆ¶é™ã«æ³¨æ„</small>
</div>

<!-- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚° -->
<div class="section">
  <details open>
    <summary>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ï¼ˆç·å½“ãŸã‚Š vs ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼‰</summary>
    <div style="margin:6px 0;">
      <button id="btnAlgoCompare" type="button">
        ç·å½“ãŸã‚Š ã¨ ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ ã‚’æ¯”è¼ƒï¼ˆåŒã˜POIã‚»ãƒƒãƒˆï¼‰
      </button>
      <button id="dbgAlgoCsv" type="button" style="margin-left:8px;">
        Excelç”¨CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      </button>
      <small style="color:#666;display:block;margin-top:4px">
        â€»å…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã§ ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼‹POI ã‚’ä½œã£ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚
      </small>
    </div>
    <pre id="algoComparePanel"
         style="font-family:ui-monospace,monospace;font-size:12px;
                white-space:pre-wrap;border:1px solid #eee;
                padding:6px;max-height:260px;overflow:auto;">
æœªå®Ÿè¡Œ
    </pre>
  </details>
</div>

<div id="viterbiEdgeTools" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0;">
  <button id="btnShowViterbiEdges">Viterbiã‚¨ãƒƒã‚¸è¡¨ç¤º</button>
  <button id="btnHideViterbiEdges">Viterbiã‚¨ãƒƒã‚¸éè¡¨ç¤º</button>
  <button id="btnDlViterbiEdgesCsv">Viterbiã‚¨ãƒƒã‚¸CSV(Excel)DL</button>
  <span id="viterbiEdgeStat" style="opacity:.8;"></span>
</div>

<div id="viterbiEdgesPanel" style="display:none; padding:8px; background:#fff; border:1px solid #ccc; margin:8px 0; max-height:220px; overflow:auto; white-space:pre;"></div>


<pre id="viterbiEdgePanel" style="display:none;max-height:260px;overflow:auto;border:1px solid #ddd;padding:8px;background:#fafafa;"></pre>

<label><input type="checkbox" id="dbg_beam" checked> ãƒ“ãƒ¼ãƒ </label>
<label><input type="checkbox" id="dbg_bf" checked> ç·å½“ãŸã‚Š</label>
<label><input type="checkbox" id="dbg_vit" checked> Viterbi</label>
<label><input type="checkbox" id="dbg_A" checked> å¯¾ç­–A</label>
<label><input type="checkbox" id="dbg_B" checked> å¯¾ç­–B</label>
<label><input type="checkbox" id="dbg_C" checked> å¯¾ç­–C</label>
<label><input type="checkbox" id="dbg_D" checked> å¯¾ç­–D</label>
<label><input type="checkbox" id="dbg_E" checked> å¯¾ç­–E</label>
<label><input type="checkbox" id="dbg_F" checked> å¯¾ç­–F</label>
<label><input type="checkbox" id="dbg_G" checked> å¯¾ç­–G</label>
<label><input type="checkbox" id="dbg_H" checked> å¯¾ç­–H</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  A/B beamWidth
  <input id="abBeamWidth" type="number" min="1" step="1" value="40" style="width:72px">
</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  A/B topK
  <input id="abTopK" type="number" min="1" step="1" value="150" style="width:72px">
</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  è‡ªå‹•èª¿æ•´
  <input id="abAutoParams" type="checkbox" checked>
</label>

<!-- ã‚µãƒãƒªãƒ¼ -->
<div id="summary">
  <div id="routeInfo">æœªè¨ˆç®—</div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒãƒ¼ã®ã©ã“ã‹ã«è¿½åŠ  -->

<script>
/* ====== è¨­å®š ====== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; 
// const ORS_KEY  = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjE0YTgxN2M5OWZmNjQ4MmNiMTZkYTk3YWFkMDI2MDAxIiwiaCI6Im11cm11cjY0In0=';
const ORS_ROOT = 'https://api.openrouteservice.org';

/* ====== ãƒ˜ãƒ«ãƒ‘ ====== */
let map, pts=[], markerLayer, routeLayers={}, lastDirTs=0;
let routeData = { shortest:null, fastest:null, slope:null, arterial:null };
let OVERPASS_CALL_TOTAL = 0;  // Overpass API ã®ç´¯è¨ˆå‘¼ã³å‡ºã—å›æ•°

  window.__algoCompareRows = [];
  window.__bruteforceAllResults = [];   // â˜… ç·å½“ãŸã‚Šã®å…¨çµæœã‚’ä¿å­˜ã™ã‚‹é…åˆ—

// æ—¢å­˜ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®è¿‘ãã«è¿½åŠ 
let restBeamLayer;   // ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®é“ã®ã‚Šãƒ“ãƒ¼ãƒ ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼

/* ===== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */

// restGroups ã®è¦ç´ ãŒ
// å½¢â‘ : {rest, pois:[...]} ã§ã‚‚ å½¢â‘¡: [...] ã§ã‚‚åŒã˜ã‚ˆã†ã« POIé…åˆ—ã‚’å–ã‚Šå‡ºã™
function getPoisGroup(g){
  if (Array.isArray(g)) return g.filter(Boolean);
  if (g && Array.isArray(g.pois)) return g.pois.filter(Boolean);
  return [];
}

// restGroups(å½¢â‘ /â‘¡ã©ã¡ã‚‰ã§ã‚‚OK) â†’ [ [poi...], [poi...], ... ] ã«çµ±ä¸€ã—ã¦è¿”ã™
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const name = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();
  if (name) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // â† POI{ãƒˆãƒªã‚¬ãƒ¼ID}_{ID}
  return poi;
}

function makeCandGroupsFromRestGroups(restGroups, cap=5, sorter=null){
  return (restGroups || []).map((g, i)=>{
    const arr = getPoisGroup(g);
    if(!arr.length) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã«å€™è£œPOIãŒã‚ã‚Šã¾ã›ã‚“`);

    const out = arr.slice();
    if (typeof sorter === 'function') out.sort(sorter);

    const sliced = out.slice(0, Math.min(cap, out.length));

    // â˜…ã“ã“ã§ç¢ºå®Ÿã«åå‰ã‚’ä»˜ã‘ã‚‹ï¼ˆ0å§‹ã¾ã‚Š & å®‰å®šIDï¼‰
    sliced.forEach((p, b) => {
      // ã™ã§ã« ensureProjections ã§ _triggerId/_poiIdInTrigger ãŒä»˜ã„ã¦ã‚‹ãªã‚‰ãã‚ŒãŒå„ªå…ˆã•ã‚Œã‚‹
      ensurePoiName(p, i, b);
    });

    return sliced;
  });
}

// HTMLè¦ç´ å–å¾—
function $(id){ return document.getElementById(id); }

// CSVç”¨ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
function csvEscape(s){
  return String(s).replace(/"/g, '""');
}

// CSVæ–‡å­—åˆ—ã‚’ä½œã£ã¦ Blob ã‚’è¿”ã™ï¼ˆUTF-8 BOM & CRLFï¼‰
function buildCsvBlob(header, rows){
  const lines = [];
  if (header && header.length) lines.push(header.join(','));
  if (rows && rows.length){
    for (const cols of rows){
      lines.push(cols.join(','));
    }
  }
  const bom = new Uint8Array([0xEF,0xBB,0xBF]);
  const csv = lines.join('\r\n');
  return new Blob([bom, csv], { type: 'text/csv;charset=utf-8' });
}

// Blob ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

// é…åˆ—ã®æ¨™æº–åå·®
function stdDev(arr){
  if (!arr || !arr.length) return 0;
  const m = arr.reduce((a,b)=>a+b, 0) / arr.length;
  const v = arr.reduce((s,x)=> s + (x-m)*(x-m), 0) / arr.length;
  return Math.sqrt(v);
}

/* ===== ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ»è©•ä¾¡é–¢é€£ ===== */
// ã“ã“ã« comboScore é–¢é€£ / SCORE_METRIC / evalByCums ãªã©
// ã€Œãƒ«ãƒ¼ãƒˆè©•ä¾¡ãƒ»ã‚¹ã‚³ã‚¢ç®—å‡ºã€ã‚’è¡Œã†é–¢æ•°ãŸã¡ã‚’ã¾ã¨ã‚ã¦ç½®ã
  
// ã‚¹ã‚³ã‚¢ï¼ˆå°ã•ã„ã»ã©è‰¯ã„ï¼‰ï¼šè·é›¢/æ™‚é–“/ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ¨™æº–åå·®ã®åˆè¨ˆ
function comboScore(legStats){
  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const metric = getScoreMetric();
  if (metric === 'time')   return sd(legStats.time);
  if (metric === 'energy') return sd(legStats.energy);
  return sd(legStats.dist); // default: distance
}

// picksByTriggerï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ã®é¸æŠï¼‰ã‚’ç´¯ç©ã‹ã‚‰è©•ä¾¡ï¼ˆã‚¼ãƒ­APIï¼‰
function evalByCums(restGroups, picksByTrigger, cumTotals){
  const totalD = Number(cumTotals?.D) || 0;   // m
  const totalT = Number(cumTotals?.T) || 0;   // s
  const totalE = Number(cumTotals?.E) || 0;   // kJ

  // ä¼‘æ†©åˆ†å‰²ã«ã‚ˆã‚‹ã€ŒåŒºåˆ‡ã‚Šã€ã‚’ç´¯ç©è·é›¢ã§ä½œã‚‹
  const cuts = [0];
  (picksByTrigger || []).forEach(p => {
    const v = Number(p?._proj?.cumD);
    if (Number.isFinite(v) && v > 0 && v < totalD) cuts.push(v);
  });
  if (totalD > 0) cuts.push(totalD);

  // åŒºé–“è·é›¢ï¼ˆkmï¼‰
  const dist = [];
  if (cuts.length >= 2){
    cuts.sort((a,b)=>a-b);
    for (let i=1;i<cuts.length;i++){
      const d = (Number(cuts[i]) - Number(cuts[i-1])) / 1000; // km
      if (Number.isFinite(d) && d >= 0) dist.push(d);
    }
  }

  // åŒºé–“æ™‚é–“/ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯è·é›¢æ¯”åˆ†é…ï¼ˆç·é‡ãŒ0ãªã‚‰å‡ç­‰å‰²ï¼‰
  const time = [], energy = [];
  if (dist.length){
    if (totalD > 0 && Number.isFinite(totalD)){
      for (const d of dist){
        const ratio = ((d*1000) / totalD); // 0..1
        time.push((totalT/60) * (Number.isFinite(ratio)? ratio : 0)); // åˆ†
        energy.push(totalE * (Number.isFinite(ratio)? ratio : 0));    // kJ
      }
    } else {
      const eqT = (totalT/60) / dist.length;
      const eqE = (totalE) / dist.length;
      for (let i=0;i<dist.length;i++){ time.push(eqT||0); energy.push(eqE||0); }
    }
  }

  // å®‰å…¨åŒ–
  const finite = a => a.filter(x => Number.isFinite(x));
  const distF = finite(dist), timeF = finite(time), energyF = finite(energy);

  // æ¨™æº–åå·®
  const sd = (a) => {
    if (!a.length) return 0;
    const m = a.reduce((s,v)=>s+v,0) / a.length;
    const v = a.reduce((s,v)=>s+(v-m)*(v-m),0) / a.length;
    return Math.sqrt(v);
  };

  // â˜… å˜ä¸€æŒ‡æ¨™ã‚¹ã‚³ã‚¢ï¼ˆUIã®é¸æŠã«å¾“ã†ï¼‰
  const metric = getScoreMetric();
  const sigmas = { dist: sd(distF), time: sd(timeF), energy: sd(energyF) };
  const score =
      metric === 'time'   ? sigmas.time
    : metric === 'energy' ? sigmas.energy
    :                       sigmas.dist;   // default: distance

  return { stats: { dist: distF, time: timeF, energy: energyF }, score, sigma: sigmas };
}

 /* ===== ã‚¹ã‚³ã‚¢æŒ‡æ¨™ï¼ˆdistance|time|energyï¼‰ ===== */
let SCORE_METRIC = (localStorage.getItem('route_score_metric') || 'distance');


/* ===== ä¼‘æ†©å€™è£œçµ„ã¿åˆã‚ã›æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç¾¤ ===== */
// ç­‰é–“éš”è²ªæ¬² / ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ / DP / ç·å½“ãŸã‚Š ãªã©ã‚’ã“ã“ã«é›†ç´„

/* ===== ç­‰é–“éš”è²ªæ¬²æ³•ï¼ˆä¿®æ­£ç‰ˆï¼‰: å€™è£œãŒã‚ã‚‹å ´åˆã¯å¿…ãšæ¡ç”¨ ===== */
function greedyTopKCandidates(restGroups, cumTotals, K = 3) {
  const R = restGroups.length;
  const groups = [];

  for (let t = 0; t < R; t++) {
    const g = restGroups[t];
    const target = cumTotals.D * (t + 1) / (R + 1); // mï¼ˆè·é›¢åŸºæº–ï¼‰
    let pois = (g && Array.isArray(g.pois)) ? g.pois : [];

    if (!pois.length) {
      groups.push([null]); // ç‰©ç†çš„ã«å€™è£œã‚¼ãƒ­
      continue;
    }
    // â–¼ _proj ãŒç„¡ã„ POI ã«ã¯ã€ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼è·é›¢ã‚’æš«å®šã§å…¥ã‚Œã¦å€™è£œè½ã¡ã‚’é˜²ã
if (g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}
    // --- å°„å½±å€¤ _proj ãŒç„¡ã„å ´åˆã«è£œå®Œ ---
    const needProj = pois.some(p => p && (!p._proj || !Number.isFinite(p._proj.cumD)));
    if (needProj && window.__routeCums) {
      const { cum, coords } = window.__routeCums;
      pois.forEach(p => {
        if (p && (!p._proj || !Number.isFinite(p._proj.cumD))) {
          p._proj = projectToRoute(p.lat, p.lon, coords, cum);
        }
      });
    }

    // --- å°„å½±å€¤ãŒã‚ã‚‹ã‚‚ã®ã‚’å„ªå…ˆ ---
    const withProj = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    let ranked;

    const base = withProj.length ? withProj : pois;
 ranked = base
   .map(p => ({ p, c: nodeCost(p, target) }))
   .sort((a, b) => a.c - b.c)
   .slice(0, K)
   .map(x => x.p);

    // å€™è£œãŒã‚ã‚Œã°å¿…ãšæ¡ç”¨ã€‚ç©ºãªã‚‰ [null]
    groups.push(ranked.length ? ranked : [null]);
  }

  return groups;
}

/* ===== ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆã‚¼ãƒ­APIï¼‰ï¼šå€™è£œã‚ã‚Šã¯å¿…æ¡ç”¨ï¼‹æœªæ¡ç”¨è£œä¿® ===== */
function beamSearch(restGroups, cumTotals, width = 3, minRest = 1, nullPenalty = 1e6, forbidNullWhenCand = true) {
  // beams è¦ç´ : { picks: [...(p or null)], score, pickedCount }
  let beams = [{ picks: [], score: 0, pickedCount: 0 }];

  for (let i = 0; i < restGroups.length; i++){
    const g = restGroups[i];
let pois = (g?.pois || []).slice();

// â–¼ _proj ãŒç„¡ã„/ä¸å®Œå…¨ãª POI ã«ã¯ã€ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã® routeD ã‚’ä½¿ã£ã¦æš«å®šå°„å½±ã‚’ä»˜ä¸
if (pois.length && g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}

// ã“ã“ã‹ã‚‰å…ˆã¯å¾“æ¥ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯
const valid = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
const totalD = Number(cumTotals?.D) || 0;
const target = targetCumDForIndex(i, restGroups.length, totalD);
valid.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));

const cand = valid.length
  ? (forbidNullWhenCand ? valid : [...valid, null])
  : [null];


    const next = [];
    for (const b of beams){
      for (const p of cand){
        const picks = b.picks.concat([p]);

        // ã‚¼ãƒ­APIè¿‘ä¼¼è©•ä¾¡
        const ev = evalByCums(restGroups, picks, cumTotals);
        let s = ev.score;

        // â˜… å€™è£œãŒã‚ã‚‹ã®ã« null ã‚’é¸ã‚“ã å ´åˆã¯å¼·ãƒšãƒŠãƒ«ãƒ†ã‚£
        if (p === null && valid.length){
          s += nullPenalty;
        }

        next.push({
          picks,
          score: Number.isFinite(s) ? s : 0,
          pickedCount: b.pickedCount + (p ? 1 : 0)
        });
      }
    }

    // ã‚¹ã‚³ã‚¢ä¸Šä½ width ä»¶ã®ã¿ä¿æŒ
    next.sort((a,b)=>a.score - b.score);
    beams = next.slice(0, width);
  }

  // â˜… æœ€ä½æ¡ç”¨æ•°ã®åˆ¶ç´„ï¼ˆå€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼åˆ†ã‚’æ¡ç”¨ï¼‰
  let final = beams.filter(b => b.pickedCount >= minRest);
  if (!final.length) final = beams;

  // â˜… æœªæ¡ç”¨(null)ã®â€œè£œä¿®â€ã‚’ã‹ã‘ã¦ã‹ã‚‰æœ€çµ‚ã‚¹ã‚³ã‚¢å†è¨ˆç®—
  final = final.map(b => {
    const fixedPicks = repairNullPicks(restGroups, cumTotals, b.picks);
    const ev = evalByCums(restGroups, fixedPicks, cumTotals);
    return {
      picksByTrigger: fixedPicks,  // â† ä¿®æ­£å¾Œã® picks ã‚’è¿”ã™ï¼ˆä»¥å¾Œã®è¡¨ç¤ºã¯å¿…ãšæ¡ç”¨è¡¨ç¤ºã«ãªã‚‹ï¼‰
      score: ev.score,
      stats: ev.stats
    };
  }).sort((a,b)=>a.score - b.score);

  return final.slice(0, 3);
}

/* ===== DPï¼ˆå±¤ã‚°ãƒ©ãƒ•æœ€çŸ­è·¯ï¼‰ ===== */
// restGroups: [{rest, pois:[p...]}, ...], cumTotals: {D,T,E}
function dpSearch(restGroups, cumTotals){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;

  // å„å±¤ã®å€™è£œï¼ˆ_proj ãŒç„¡ã„ã‚‚ã®ã¯ routeD ã§æš«å®šè£œå®Œï¼‰
  const layers = restGroups.map((g, i) => {
    let pois = (g?.pois || []).slice();
    if (g?.rest && Number.isFinite(g.rest.routeD)) {
      pois.forEach(p => {
        if (!p._proj || !Number.isFinite(p._proj.cumD)) {
          p._proj = { cumD: Number(g.rest.routeD), perpM: Number(p.distFromTriggerM)||0 };
        }
      });
    }
    // ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã™ã‚‹å˜ç‚¹ã‚³ã‚¹ãƒˆï¼ˆä¸¦ã¹æ›¿ãˆã«ã‚‚ä½¿ã†ï¼‰
    const target = targetCumDForIndex(i, R, totalD);
    pois.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));
    return pois;
  });

  // DPãƒ†ãƒ¼ãƒ–ãƒ«
  // dp[i][j] = ç¬¬iå±¤ã§ jç•ªç›®POIã‚’é¸ã‚“ã æ™‚ã®æœ€å°ã‚³ã‚¹ãƒˆ
  // prev[i][j] = ä¸€ã¤å‰ã®å±¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const dp = [], prev = [];
  for (let i=0;i<R;i++) { dp[i] = []; prev[i] = []; }

  // åˆæœŸåŒ–ï¼šã‚¹ã‚¿ãƒ¼ãƒˆâ†’ç¬¬0å±¤ã®å„POIã®ã‚³ã‚¹ãƒˆï¼ˆå˜ç‚¹ã‚³ã‚¹ãƒˆã®ã¿ï¼‰
  const t0 = targetCumDForIndex(0, R, totalD);
  layers[0].forEach((p, j) => {
    dp[0][j] = nodeCost(p, t0);
    prev[0][j] = -1;
  });

  // é·ç§»ï¼šç¬¬i-1å±¤ â†’ ç¬¬iå±¤
  for (let i=1;i<R;i++){
    const ti = targetCumDForIndex(i, R, totalD);
    for (let j=0;j<layers[i].length;j++){
      let best = { cost: Infinity, k: -1 };
      const pj = layers[i][j];

      for (let k=0;k<layers[i-1].length;k++){
        const costPrev = dp[i-1][k];
        if (!Number.isFinite(costPrev)) continue;

        // ã‚¨ãƒƒã‚¸ã‚³ã‚¹ãƒˆï¼ˆåŒºé–“ã®ã€Œç­‰é–“éš”ã‚ºãƒ¬ã€è£œæ­£ã‚’å°‘ã—åŠ ç‚¹ï¼šç´¯ç©è·é›¢ã®å‰å¾Œå·®ãŒç‹­ã™ã/åºƒã™ãã‚’æŠ‘åˆ¶ï¼‰
        const pi = layers[i-1][k];
        const segD = Math.abs((pj?._proj?.cumD||0) - (pi?._proj?.cumD||0)); // m
        const ideal = totalD / (R + 1); // ç†æƒ³åŒºé–“é•·
        const intervalPenalty = Math.abs(segD - ideal) / 1000; // kmå·®åˆ†

        const edge = intervalPenalty * 0.5; // èª¿æ•´ä¿‚æ•°
        const node = nodeCost(pj, ti);

        const cand = costPrev + edge + node;
        if (cand < best.cost){ best = { cost: cand, k }; }
      }
      dp[i][j] = best.cost;
      prev[i][j] = best.k;
    }
  }

  // å¾©å…ƒï¼ˆç¬¬R-1å±¤ã®æœ€å°ã‚³ã‚¹ãƒˆçµ‚ç«¯ã‹ã‚‰è¾¿ã‚‹ï¼‰
  let endJ = -1, bestVal = Infinity;
  for (let j=0;j<layers[R-1].length;j++){
    if (dp[R-1][j] < bestVal){ bestVal = dp[R-1][j]; endJ = j; }
  }
  if (endJ < 0) {
    // ã©ã®å±¤ã«ã‚‚å€™è£œãŒç„¡ã„å ´åˆã®ä¿é™ºï¼šç©ºã§è¿”ã™
    return { picksByTrigger: Array(R).fill(null), stats:{dist:[],time:[],energy:[]}, score: 1e9 };
  }

  const picks = Array(R).fill(null);
  let i = R-1, j = endJ;
  while (i >= 0 && j >= 0){
    picks[i] = layers[i][j];
    j = prev[i][j];
    i--;
  }

  // æ—¢å­˜ã®è¿‘ä¼¼è©•ä¾¡ã§çµ±è¨ˆã‚’ä½œæˆï¼ˆå¯è¦–åŒ–ã®ãŸã‚ï¼‰
  const ev = evalByCums(restGroups, picks, cumTotals);
  return { picksByTrigger: picks, stats: ev.stats, score: ev.score };
}


  
/* ===== è¶…ã‚·ãƒ³ãƒ—ãƒ«ãƒ»ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ© ===== */
// --- PROFILER ã‚’ç„¡åŠ¹åŒ– ---
const PERF = { on:false, rows:[], max:0 };

function perfNow(){ return 0; }
function tStart(name){ return null; }
function tEnd(tok, info){}
function renderPerf(){}
function exportPerfCSV(){}
window.addEventListener('DOMContentLoaded', ()=>{
  const on=$('perfToggle'), reset=$('perfResetBtn'), exp=$('perfExportBtn');
  on && (on.onchange=()=>{ PERF.on = on.checked; });
  reset && (reset.onclick=()=>{ PERF.rows.length=0; renderPerf(); });
  exp && (exp.onclick=exportPerfCSV);
  renderPerf();
});

/* ===== API åˆ©ç”¨ã‚«ã‚¦ãƒ³ã‚¿ ===== */
const API_USED = {
  orsTotal: 0,             // ãƒšãƒ¼ã‚¸å…¨ä½“ã§ã® ORS å‘¼ã³å‡ºã—å›æ•°
  orsAtSolveStart: 0,
  lastSolveOrs: 0,         // ç›´è¿‘ã®ã€Œãƒ«ãƒ¼ãƒˆæ¢ç´¢ã€1å›ã§ä½¿ã£ãŸ ORS å›æ•°

  overpassTotal: 0,        // ãƒšãƒ¼ã‚¸å…¨ä½“ã§ã® Overpass å‘¼ã³å‡ºã—å›æ•°
  overpassAtSolveStart: 0,
  lastSolveOverpass: 0     // ç›´è¿‘ã®ã€Œãƒ«ãƒ¼ãƒˆæ¢ç´¢ã€1å›ã§ä½¿ã£ãŸ Overpass å›æ•°
};

// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚³ãƒ¼ãƒ‰ â†’ è¡¨ç¤ºç”¨ãƒ©ãƒ™ãƒ«
function algoLabel(code){
  switch(code){
    case 'greedy':     return 'ç­‰é–“éš”è²ªæ¬²ï¼ˆã‚¼ãƒ­APIï¼‰';
    case 'beam3':      return 'ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ãƒ»ã‚¼ãƒ­APIï¼‰';
    case 'bruteforce': return 'ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰';
    case 'dp':         return 'DPï¼ˆæœ€çŸ­è·¯ãƒ»ã‚¼ãƒ­APIï¼‰';
    default:           return code;
  }
}

// ç›´è¿‘ã®æ¢ç´¢çµæœã‚’ UI ã«åæ˜ 
function updateAlgoPerfSummary(algoCode){
  const box = $('algoPerfSummary');
  if (!box) return;

  const targetName = `æ¢ç´¢: ${algoCode}`;
  const rows = [...PERF.rows].reverse();
  const row = rows.find(r => r.name === targetName);
  const msText = row ? `${row.ms.toFixed(1)} ms` : 'ä¸æ˜';

  const ors  = API_USED.lastSolveOrs;
  const ovp  = API_USED.lastSolveOverpass;

  box.innerHTML =
    `ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : <b>${algoLabel(algoCode)}</b><br>` +
    `å‡¦ç†æ™‚é–“: <b>${msText}</b><br>` +
    `ã“ã®æ¢ç´¢ã§ä½¿ç”¨ã—ãŸ ORS Directions API: <b>${ors} å›</b><br>` +
    `ã“ã®æ¢ç´¢ã§ä½¿ç”¨ã—ãŸ Overpass API: <b>${ovp} å›</b><br>` +
    `<small style="color:#777">
      â€»å®Ÿéš›ã® API æ®‹ã‚Šã‚¯ã‚©ãƒ¼ã‚¿ã¯ OpenRouteService / Overpass ã®
      ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®šã«ä¾å­˜ã—ã¾ã™ã€‚ã“ã®ãƒ„ãƒ¼ãƒ«ã§ã¯ã€Œã“ã®ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ã‹ã‚‰
      ä½•å›å‘¼ã‚“ã ã‹ã€ã®æ¦‚ç®—ã®ã¿ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚
    </small>`;
}



// â–¼â–¼ ä¼‘æ†©ãƒªã‚¹ãƒˆç”¨å¤‰æ•° â–¼â–¼
let restList = []; // ä¼‘æ†©åœ°ç‚¹ã‚’ä¿å­˜
let restGroups = []; 

const ICON = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
const ICONS = {start:ICON('green'),via:ICON('blue'),goal:ICON('red')};

const OVERPASS_MIN_INTERVAL = 1800; // 1.8sï¼ˆå¿…è¦ãªã‚‰ 2000ï½2500 ã¾ã§ä¸Šã’ã¦OKï¼‰
let __overpassLastTs = 0;
const __overpassCache = new Map();  // key=queryæ–‡å­—åˆ—, value=JSON

function formatDist(m){return (m/1000).toFixed(2)+' km';}
function formatDur(s){const m=Math.round(s/60);return m<60? m+' åˆ†' : (Math.floor(m/60)+' æ™‚é–“ '+(m%60)+' åˆ†');}

/* ====== åˆæœŸåŒ– ====== */
window.addEventListener('DOMContentLoaded',()=>{
    const btnCmp = $('btnAlgoCompare');
  if (btnCmp) {
    btnCmp.onclick = runAlgoCompareDebug;
  }
  // â–¼ Excelç”¨CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ç´ä»˜ã‘
  const csvBtn = $('dbgAlgoCsv');
  if (csvBtn) {
    csvBtn.onclick = downloadAlgoCompareCsv;
  }
    // â–¼ ç·å½“ãŸã‚Š å…¨çµ„ã¿åˆã‚ã› CSV ãƒœã‚¿ãƒ³ã®ç´ä»˜ã‘
  const bfCsvBtn = $('btnDownloadBruteforceCsv');
  if (bfCsvBtn) {
    bfCsvBtn.onclick = downloadBruteforceCsv;
  }

  /* ===== è©•ä¾¡ã‚¦ã‚§ã‚¤ãƒˆ UI åˆæœŸåŒ– ===== */
  function reflectWeightsToInputs(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    if(!WA || !WP || !WT) return;
    WA.value = String(SCORE_WEIGHTS.wAlign);
    WP.value = String(SCORE_WEIGHTS.wPerp);
    WT.value = String(SCORE_WEIGHTS.wTrig);
  }

  // â–¼ ã‚¹ã‚³ã‚¢æŒ‡æ¨™ã‚»ãƒ¬ã‚¯ã‚¿ã®åˆæœŸåŒ–
const sm = document.getElementById('scoreMetricSelect');
if (sm) {
  sm.value = SCORE_METRIC;             // ä¿å­˜æ¸ˆã¿ã®é¸æŠã‚’åæ˜ 
  sm.addEventListener('change', ()=>{  // å¤‰æ›´æ™‚ã«ä¿å­˜
    setScoreMetric(sm.value);
    // â€»å¿…è¦ãªã‚‰ç›´è¿‘çµæœã®å†è¡¨ç¤ºã‚’å‘¼ã¶ï¼ˆä¾‹ï¼šæœ€å¾Œã®ãƒˆãƒƒãƒ—3ã‚’ä½œã‚Šç›´ã™ç­‰ï¼‰
  });
}


  function saveWeights(){
    localStorage.setItem('route_score_weights', JSON.stringify(SCORE_WEIGHTS));
  }

  function bindWeightsUI(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    const RB = document.getElementById('btnWeightsReset');

    if(WA){
      WA.addEventListener('input', ()=>{
        const v = Number(WA.value);
        SCORE_WEIGHTS.wAlign = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WP){
      WP.addEventListener('input', ()=>{
        const v = Number(WP.value);
        SCORE_WEIGHTS.wPerp = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WT){
      WT.addEventListener('input', ()=>{
        const v = Number(WT.value);
        SCORE_WEIGHTS.wTrig = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(RB){
      RB.addEventListener('click', ()=>{
        SCORE_WEIGHTS = { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
        saveWeights();
        reflectWeightsToInputs();
      });
    }
  }

  // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åæ˜ ï¼†ãƒã‚¤ãƒ³ãƒ‰
  reflectWeightsToInputs();
  bindWeightsUI();

  
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {attribution:'Â©OpenStreetMap'}).addTo(map);
  restBeamLayer = L.layerGroup().addTo(map);

  // æ¤œç´¢ãƒœã‚¿ãƒ³ï¼šæ¤œç´¢å¾Œã«å…¥åŠ›æ¬„ã‚¯ãƒªã‚¢
  $('searchBtn').onclick = () => {
    const val = $('placeInput').value.trim();
    if (!val) return;
    nomSearch(val);
    $('placeInput').value = ''; // å…¥åŠ›æ¬„ãƒªã‚»ãƒƒãƒˆ
  };
  $('drawBtn').onclick=drawRoutes;

  $('solveCombBtn').onclick = async () => {
     const algoCode = $('algoSelect').value;                // ã©ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‹
  const tkSolveAll = tStart(`æ¢ç´¢: ${algoCode}`);        // å…¨ä½“è¨ˆæ¸¬é–‹å§‹

  // â˜…ã“ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã® API ç´¯è¨ˆå€¤ã‚’è¨˜éŒ²ï¼ˆå·®åˆ†ã‚’è¦‹ã‚‹ãŸã‚ï¼‰
  const prevOrs = API_USED.orsTotal;
  const prevOv  = API_USED.overpassTotal;
  try {
    // 0) å‰æãƒã‚§ãƒƒã‚¯
    if (!routeData.fastest){
      alert('å…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    if (!Array.isArray(restGroups) || !restGroups.length){
      alert('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    if (poiGroups.every(a => !a.length)){
      alert('å„ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã«POIãŒã‚ã‚Šã¾ã›ã‚“ã€‚POIè¨­å®šï¼ˆã‚«ãƒ†ã‚´ãƒª/åŠå¾„/ä»¶æ•°ï¼‰ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    ensureProjections();
    injectAlgoDebugButtons(window.__cumTotals);

    // 1) å…¥åŠ›ï¼†å…±æœ‰ãƒ‡ãƒ¼ã‚¿å–å¾—
    const algo = $('algoSelect').value; // 'greedy' | 'beam3' | 'bruteforce'
    const start = pts.find(p=>p.type==='start') || pts[0];
    const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
    if (!start || !goal){
      alert('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }
    const cumTotals = window.__cumTotals; // drawRoutes() å®Ÿè¡Œå¾Œã« buildCums() ã§è¨­å®šæ¸ˆã¿ã®ç´¯ç©ç·é‡

   // 2) ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ åˆ†å²ï¼ˆâ˜… è¨ˆæ¸¬ãƒ•ãƒƒã‚¯è¿½åŠ ç‰ˆï¼‰
if (algo === 'greedy'){
  const tkG = tStart('æ¢ç´¢: ç­‰é–“éš”è²ªæ¬²');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    // ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¿‘ã„ã€Œä¸Šä½Kå€™è£œã€ã‚’å„ãƒˆãƒªã‚¬ãƒ¼ã‹ã‚‰é›†ã‚ã‚‹
    const K = 3; // ã“ã“ã‚’2ï½5ã§èª¿æ•´å¯
    const candGroups = greedyTopKCandidates(restGroups, cumTotals, K);

    // ç›´ç©ï¼ˆä¸Šé™ã‚’ã‹ã‘ã¦æš´èµ°é˜²æ­¢ï¼‰
    const combos = enumerateCombinations(candGroups, /*perGroupLimit=*/K, /*hardCap=*/60);
    if (!combos.length){
      alert('çµ„ã¿åˆã‚ã›å€™è£œãŒä½œã‚Œã¾ã›ã‚“ã§ã—ãŸï¼ˆå€™è£œä¸è¶³ï¼‰ã€‚');
      return;
    }

    // å…¨å€™è£œã‚’ã€Œç´¯ç©å·®åˆ†ã®è¿‘ä¼¼è©•ä¾¡ã€ã§æ¡ç‚¹ï¼ˆã‚¼ãƒ­APIï¼‰
    const scored = combos.map(cmb => {
      const picksByTrigger = cmb; // nullå«ã‚€ï¼ˆæœªæ¡ç”¨ã‚‚è¨±å®¹ï¼‰
      const ev = evalByCums(restGroups, picksByTrigger, cumTotals); // dist/time/energy ã®Ïƒåˆè¨ˆã§ã‚¹ã‚³ã‚¢
      return {
        score: ev.score,
        stats: ev.stats,
        picksByTrigger,
        picks: picksByTrigger.filter(Boolean)
      };
    });

    // ã‚¹ã‚³ã‚¢æ˜‡é †ã§ä¸Šä½3ä»¶ã‚’è¡¨ç¤º
    scored.sort((a,b)=>a.score-b.score);
    showTop3Combos(scored.slice(0,3));
  } finally {
    // info ã«ã¯ã€Œãƒˆãƒªã‚¬ãƒ¼æ•°ã€ã€Œå€™è£œã®ç·æ•°ã€ã€Œè©¦ã—ãŸã‚³ãƒ³ãƒœæ•°ã€ã‚’å…¥ã‚Œã‚‹ã¨è¦‹ã‚„ã™ã„
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkG, `R=${R}, cand=${totalCand}`);
  }
  return;
}

if (algo === 'beam3'){
  const tkB = tStart('æ¢ç´¢: ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒ');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    // ã€Œå€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼æ•°ã€ã¯å¿…ãšæ¡ç”¨ã™ã‚‹
    const triggersWithCand = (restGroups || []).reduce((n, g) => {
      const valid = (g?.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
      return n + (valid.length ? 1 : 0);
    }, 0);

    const width = 3; // ãƒ“ãƒ¼ãƒ å¹…
    const top = beamSearch(restGroups, cumTotals, /*width*/width, /*minRest*/triggersWithCand, /*nullPenalty*/1e6, /*forbidNullWhenCand*/true);
    top.forEach(t => t.picks = t.picksByTrigger.filter(Boolean));
    showTop3Combos(top);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkB, `R=${R}, cand=${totalCand}, width=3`);
  }
  return;
}

if (algo === 'bruteforce'){
  const tkBF = tStart('æ¢ç´¢: ç·å½“ãŸã‚Š');  // â† è¨ˆæ¸¬é–‹å§‹ï¼ˆå…¨ä½“ï¼‰
  try {
    // --- ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰---
    //const perGroupLimit = Math.max(1, Math.min(3, Number($('poiLimit').value)||3)); // å„ãƒˆãƒªã‚¬ãƒ¼æœ€å¤§ä»¶æ•°
    const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    const combos = enumerateCombinations(poiGroups, perGroupLimit, 60);             // ç·å½“ãŸã‚Šä¸Šé™60é€šã‚Š
    if (!combos.length){
      alert('çµ„ã¿åˆã‚ã›å€™è£œãŒä½œã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚');
      return;
    }

    const profile = 'cycling-road'; // ORSãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆcycling-road ç­‰ï¼‰
    const results = [];

    // é€æ¬¡ã§APIè² è·ã‚’æŠ‘ãˆã¤ã¤è©•ä¾¡
    let okCount = 0, failCount = 0;
    for (const cmb of combos){
      const picks = cmb.filter(Boolean); // nullé™¤å¤–
      const wps = [start, ...picks, goal].map(p=>({
        lat: p.lat, lon: p.lon, name: p.name || 'POI'
      }));

      // ï¼ˆä»»æ„ï¼‰1ã‚³ãƒ³ãƒœæ¯ã®è¨ˆæ¸¬ãŒæ¬²ã—ã„ãªã‚‰ã€ã“ã“ã§é–‹å§‹
      const tkOne = tStart('ç·å½“ãŸã‚Š: 1ã‚³ãƒ³ãƒœ');

      try {
        const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);
        const rawScore = comboScore(stats); // è·é›¢/æ™‚é–“/ã‚¨ãƒã®æ¨™æº–åå·®ã®åˆè¨ˆ
        const weights  = picks.map(p => Number(p?._w) || 1);
        const meanW    = weights.length ? (weights.reduce((a,b)=>a+b,0)/weights.length) : 1;
        const score    = rawScore / Math.max(0.1, meanW); // é‡ã¿ãŒé«˜ã„çµ„åˆã›ã‚’å„ªé‡
        results.push({ score, rawScore, feature, picks, picksByTrigger: cmb, stats });
        okCount++;
      } catch(e){
        console.warn('combo route fail', e);
        failCount++;
        // å¤±æ•—ã—ãŸçµ„åˆã›ã¯ã‚¹ã‚­ãƒƒãƒ—
      } finally {
        // 1ã‚³ãƒ³ãƒœã®çµŒéæ™‚é–“ã‚’æ®‹ã—ãŸã„å ´åˆï¼ˆãƒ­ã‚°ãŒå¤šã„ã¨æ„Ÿã˜ãŸã‚‰å¤–ã—ã¦OKï¼‰
        //tEnd(tone, `ok=${okCount}, fail=${failCount}`);
      }
    }

    // ã‚¹ã‚³ã‚¢æ˜‡é †ã«ä¸Šä½3ä»¶
    results.sort((a,b)=>a.score-b.score);
    showTop3Combos(results.slice(0,3));
    // â˜… è¿½åŠ ï¼šç·å½“ãŸã‚Šã®å…¨çµ„ã¿åˆã‚ã›ã‚’ä¿å­˜ï¼†ä¸€è¦§è¡¨ç¤º
    window.__bruteforceAllResults = results;
    renderBruteforceAllResults(results);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkBF, `R=${R}, cand=${totalCand}, cap=60`);
  }
  return;
}

if (algo === 'dp'){
  const tkDP = tStart('æ¢ç´¢: DP');  // â† è¨ˆæ¸¬é–‹å§‹
  try {
    const best = dpSearch(restGroups, cumTotals);
    best.picks = best.picksByTrigger.filter(Boolean);
    showTop3Combos([best]);  // DPã¯æœ€é©è§£1æœ¬ã‚’å‡ºã™
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkDP, `R=${R}, cand=${totalCand}`);
  }
  return;
}


    // æœªçŸ¥ã®å€¤ï¼ˆä¿é™ºï¼‰
    alert('æœªçŸ¥ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æŒ‡å®šã§ã™ã€‚');
    } catch (err){
    console.error(err);
    alert('ãƒ«ãƒ¼ãƒˆæ¢ç´¢ã§ã‚¨ãƒ©ãƒ¼: ' + (err.message || err));
  } finally {
    // â˜…ä»Šå›ã®æ¢ç´¢ã§ä½¿ã£ãŸ API å›æ•°ï¼ˆå·®åˆ†ï¼‰ã‚’è¨˜éŒ²
    API_USED.lastSolveOrs      = API_USED.orsTotal      - prevOrs;
    API_USED.lastSolveOverpass = API_USED.overpassTotal - prevOv;

    // è¨ˆæ¸¬çµ‚äº†ï¼ˆPERF ã«è¨˜éŒ²ï¼‰
    tEnd(tkSolveAll);

    // UI ã«åæ˜ 
    updateAlgoPerfSummary(algoCode);
  }
};


  new Sortable($('pointList'),{
    animation:150,
    onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li.dataset.idx]);fixType();drawList();}
  });
});

/* ====== åœ°ç‚¹ç®¡ç† ====== */
function addPoint(p){
  p.type=pts.length?'':'start';
  pts.forEach(d=>{if(d.type==='goal')d.type='via';});
  pts.push(p);
  if(pts.length>1) pts[pts.length-1].type='goal';
  drawList();
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li.dataset.idx=i;
    const name = p.name + (p.isRest? 'ï¼ˆä¼‘æ†©ï¼‰':'');
    li.innerHTML = `<span>${name}${p.isRest? ' <small>(' + p.lat.toFixed(5)+','+p.lon.toFixed(5)+')</small>':''}</span><button class="del">Ã—</button>`;
    li.querySelector('.del').onclick=()=>{pts.splice(i,1); fixType(); drawList();};
    ul.appendChild(li);
  });
}

/* ====== æ¤œç´¢å‡¦ç†ï¼ˆå€™è£œè¡¨ç¤ºå¯¾å¿œç‰ˆï¼‰ ====== */
async function nomSearch(q){
  const url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  const arr=await (await fetch(url)).json();
  const sug=$('searchSuggestions');
  sug.innerHTML='';
  if(!arr.length){alert('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');return;}
  // å€™è£œã‚’ãƒªã‚¹ãƒˆè¡¨ç¤º
  arr.forEach(o=>{
    const li=document.createElement('li');
    li.textContent=o.display_name;
    li.style.cursor='pointer';
    li.style.padding='4px';
    li.onmouseenter=()=>li.style.background='#eee';
    li.onmouseleave=()=>li.style.background='';
    li.onclick=()=>{
      addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
      sug.innerHTML=''; // ã‚¯ãƒªãƒƒã‚¯å¾Œã‚¯ãƒªã‚¢
      $('placeInput').value='';
    };
    sug.appendChild(li);
  });
}


/* ====== ORS ====== */
/* ====== ORS API å‘¼ã³å‡ºã—ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ãƒ»ã‚¨ãƒ©ãƒ¼è©³ç´°åŒ–ç‰ˆï¼‰ ====== */

// â˜…å¤‰æ›´ç‚¹1: å¾…æ©Ÿæ™‚é–“ã‚’ 1100ms -> 2500ms (2.5ç§’) ã«å¤‰æ›´
// ç„¡æ–™æ ã¯ã€Œ1åˆ†é–“ã«40å›ã€ãªã®ã§ã€1å›ã‚ãŸã‚Šæœ€ä½1.5ç§’ã¯å¿…è¦ã€‚ä½™è£•ã‚’æŒã£ã¦2.5ç§’ã«ã—ã¾ã™ã€‚
const ORS_INTERVAL = 2500; 

async function dir(body, profile) {
  // ç¾åœ¨æ™‚åˆ»ã¨å‰å›ã®å·®åˆ†ã‚’è¨ˆç®—
  const now = Date.now();
  const elapsed = now - lastDirTs;
  const wait = ORS_INTERVAL - elapsed;

  // ã¾ã æ™‚é–“ãŒçµŒã£ã¦ã„ãªã‘ã‚Œã°å¾…æ©Ÿ
  if (wait > 0) {
    await new Promise(r => setTimeout(r, wait));
  }

  // â˜… ORS å‘¼ã³å‡ºã—å›æ•°ã‚«ã‚¦ãƒ³ãƒˆ
  if (typeof API_USED !== 'undefined') {
    API_USED.orsTotal++;
  }

  try {
    const d = await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`, body);
    // æˆåŠŸã—ãŸã‚‰æ™‚åˆ»ã‚’æ›´æ–°
    lastDirTs = Date.now();
    return d;
  } catch (e) {
    // ã‚¨ãƒ©ãƒ¼ã§ã‚‚æ™‚åˆ»æ›´æ–°ï¼ˆé€£ç¶šãƒªãƒˆãƒ©ã‚¤ã«ã‚ˆã‚‹ãƒ‘ãƒ³ã‚¯ã‚’é˜²ããŸã‚ï¼‰
    lastDirTs = Date.now();
    throw e;
  }
}

/* ==============================================
   ã€ä¿®æ­£ç‰ˆã€‘APIå‘¼ã³å‡ºã—é–¢æ•°ï¼ˆé‡è¤‡ã‚¨ãƒ©ãƒ¼å¯¾ç­–æ¸ˆã¿ï¼‰
   ============================================== */
async function post(url, body) {
  const MAX_RETRIES = 5; // æœ€å¤§5å›ã¾ã§å†æŒ‘æˆ¦
  let delay = 5000;      // åˆå›ã¯5ç§’å¾…ã¤

  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      const r = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': ORS_KEY
        },
        body: JSON.stringify(body)
      });

      // æˆåŠŸ (200 OK) ãªã‚‰çµæœã‚’è¿”ã—ã¦çµ‚äº†
      if (r.ok) {
        return await r.json();
      }

      // 429 (Too Many Requests) ã®å ´åˆ -> å¾…æ©Ÿã—ã¦ãƒªãƒˆãƒ©ã‚¤
      if (r.status === 429) {
        console.warn(`[API] 429 Rate Limit detected. Waiting ${delay/1000}s... (Retry ${i+1}/${MAX_RETRIES})`);
        // æ—¢å­˜ã® sleep é–¢æ•°ã‚’ä½¿ã„ã¾ã™
        await sleep(delay);
        delay *= 2; // å¾…æ©Ÿæ™‚é–“ã‚’å€ã«å¢—ã‚„ã™ (5s -> 10s -> 20s...)
        continue;   // ãƒ«ãƒ¼ãƒ—ã®å…ˆé ­ã«æˆ»ã£ã¦ã‚„ã‚Šç›´ã™
      }

      // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼ (403:1æ—¥ã®ä¸Šé™è¶…é, 500:ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãªã©) -> å³åº§ã«ã‚¨ãƒ©ãƒ¼ã«ã—ã¦æ­¢ã‚ã‚‹
      let errorMsg = `Error ${r.status}`;
      if (r.status === 403) {
        errorMsg += ': APIã‚­ãƒ¼ã®ç„¡åŠ¹åŒ–ã€ã¾ãŸã¯1æ—¥ã®åˆ©ç”¨ä¸Šé™(2000å›)ã‚’è¶…éã—ã¾ã—ãŸã€‚ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
      } else {
        try {
          const txt = await r.text();
          errorMsg += `: ${txt}`;
        } catch (e) {}
      }
      throw new Error(errorMsg);

    } catch (e) {
      // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ç­‰ã§fetchè‡ªä½“ãŒå¤±æ•—ã—ãŸå ´åˆã‚‚ãƒªãƒˆãƒ©ã‚¤å¯¾è±¡ã«ã™ã‚‹
      // ãŸã ã—ã€æ˜ç¤ºçš„ã«throwã—ãŸ403ã‚¨ãƒ©ãƒ¼ãªã©ã¯å†é€ã—ãªã„
      if (e.message.includes('Error 403')) {
        throw e;
      }
      
      console.warn(`[API] Network or Fetch error. Waiting ${delay/1000}s...`, e);
      // æ—¢å­˜ã® sleep é–¢æ•°ã‚’ä½¿ã„ã¾ã™
      await sleep(delay);
      delay *= 2;
    }
  }

  throw new Error(`API Retry limit exceeded after ${MAX_RETRIES} attempts.`);
}

// async function post(url, body) {
//   const r = await fetch(url, {
//     method: 'POST',
//     headers: {
//       'Content-Type': 'application/json',
//       'Authorization': ORS_KEY
//     },
//     body: JSON.stringify(body)
//   });

//   // â˜…å¤‰æ›´ç‚¹2: ã‚¨ãƒ©ãƒ¼æ™‚ã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã ã‘ã§ãªãã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚èª­ã¿å–ã‚‹
//   if (!r.ok) {
//     let errorMsg = `Error ${r.status}`;
//     try {
//       // ã‚µãƒ¼ãƒãƒ¼ãŒè¿”ã™è©³ç´°ãªã‚¨ãƒ©ãƒ¼æ–‡ï¼ˆ"Rate limit exceeded"ç­‰ï¼‰ã‚’å–å¾—
//       const txt = await r.text();
//       errorMsg += `: ${txt}`;
//     } catch (e) {
//       // textå–å¾—å¤±æ•—æ™‚ã¯ç„¡è¦–
//     }
//     // CORSã‚¨ãƒ©ãƒ¼ã‚„429ã‚¨ãƒ©ãƒ¼ã®å†…å®¹ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§è¦‹ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
//     throw new Error(errorMsg);
//   }

//   return r.json();
// }


/* ====== ãƒ«ãƒ¼ãƒˆè¡¨ç¤ºé–¢é€£ ====== */
function clearRouteLayers(){
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); });
  routeLayers={};
}
function setActiveButton(btn){
  document.querySelectorAll('#routeButtons button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
}
function showSingleRoute(type, noFit){
  clearRouteLayers();
  const colorMap = { shortest:'#ff0000', fastest:'#0066ff', slope:'#ff9900', arterial:'#00b26b' };
  const f = routeData[type];
  if(!f){ alert('ã¾ã è¨ˆç®—ã—ã¦ã„ã¾ã›ã‚“'); return; }
  routeLayers[type] = L.geoJSON(f, { style:{ color: colorMap[type], weight: 6 } }).addTo(map);
  if(!noFit) map.fitBounds(routeLayers[type].getBounds().pad(0.1));
}
function toggleSingleRoute(type, btn){
  showSingleRoute(type);
  setActiveButton(btn);
}

/* ====== ãƒ«ãƒ¼ãƒˆè¨ˆç®—ãƒ»ä¼‘æ†©ãƒ»POI ====== */
async function drawRoutes(){
  if(pts.length<2){alert('2åœ°ç‚¹ä»¥ä¸Šç™»éŒ²ã—ã¦ãã ã•ã„');return;}

  clearRouteLayers();
  if(markerLayer) map.removeLayer(markerLayer);

  markerLayer=L.layerGroup().addTo(map);
  
  pts.forEach(p=>markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ICONS[p.type||'via']}).bindTooltip(p.name)));

  const coords=pts.map(p=>[p.lon,p.lat]);
  const profile = 'cycling-road';
  const base={coordinates:coords,elevation:true,extra_info:['steepness']};

  try{
    const tkORS = tStart('ORS: æœ€çŸ­/æœ€é€Ÿ');
    const shortest = await dir({...base, preference:'shortest'}, profile);
    const fastest  = await dir({...base, preference:'fastest'},  profile);
    tEnd(tkORS, `pts=${pts.length}`);


    let slope = shortest.features[0];
    let arterial = fastest.features[0];
    if(coords.length===2){
      const tkAlt = tStart('ORS: ä»£æ›¿çµŒè·¯');
      const alt = await dir({...base, preference:'shortest',
        alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}, profile);
      tEnd(tkAlt, `alts=${(alt.features||[]).length}`);

      const feats = alt.features || [];
      if(feats.length){
        function steepSum(f){
          const vals=((f.properties||{}).extras||{}).steepness?.values||[];
          let s=0; for(const v of vals){ s+=Math.abs(v[2]||0); }
          return s;
        }
        slope = feats.reduce((a,b)=> steepSum(a)<steepSum(b)?a:b);
        // å¹¹ç·šå„ªå…ˆï¼ˆä»£æ›¿çµŒè·¯ï¼‹fastest ã®ä¸­ã‹ã‚‰ã‚¹ã‚³ã‚¢æœ€å¤§ï¼‰
        arterial = feats.concat(fastest.features || [])
        .reduce((best,cand)=> arterialScore(cand) > arterialScore(best) ? cand : best, arterial);
      }
    }

    routeData.shortest = shortest.features[0];
    routeData.fastest  = fastest.features[0];
    routeData.slope    = slope;
    routeData.arterial = arterial;

    const s1 = routeData.shortest.properties.summary;
    const s2 = routeData.fastest.properties.summary;
    const s3 = routeData.slope.properties.summary;
    $('routeInfo').innerHTML =
      `<b>æœ€çŸ­</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>æœ€é€Ÿ</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>å‹¾é…</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}<br>`+
      (routeData.arterial ? `<b>å¹¹ç·š</b> ${formatDist(routeData.arterial.properties.summary.distance)} / ${formatDur(routeData.arterial.properties.summary.duration)}` : '');
    $('distanceScore').textContent = 'è·é›¢å·®ï¼ˆæœ€é€Ÿ-æœ€çŸ­ï¼‰: '+(s2.distance - s1.distance).toFixed(0)+' m';

    /* ===== ä¼‘æ†©åœ°ç‚¹æŒ¿å…¥ ===== */
    const mass = 75; // ä½“é‡+ãƒã‚¤ã‚¯è³ªé‡(ä¾‹)
    const flat = 18; // å¹³å¦ä¿‚æ•°
    const baseFeature = routeData.arterial || routeData.fastest;
    const tkRest = tStart('ä¼‘æ†©ãƒˆãƒªã‚¬ç”Ÿæˆ');
    const rests = await makeRestPoints(baseFeature, mass, flat);
    tEnd(tkRest, `hits=${rests.length}`);


    restGroups = (rests || []).map(r => ({ rest: r, pois: [] }));

    restList = []; // å‰å›ã®ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ

    if (rests.length) {
      // ãƒªã‚¹ãƒˆã«æŒ¿å…¥ï¼ˆã‚´ãƒ¼ãƒ«ç›´å‰ï¼‰
      rests.forEach(r => {
        pts.splice(pts.length-1, 0,
                  { name:'ä¼‘æ†©', lat:r.lat, lon:r.lon, type:'via', isRest:true });
        // â–¼ r ãŒæœ‰åŠ¹ãªã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ push
        restList.push({distance:(r.routeD/1000).toFixed(2), lat:r.lat, lon:r.lon});
      });
      drawList();
      updateRestListPanel(); // ä¼‘æ†©åœ°ç‚¹ãƒªã‚¹ãƒˆè¡¨ç¤ºæ›´æ–°

      // ä¼‘æ†©ãƒãƒ¼ã‚«ãƒ¼
      for (const r of rests) {
        L.marker([r.lat, r.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/yellow-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        }).bindTooltip('ä¼‘æ†©').addTo(markerLayer);
      }

      // POIæ¤œç´¢ï¼ˆåŠå¾„å›ºå®šãƒ»è¿‘ã„é †ã« n ä»¶ï¼‰
      if ($('poiToggle').checked) {
        const baseRadius = Number($('poiRadius').value) || 500;
        const limit = Math.max(1, Number($('poiLimit').value) || 5);
        // â˜… ã“ã“ã§ä»Šå›ã®ä¼‘æ†©å ´æ‰€æ¤œç´¢é–‹å§‹æ™‚ç‚¹ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨˜éŒ²
        const overpassBefore = OVERPASS_CALL_TOTAL;

        for (let idx = 0; idx < rests.length; idx++) {
          const r = rests[idx];
          
          // â˜…â˜…â˜… è¿½åŠ å¯¾ç­–ï¼šå‰ã®æ¤œç´¢ã‹ã‚‰å¿…ãš3ç§’ç©ºã‘ã‚‹ï¼ˆOverpassè² è·è»½æ¸›ï¼‰ â˜…â˜…â˜…
          if (idx > 0) {
             await new Promise(res => setTimeout(res, 3000));
          }

          try {
            const tkPOI = tStart(`POI#${idx+1}`);
            const pois = await fetchPoisAround(r.lat, r.lon, baseRadius, limit);
            tEnd(tkPOI, `found=${pois.length}`);

            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: åŠå¾„${baseRadius}m â†’ ${pois.length}ä»¶ï¼ˆè¿‘ã„é †ï¼‰`);

            // â–¼ è¿½åŠ ï¼šã“ã®ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã®POIã‚’ä¿å­˜
            if (restGroups[idx]) {
              restGroups[idx].pois = pois.map(p => ({ ...p, triggerIndex: idx }));
            }
              
            // æ—¢å­˜ï¼šãƒãƒƒãƒ—ã«æç”»
            pois.forEach(po => {
              L.marker([po.lat, po.lon], {
                icon: new L.Icon({
                  iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple.png',
                  iconSize: [24, 24],
                  iconAnchor: [12, 24]
                })
              }).bindTooltip(`${po.name}${typeof po.distFromTriggerM === 'number' ? ` (${formatDist(po.distFromTriggerM)})` : ''}`).addTo(markerLayer);
            });
          } catch (e) {
            logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: å–å¾—å¤±æ•—`);
          }
        }

        //ãƒ‘ãƒãƒ«ã¸åæ˜ 
        ensureProjections();
        updateRestPoiPanel();
        // â˜… ã“ã“ã§ä»Šå›ä½¿ã£ãŸå›æ•°ã¨ç´¯è¨ˆã‚’ã€Œæœ€å¾Œã®è¡Œã€ã¨ã—ã¦å‡ºã™
        const usedThisTime = OVERPASS_CALL_TOTAL - overpassBefore;
        logRest(`--- Overpass API å‘¼ã³å‡ºã—: ä»Šå› ${usedThisTime} å› / ç´¯è¨ˆ ${OVERPASS_CALL_TOTAL} å› ---`);
      }

    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºã¯å¹¹ç·šå„ªå…ˆï¼ˆãªã‘ã‚Œã°æœ€é€Ÿï¼‰
    const prefer = routeData.arterial ? 'arterial' : 'fastest';
    showSingleRoute(prefer, true);
    setActiveButton(prefer === 'arterial' ? $('btnShowArterial') : $('btnShowFastest'));

  }catch(e){
    console.error(e);
    alert('ãƒ«ãƒ¼ãƒˆå–å¾—å¤±æ•—: '+e.message);
  }
}

/* ===== ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼é–¢é€£ ===== */
function logRest(msg){ $('restDebug').textContent += msg + "\n"; }
function energyStepKJ(dist,dz,mass,flat=18){
  return flat*(dist/1000)+Math.max(dz,0)*mass*9.80665/1000;
}
async function totalEnergyKJ(feature,mass,flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments||[];
  let tot=0;
  for(const s of segs){
    for(const st of s.steps||[]){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz = coords[i1].length>=3 ? (coords[i1][2]-coords[i0][2]) : 0;
      tot += energyStepKJ(d,dz,mass,flat);
    }
  }
  return tot;
}
async function makeRestPoints(feature,mass,flat){
  const coords=feature.geometry.coordinates;
  const segs=(feature.properties.segments||[]);
    // æ—…å…¨ä½“ã®åˆè¨ˆï¼ˆè·é›¢ã¯æ—¢å­˜ã® totalDist ä»£ã‚ã‚Šã« summary.distance ã‚’åˆ©ç”¨ï¼‰
  const totalD = feature?.properties?.summary?.distance || 0;        // m
  const totalT = feature?.properties?.summary?.duration || 0;        // s
  const totalE = await totalEnergyKJ(feature, mass, flat);           // kJ

    // â–¼â–¼ è¿½åŠ ï¼šå…¨ãƒˆãƒªã‚¬å…±é€šã®ã€Œã‚¹ã‚­ãƒƒãƒ—åˆ¤å®š & pushã€ãƒ˜ãƒ«ãƒ‘ â–¼â–¼
  function getSkipUI() {
    const skipGoalOn  = document.getElementById('skipNearGoalToggle')?.checked ?? false;
    const skipNodeOn  = document.getElementById('skipNearNodeToggle')?.checked ?? false;
    const skipGoalKmV = Number(document.getElementById('skipNearGoalKm')?.value);
    const skipNodeMV  = Number(document.getElementById('skipNearNodeM')?.value);
    return {
      skipGoalOn,
      skipNodeOn,
      skipGoalKm: (Number.isFinite(skipGoalKmV) && skipGoalKmV >= 0) ? skipGoalKmV : 0,
      skipNodeM : (Number.isFinite(skipNodeMV)  && skipNodeMV  >= 0) ? skipNodeMV  : 0
    };
  }

  function nearExistingNode(lat, lon, skipNodeM) {
    if (!Array.isArray(pts) || !pts.length || !skipNodeM) return false;
    const P = L.latLng(lat, lon);
    return pts.some(p => {
      if (!p || p.isRest) return false; // è‡ªå‹•æŒ¿å…¥ã®ä¼‘æ†©ç‚¹ã¯é™¤å¤–
      const Q = L.latLng(p.lat, p.lon);
      return P.distanceTo(Q) <= skipNodeM;
    });
  }

  /**
   * å…±é€špushé–¢æ•°ï¼š
   *  - hereCumMï¼šå€™è£œã®ç´¯ç©è·é›¢[m]
   *  - lat, lonï¼šå€™è£œã®ç·¯åº¦çµŒåº¦
   *  - label   ï¼šãƒ­ã‚°ç”¨ "[ACCUM] / [STAT] / [PERCENT]" ãªã©
   *  - progTsec, progEkJï¼šãã®æ™‚ç‚¹ã¾ã§ã®ç´¯ç©ï¼ˆä¸æ˜ãªã‚‰çœç•¥â†’è·é›¢æ¯”ã§è¿‘ä¼¼ï¼‰
   */
  function pushIfNotSkipped(raw, hereCumM, lat, lon, label, progTsec, progEkJ) {
    const { skipGoalOn, skipNodeOn, skipGoalKm, skipNodeM } = getSkipUI();

    // æ®‹é‡è¨ˆç®—ï¼ˆç´¯ç©ãŒæœªæŒ‡å®šãªã‚‰è·é›¢æ¯”ã§è¿‘ä¼¼ï¼‰
    const remainD = Math.max(0, (totalD || 0) - (hereCumM || 0)); // m
    let usedT = progTsec, usedE = progEkJ;
    if (!Number.isFinite(usedT) || !Number.isFinite(usedE)) {
      const ratio = (Number.isFinite(totalD) && totalD > 0) ? (hereCumM / totalD) : 0;
      usedT = (totalT || 0) * ratio;
      usedE = (totalE || 0) * ratio;
    }
    const remainT = Math.max(0, (totalT || 0) - (usedT || 0)); // s
    const remainE = Math.max(0, (totalE || 0) - (usedE || 0)); // kJ

    // 1) ã‚´ãƒ¼ãƒ«æ‰‹å‰ã‚¹ã‚­ãƒƒãƒ—
    if (skipGoalOn && Number.isFinite(remainD) && remainD <= skipGoalKm * 1000) {
      logRest(`${label} ${(hereCumM/1000).toFixed(2)} km â†’ HITï¼ˆã‚¹ã‚­ãƒƒãƒ—: ã‚´ãƒ¼ãƒ«ã¾ã§ ${(remainD/1000).toFixed(2)} km / ${formatDur(remainT)} / ${remainE.toFixed(0)} kJï¼‰`);
      return;
    }
    // 2) æ—¢å­˜åœ°ç‚¹è¿‘æ¥ã‚¹ã‚­ãƒƒãƒ—
    if (skipNodeOn && nearExistingNode(lat, lon, skipNodeM)) {
      logRest(`${label} ${(hereCumM/1000).toFixed(2)} km â†’ HITï¼ˆã‚¹ã‚­ãƒƒãƒ—: æ—¢å­˜åœ°ç‚¹ã« ${skipNodeM}m ä»¥å†…ï¼‰`);
      return;
    }
    // æ¡ç”¨
    raw.push({ lat, lon, routeD: hereCumM });
    logRest(`${label} ${(hereCumM/1000).toFixed(2)} km â†’ HIT`);
  }


  // ç¾åœ¨ä½ç½®ã¾ã§ã®ç´¯ç©ï¼ˆç§’ / kJï¼‰â€” å„stepã§è¶³ã—ã¦ã„ã
  let cumTsec = 0;   // s
  let cumEkJ  = 0;   // kJ
  
  const hasEle = coords[0].length>=3;
  const cumDist=[0];
  for(let i=1;i<coords.length;i++){
    cumDist[i]=cumDist[i-1]+L.latLng(coords[i][1],coords[i][0]).distanceTo([coords[i-1][1],coords[i-1][0]]);
  }

  const basis=$('restBasis').value;
  const thr=basis==='time' ? Number($('restMinutes').value)*60 : Number($('restKJ').value);
  let raw=[];

  // ç©ç®—ãƒˆãƒªã‚¬
  if($('optAccum').checked){
    let acc=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0, t=st.duration||0;
        const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
        const dE = energyStepKJ(d,dz,mass,flat);
        // â˜… ç´¯ç©ï¼ˆç§’ / kJï¼‰ã‚’æ›´æ–°
        cumTsec += t;
        cumEkJ  += dE;
        acc += (basis==='time') ? t : dE;
       if (acc >= thr) {
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];
  const hereCum = cumDist[i1]; // m

  // ç©ç®—ã¯ cumTsec / cumEkJ ã‚’æ¸¡ã›ã‚‹ï¼ˆç²¾å¯†ãƒ­ã‚°ï¼‰
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[ACCUM]', /*progTsec*/cumTsec, /*progEkJ*/cumEkJ);
  acc = 0; // æ¬¡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸
}


      }
    }
  }

  // çµ±è¨ˆãƒˆãƒªã‚¬ï¼ˆå®‰å…¨åŒ–ãƒ‘ãƒƒãƒï¼‰
  if ($('optStatTrigger').checked) {
    const meanRaw = Number($('statMean').value);
    const varRaw  = Number($('statVar').value);

    const mean  = Number.isFinite(meanRaw) ? meanRaw : 0;
    const sigma = (Number.isFinite(varRaw) && varRaw >= 0) ? Math.sqrt(varRaw) : 0;

    // Box-Mullerï¼š0 ã® log å›é¿
    const normal = () => {
      let u = Math.random(); if (u <= 1e-12) u = 1e-12;
      let v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    };

    // ä¼‘æ†©é–“éš”ã®ä¸‹é™ï¼ˆkmï¼‰ã€‚å¿…è¦ãªã‚‰ 0.3ï½1.0 ã§å¥½ã¿èª¿æ•´
    const MIN_KM = 0.5;

    let target = Math.max(MIN_KM, mean + sigma * normal());
    let accKm  = 0;

    for (const s of segs) {
      for (const st of s.steps || []) {
        const [i0, i1] = st.way_points || [0, 0];
        const d = st.distance || 0;        // m
        accKm += d / 1000;

        if (accKm >= target) {
  const hereCum = cumDist[i1];          // m
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];

  // çµ±è¨ˆã¯å®Ÿæ¸¬ã®æ™‚é–“/ã‚¨ãƒç´¯ç©ã‚’æŒã£ã¦ã„ãªã„â†’è·é›¢æ¯”ã§è¿‘ä¼¼
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[STAT]');
  target = Math.max(MIN_KM, mean + sigma * normal());
  accKm = 0;
}

      }
    }
  }


   // å‰²åˆãƒˆãƒªã‚¬ï¼ˆå®‰å…¨åŒ–ãƒ‘ãƒƒãƒï¼‰
  if ($('optPercentTrigger').checked) {
    // å…¥åŠ›å€¤ã®æ­£è¦åŒ–ï¼ˆ1%ï½90%ã«ä¸¸ã‚ï¼šå¥½ã¿ã§èª¿æ•´å¯ï¼‰
    let stepPct = Number($('percentStep').value) / 100;
    if (!Number.isFinite(stepPct)) stepPct = 0.25;
    stepPct = Math.min(0.9, Math.max(0.01, stepPct));

    const metric = $('percentMetric').value;

    const totalDist   = feature.properties.summary.distance;     // m
    const totalTime   = feature.properties.summary.duration;     // s
    const totalEnergy = await totalEnergyKJ(feature, mass, flat); // kJ

    const total = (metric === 'distance') ? totalDist
                : (metric === 'time')     ? totalTime
                :                           totalEnergy;

    if (!(Number.isFinite(total) && total > 0)) {
      logRest('[PERCENT] ç·é‡ãŒ0ã¾ãŸã¯éæ•°ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—');
    } else {
      // é–¾å€¤ã¯ã€Œç´¯ç©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã€ã‚’é †ã«è¶³ã—ã¦ã„ãæ–¹å¼
      let nextThreshold = stepPct * total;
      let progressed    = 0;
      const hasEle = coords[0].length >= 3;

      for (const s of segs) {
        for (const st of s.steps || []) {
          const [i0, i1] = st.way_points || [0, 0];
          const d  = st.distance || 0;  // m
          const t  = st.duration || 0;  // s
          const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
          const dE = energyStepKJ(d, dz, mass, flat);

          if (metric === 'distance') progressed += d;
          else if (metric === 'time') progressed += t;
          else progressed += dE;

          // 1ã‚¹ãƒ†ãƒƒãƒ—ã§è¤‡æ•°å›é–¾å€¤ã‚’è·¨ãå¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ while ã§å¯¾å¿œ
          while (progressed >= nextThreshold) {
  const hereCum = cumDist[i1];      // m
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];

  // æ™‚é–“/ã‚¨ãƒã‚’å®Ÿæ¸¬ã§æŒã£ã¦ãªã„ã‚±ãƒ¼ã‚¹â†’è·é›¢æ¯”ã§è¿‘ä¼¼
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[PERCENT]');
  nextThreshold += stepPct * total;
}
        }
      }
    }
  }

  

  return raw;
}

/* ===== åŒºé–“çµ±è¨ˆï¼ˆå„ãƒ«ãƒ¼ãƒˆï¼‰ ===== */
async function calcLegStats(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments || [];
  const hasEle = coords[0].length >= 3;

  const legDist = [], legTime = [], legEnergy = [];
  for (const s of segs) {
    for (const step of (s.steps || [])) {
      const [i0, i1] = step.way_points || [0, 0];
      const d  = step.distance || 0;  // m
      const t  = step.duration || 0;  // s
      const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
      legDist.push(d / 1000);
      legTime.push(t / 60);
      legEnergy.push(energyStepKJ(d, dz, mass, flat));
    }
  }
  return {dist:legDist, time:legTime, energy:legEnergy};
}

function summaryStats(arr){
  if(!arr.length) return {mean:0,var:0,std:0};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length;
  return {mean:m, var:v, std:Math.sqrt(v)};
}

/* ====== Overpass API å‘¼ã³å‡ºã—ï¼ˆå¼·åŒ–ç‰ˆï¼‰ ====== */

// å¾…æ©Ÿç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆã“ã‚ŒãŒå¿…è¦ã§ã™ï¼‰
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function overpassQuery(query) {
  const endpoints = [
    'https://overpass-api.de/api/interpreter',
    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå¿…è¦ãªã‚‰ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’å¤–ã™
    // 'https://overpass.kumi.systems/api/interpreter' 
  ];
  
  let lastError = null;

  for (const ep of endpoints) {
    try {
      // â˜… å‘¼ã³å‡ºã—å‰ã«å¿…ãš1ç§’å¾…ã¤ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ãªè² è·è»½æ¸›ï¼‰
      await sleep(1000); 

      // ã‚«ã‚¦ãƒ³ã‚¿æ›´æ–°
      if (typeof API_USED !== 'undefined') API_USED.overpassTotal++;
      if (typeof OVERPASS_CALL_TOTAL !== 'undefined') OVERPASS_CALL_TOTAL++;

      const r = await fetch(ep, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
        },
        body: new URLSearchParams({ data: query }).toString()
      });

      if (r.ok) return await r.json();

      // ã‚¨ãƒ©ãƒ¼æ™‚ã®å‡¦ç†
      const txt = await r.text().catch(() => "");
      
      // 429 (Too Many Requests) ã®å ´åˆ -> ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã€Œå¾…ã¡ãªã•ã„ã€ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹
      if (r.status === 429) {
        console.warn(`[Overpass] 429 Detected on ${ep}. Waiting 10s...`);
        await sleep(10000); // 10ç§’å¾…æ©Ÿ
        throw new Error("RateLimit"); // ãƒªãƒˆãƒ©ã‚¤ã•ã›ã‚‹ãŸã‚ã«ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹
      }

      // 504 (Timeout) ã®å ´åˆ -> ã‚¯ã‚¨ãƒªãŒé‡ã™ãã‚‹
      if (r.status === 504) {
        console.warn(`[Overpass] 504 Timeout on ${ep}. Query too heavy.`);
        lastError = new Error(`Timeout 504: ${txt}`);
        continue; // åˆ¥ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãªã‚‰ã„ã‘ã‚‹ã‹ã‚‚ï¼Ÿï¼ˆå¯èƒ½æ€§ã¯ä½ã„ãŒï¼‰
      }

      lastError = new Error(`Status ${r.status}: ${txt}`);

    } catch (e) {
      if (e.message === "RateLimit") throw e; // Retryé–¢æ•°ã§ã‚­ãƒ£ãƒƒãƒã•ã›ã‚‹
      console.warn(`[Overpass] Error on ${ep}:`, e);
      lastError = e;
    }
  }
  throw lastError || new Error('[Overpass] All endpoints failed.');
}

async function overpassRetry(query) {
  // ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’æ¸›ã‚‰ã—ã€é–“éš”ã‚’åºƒã’ã‚‹
  let delay = 3000; // åˆå›3ç§’å¾…æ©Ÿ

  for (let i = 0; i < 3; i++) { // æœ€å¤§3å›ãƒˆãƒ©ã‚¤
    try {
      return await overpassQuery(query);
    } catch (e) {
      // æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãªã‚‰å³æ­»
      if (String(e).includes('status=400')) throw e;
      
      console.warn(`[Overpass] Retry ${i+1}/3 after ${delay}ms...`);
      await sleep(delay);
      
      // å¾…æ©Ÿæ™‚é–“ã‚’å€ã€…ã«å¢—ã‚„ã™ (3s -> 6s -> 12s)
      delay *= 2;
    }
  }
  // æœ€å¾Œã«ã‚‚ã†ä¸€åº¦ã ã‘ãƒˆãƒ©ã‚¤ã—ã¦ãƒ€ãƒ¡ãªã‚‰è«¦ã‚ã‚‹
  return await overpassQuery(query);
}
/* ===== POIå–å¾—ï¼ˆæ”¹è‰¯ç‰ˆï¼‰ï¼šã‚«ãƒ†ã‚´ãƒªè‡ªå‹•æ‹¡å¼µï¼‹åŠå¾„æ®µéšæ‹¡å¤§ï¼‹è·é›¢ã‚½ãƒ¼ãƒˆ ===== */
async function fetchPoisAround(latRaw, lonRaw, baseRadius, limit) {
  // --- å…¥åŠ›/å‰å‡¦ç† ---
  const round6 = v => Math.round(Number(v) * 1e6) / 1e6;
  const lat = round6(latRaw), lon = round6(lonRaw);
  const centerLL = L.latLng(lat, lon);

  const limitN = Math.max(1, Number(limit) || 5);

  // ãƒ¦ãƒ¼ã‚¶ã®3ãƒã‚§ãƒƒã‚¯ã‚’èª­ã‚€ï¼ˆã‚³ãƒ³ãƒ“ãƒ‹/ã‚¹ãƒ¼ãƒ‘ãƒ¼/ãƒ‰ãƒ©ãƒƒã‚°ï¼‰
  const useConvenience = document.getElementById('chkConvenience')?.checked ?? true;
  const useSuper       = document.getElementById('chkSuper')?.checked ?? true;
  const useDrug        = document.getElementById('chkDrug')?.checked ?? true;

  // ã¾ãšã¯ãƒ¦ãƒ¼ã‚¶æŒ‡å®šã‚«ãƒ†ã‚´ãƒªã®ã¿ã§è©¦ã™ã€‚0ä»¶ãªã‚‰ä¼‘æ†©ã«é©ã—ãŸã‚«ãƒ†ã‚´ãƒªã‚’è‡ªå‹•ã§è¿½åŠ ã—ã¦å†è©¦è¡Œ
  const PRIMARY_TAGS = [];
  if (useConvenience) PRIMARY_TAGS.push(['shop', 'convenience']);
  if (useSuper)       PRIMARY_TAGS.push(['shop', 'supermarket']);
  if (useDrug) {
    PRIMARY_TAGS.push(['shop','chemist'], ['shop','pharmacy'], ['amenity','pharmacy']);
  }

  // è¿½åŠ ã‚«ãƒ†ã‚´ãƒªï¼ˆå€™è£œã‚¼ãƒ­æ™‚ã«é †æ¬¡è¿½åŠ ï¼‰
  const EXTRA_TAGS = [
    ['amenity','cafe'],
    ['amenity','restaurant'],
    ['amenity','fast_food'],
    ['amenity','drinking_water'],
    ['amenity','toilets'],
    ['amenity','shelter'],
    ['amenity','bench'],
    ['amenity','bicycle_repair_station'],
    ['tourism','picnic_site'],
    ['highway','rest_area'],
    // è‡ªè²©æ©Ÿï¼ˆé£²æ–™ï¼‰: vending_machine=drinks or amenity=vending_machine + vending=drinks
    ['amenity','vending_machine'],
  ];

  // æ®µéšçš„ã«åºƒã’ã‚‹åŠå¾„ï¼ˆmï¼‰ã€‚baseRadiusã‚’å„ªå…ˆã—ã¦çµ„ã¿è¾¼ã‚€
  const radiusSteps = (() => {
    const base = Math.max(100, Number(baseRadius) || 5000); // åˆæœŸã¯å°ã•ã‚ã‹ã‚‰
    const steps = [1000, 2000, 3000, 5000, 8000, 12000, 20000, 30000, 50000, 80000, 100000];
    // base ã‚’å…ˆé ­ã¸ï¼ˆé‡è¤‡æ’é™¤ï¼‰
    const s = [base, ...steps].filter((v, i, a) => a.indexOf(v) === i).sort((a,b)=>a-b);
    return s;
  })();

  // Overpassã‚¯ã‚¨ãƒªã‚’ä½œã‚‹ï¼ˆnode/wayä¸¡æ–¹ã€out centerï¼‰
  const buildQuery = (tags, radius) => {
    if (!tags.length) return null;
    // åŒä¸€ã‚­ãƒ¼ã®è¤‡æ•°å€¤ï¼ˆä¾‹: shop=chemist / shop=pharmacyï¼‰ã‚‚ç¹‹ã’ã¦æ¤œç´¢
    const clauses = [];
    // tags ã¯ [ [k,v], [k,v], ... ]
    // ã“ã“ã§ key ã”ã¨ã« v ã‚’ã¾ã¨ã‚ãŸæ­£è¦è¡¨ç¾ã«ã™ã‚‹
    const grouped = {};
    for (const [k, v] of tags) {
      grouped[k] = grouped[k] || new Set();
      grouped[k].add(v);
    }
    Object.entries(grouped).forEach(([k, set]) => {
      const values = Array.from(set);
      // vending_machine ã¯è£œåŠ©å±æ€§ vending=drinks ã«ã‚‚å¯¾å¿œ
      if (k === 'amenity' && values.includes('vending_machine')) {
        clauses.push(`node(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`node(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
      }
      const re = '(' + values.map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')';
      clauses.push(`node(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
      clauses.push(`way(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
    });

    return `[out:json][timeout:25];
(
  ${clauses.join(';\n  ')};
);
out center;`;
  };

  // å®Ÿè¡Œâ†’elementsâ†’çµæœæ•´å½¢
  const runOnce = async (tags, radius) => {
    let elements = [];
    const q = buildQuery(tags, radius);
    if (!q) return [];

    try {
      const data = await overpassRetry(q);
      elements = data.elements || [];
    } catch (err) {
      // 400ã¯æ§‹æ–‡ç³» â†’ ãƒ­ã‚°ã—ã¦ç©ºæ‰±ã„ã€‚ä»–ã‚¨ãƒ©ãƒ¼ã¯ä¸Šä½ã¸æŠ•ã’ã¦ã‚‚OKã ãŒã€ã“ã“ã§ã¯ç©ºã§ç¶™ç¶šã€‚
      if (String(err).includes('status=400')) console.warn('[Overpass] 400 with query, continue fallback.');
      else console.warn('[Overpass] error', err);
      elements = [];
    }

    // elements ã‚’ {name, lat, lon, distFromTriggerM, distKm, dist} ã«æ•´å½¢ï¼ˆdist ã¯äº’æ›ç”¨ï¼‰
    const results = [];
    elements.forEach(e => {
      const ll = e.type === 'node'
        ? [e.lat, e.lon]
        : (e.center ? [e.center.lat, e.center.lon] : null);
      if (!ll) return;
      const name = (e.tags && (e.tags['name:ja'] || e.tags.name || e.tags.brand)) || 'POI';
      const dist = centerLL.distanceTo([ll[0], ll[1]]); // m
      results.push({
        name,
        lat: ll[0],
        lon: ll[1],
        dist,                     // äº’æ›ã®ãŸã‚æ®‹ã™
        distFromTriggerM: dist,   // æ˜ç¤ºå
        distKm: dist / 1000       // ä¾¿åˆ©ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        });
    });

    // é‡è¤‡æ’é™¤ï¼ˆåŒåï¼†è¿‘æ¥ç‚¹ãŒå¤šã„å ´åˆã‚‚ã‚ã‚‹ã®ã§åº§æ¨™ã‚­ãƒ¼ã§ç²—ãï¼‰
    const seen = new Set();
    const uniq = [];
    for (const p of results) {
      const key = `${p.name}|${p.lat.toFixed(5)},${p.lon.toFixed(5)}`;
      if (seen.has(key)) continue;
      seen.add(key);
      uniq.push(p);
    }

    // è·é›¢ã§ã‚½ãƒ¼ãƒˆ
    uniq.sort((a,b)=>a.dist-b.dist);
    return uniq;
  };

  // 1) ã¾ãšã€Œãƒ¦ãƒ¼ã‚¶æŒ‡å®šã‚«ãƒ†ã‚´ãƒªã®ã¿ã€ã§åŠå¾„ã‚¹ãƒ†ãƒƒãƒ—ã‚’å›ã™
  let picked = [];
  for (const r of radiusSteps) {
    const res = await runOnce(PRIMARY_TAGS, r);
    if (res.length >= limitN) {
      picked = res.slice(0, limitN);
      break;
    }
    // è¶³ã‚Šãªã„åˆ†ã¯ä»®ã«ç¢ºä¿ï¼ˆæ¬¡ã‚¹ãƒ†ãƒƒãƒ—ã§åŸ‹ã¾ã‚Œã°ä¸Šæ›¸ãã•ã‚Œã‚‹ï¼‰
    if (res.length && !picked.length) picked = res.slice(0, limitN);
  }

  // 2) ãã‚Œã§ã‚‚ä¸è¶³ã™ã‚‹ãªã‚‰ã€ã‚«ãƒ†ã‚´ãƒªã‚’è‡ªå‹•æ‹¡å¼µã—ã¦å†è©¦è¡Œ
  if (picked.length < limitN) {
    const MERGED = PRIMARY_TAGS.slice();
    EXTRA_TAGS.forEach(t => MERGED.push(t));

    for (const r of radiusSteps) {
      const res = await runOnce(MERGED, r);
      if (res.length >= limitN) {
        picked = res.slice(0, limitN);
        break;
      }
      if (res.length && res.length > picked.length) {
        picked = res.slice(0, limitN);
      }
    }
  }

  return picked;
}


/* ===== å°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */
function sanitizeCoord(n, fallback) {
  const v = Number(n);
  if (!isFinite(v)) return Number(fallback);
  return Math.round(v * 1e6) / 1e6;
}

/* ====== ä¼‘æ†©ãƒªã‚¹ãƒˆè¡¨ç¤ºæ›´æ–° ====== */
function updateRestListPanel(){
  const ul = $('restListPanel');
  ul.innerHTML='';
  if (!restList.length){
    ul.innerHTML='<li>ä¼‘æ†©åœ°ç‚¹ã¯ã‚ã‚Šã¾ã›ã‚“</li>';
    return;
  }
  restList.forEach((r,i)=>{
    const li=document.createElement('li');
    li.style.padding='4px 0';
    li.innerHTML=`${i+1}. ${r.distance} kmåœ°ç‚¹
      <small>(${r.lat.toFixed(5)}, ${r.lon.toFixed(5)})</small>`;
    ul.appendChild(li);
  });
}

function updateRestPoiPanel(){
  const ol = document.getElementById('restPoiPanel');
  if (!ol) return;
  ol.innerHTML = '';

  // â˜…ã“ã“ã‚’è¿½åŠ ï¼šUIã«å‡ºã™ç›´å‰ã«ã€å…¨POIã¸å‘½åã‚’å¼·åˆ¶
  restGroups.forEach((g, ti) => {
    (g?.pois || []).forEach((p, pi) => ensurePoiName(p, ti, pi));
  });

  if (!restGroups.length){
    const li = document.createElement('li');
    li.textContent = 'ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“';
    ol.appendChild(li);
    return;
  }

  restGroups.forEach((g, i) => {
    const li = document.createElement('li');
    li.style.margin = '6px 0';

    // è¦‹å‡ºã—ï¼šä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼#Nï¼ˆkmåœ°ç‚¹ / ç·¯åº¦çµŒåº¦ï¼‰
    const km = (g.rest?.routeD ?? 0) / 1000;
    const head = document.createElement('div');
    head.innerHTML = `<b>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼ƒ${i+1}</b>ã€€<span style="color:#666">${km.toFixed(2)} kmåœ°ç‚¹</span>
      <small>(${(g.rest?.lat ?? 0).toFixed(5)}, ${(g.rest?.lon ?? 0).toFixed(5)})</small>`;
    li.appendChild(head);

    // å€™è£œPOIã®UL
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.margin = '4px 0 0';
    ul.style.padding = '0';

    if (!g.pois?.length){
      const x = document.createElement('li');
      x.textContent = 'ãƒ»ï¼ˆå€™è£œãªã—ï¼‰';
      ul.appendChild(x);
    } else {
      g.pois.forEach((p) => {
  const it = document.createElement('li');
  it.style.padding = '2px 0';
  const dTrigger = (typeof p.distFromTriggerM === 'number')
    ? ` / ãƒˆãƒªã‚¬ãƒ¼è·é›¢ ${formatDist(p.distFromTriggerM)}`
    : '';
  const dPerp = (p._proj && typeof p._proj.perpM === 'number')
    ? ` / ãƒ«ãƒ¼ãƒˆâŠ¥ <b>${formatDist(p._proj.perpM)}</b>`
    : '';
  it.innerHTML = `ãƒ»${p.name}ã€€${p.lat.toFixed(5)}ã€€${p.lon.toFixed(5)}${dTrigger}${dPerp}`;
  ul.appendChild(it);
});
    }

    li.appendChild(ul);
    ol.appendChild(li);
  });
  drawRestBeams();
  // â–¼â–¼ è¿½åŠ : æ‰‹å‹•æ¯”è¼ƒãƒ„ãƒ¼ãƒ«ã®UIã‚‚æ›´æ–°ã™ã‚‹ â–¼â–¼
  if (typeof updateManualRouteUI === 'function') {
    updateManualRouteUI();
  }
}
  
// ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã‚’ç·šã§çµã‚“ã§å¯è¦–åŒ–ã™ã‚‹
function drawRestBeams(){
  if (!restBeamLayer) return;

  // ã„ã£ãŸã‚“å‰å›ã®ç·šã‚’å…¨éƒ¨æ¶ˆã™
  restBeamLayer.clearLayers();

  if (!Array.isArray(restGroups) || !restGroups.length) return;

  restGroups.forEach(g => {
    const r = g && g.rest;
    if (!r || !Array.isArray(g.pois)) return;

    g.pois.forEach(p => {
      if (!p) return;
      // ãƒˆãƒªã‚¬ãƒ¼ â†’ POI ã‚’ç´°ã„ç ´ç·šã§å¼•ã
      const line = L.polyline(
        [[r.lat, r.lon], [p.lat, p.lon]],
        { weight: 2, dashArray: '4,4', color: '#999' }
      );
      restBeamLayer.addLayer(line);
    });
  });
}

// çµ„ã¿åˆã‚ã›è¡¨ç¤ºå°‚ç”¨ï¼šä½¿ç”¨åœ°ç‚¹ã ã‘ãƒ”ãƒ³ã‚’å‡ºã™
function setComboMarkers(start, picksArray, goal){
  // æ—¢å­˜ãƒ”ãƒ³ã‚’ã™ã¹ã¦æ¶ˆã™
  if (markerLayer) map.removeLayer(markerLayer);
  markerLayer = L.layerGroup().addTo(map);

  // ã‚¹ã‚¿ãƒ¼ãƒˆ
  if (start) {
    L.marker([start.lat, start.lon], {icon:ICONS.start})
      .bindTooltip(start.name || 'ã‚¹ã‚¿ãƒ¼ãƒˆ').addTo(markerLayer);
  }

  // æ¡ç”¨POIï¼ˆé †è·¯ï¼‰
  (picksArray || []).forEach((p, i) => {
    if (!p) return;
    L.marker([p.lat, p.lon], {
      icon: new L.Icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
        iconSize:[32,32], iconAnchor:[16,32]
      })
    }).bindTooltip(`${p.name || 'ä¼‘æ†©'} #${i+1}`).addTo(markerLayer);
  });

  // ã‚´ãƒ¼ãƒ«
  if (goal) {
    L.marker([goal.lat, goal.lon], {icon:ICONS.goal})
      .bindTooltip(goal.name || 'ã‚´ãƒ¼ãƒ«').addTo(markerLayer);
  }
}


function showTop3Combos(resultList){
  const box = document.getElementById('comboTop3');
  box.innerHTML = '';
  // ç›´è¿‘ã®ã€Œæ¢ç´¢: *ã€ã‚’æ‹¾ã£ã¦è¦‹å‡ºã—ã«è¡¨ç¤º
const last = [...PERF.rows].reverse().find(r=>String(r.name).startsWith('æ¢ç´¢:'));
if(last){
  const note = document.createElement('div');
  note.style.cssText='color:#555;margin-bottom:6px';
  note.innerHTML = `æ¢ç´¢æ™‚é–“: <b>${last.ms.toFixed(1)} ms</b> <small>(${last.name})</small>`;
  box.appendChild(note);
}

  if (!resultList.length){
    box.textContent = 'å€™è£œãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã‚„POIãŒä¸è¶³ï¼‰';
    return;
  }

  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const fmt = (n)=>Number(n).toFixed(5);

  resultList.slice(0,3).forEach((r, idx) => {
    const rank = idx+1;

    const wrap = document.createElement('div');
    wrap.style.border='1px solid #ddd';
    wrap.style.borderRadius='8px';
    wrap.style.padding='8px';
    wrap.style.marginBottom='8px';

    const header = document.createElement('div');
    const metric = getScoreMetric();
const sig = {
  dist: sd(r.stats.dist),
  time: sd(r.stats.time),
  energy: sd(r.stats.energy)
};
const metricLabel = (metric === 'time') ? 'æ™‚é–“Ïƒ'
                  : (metric === 'energy') ? 'ã‚¨ãƒãƒ«ã‚®ãƒ¼Ïƒ'
                  : 'è·é›¢Ïƒ';
const metricValue = (metric === 'time') ? sig.time
                   : (metric === 'energy') ? sig.energy
                   : sig.dist;

header.innerHTML = `
  <div style="font-weight:700;margin-bottom:4px">
    #${rank}ã€€ã‚¹ã‚³ã‚¢ï¼ˆ${metricLabel}ï¼‰: ${metricValue.toFixed(3)}
    ${Number.isFinite(r.score)
      ? `<span style="color:#777">ï¼ˆMSE=${Number(r.score).toFixed(3)}ï¼‰</span>`
      : ''
    }
  </div>
  <div style="margin-top:4px">
    è·é›¢Ïƒ=${sig.dist.toFixed(2)} kmã€€
    æ™‚é–“Ïƒ=${sig.time.toFixed(2)} åˆ†ã€€
    ã‚¨ãƒãƒ«ã‚®ãƒ¼Ïƒ=${sig.energy.toFixed(2)} kJ
  </div>
`;

    wrap.appendChild(header);

    const list = document.createElement('div');
    list.style.marginTop = '8px';
    list.innerHTML = `<div style="font-weight:600;margin-bottom:4px">æ¡ç”¨ã—ãŸä¼‘æ†©åœ°ç‚¹ï¼ˆãƒˆãƒªã‚¬ãƒ¼ã”ã¨ï¼‰</div>`;
    const ol = document.createElement('ol');
    ol.style.margin = '4px 0 0 1.1rem';
    ol.style.fontSize = '0.92rem';

    (restGroups || []).forEach((g, i) => {
      const li = document.createElement('li');
      const km = ((g?.rest?.routeD || 0) / 1000).toFixed(2);
      const head = document.createElement('div');
      head.innerHTML = `<b>ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ï¼ƒ${i+1}</b>ã€€<span style="color:#666">${km} kmåœ°ç‚¹</span>
        <small>(${fmt(g?.rest?.lat||0)}, ${fmt(g?.rest?.lon||0)})</small>`;
      li.appendChild(head);

      const chosen = (r.picksByTrigger && r.picksByTrigger[i]) ? r.picksByTrigger[i] : null;
      const ul = document.createElement('ul');
      ul.style.listStyle='none'; ul.style.margin='4px 0 0'; ul.style.padding='0';

      const row = document.createElement('li');
      row.style.padding='2px 0';

      if (chosen){
        row.style.cursor='pointer';
        const dtxt = (typeof chosen.distFromTriggerM === 'number')
          ? ` / ${formatDist(chosen.distFromTriggerM)}`
            : '';
        row.textContent = `ãƒ»${chosen.name}ã€€${fmt(chosen.lat)}ã€€${fmt(chosen.lon)}${dtxt}`;
        row.onclick = () => {
          map.flyTo([chosen.lat, chosen.lon], 17);
          L.popup().setLatLng([chosen.lat, chosen.lon]).setContent(chosen.name).openOn(map);
        };
      } else {
  // å€™è£œãŒä¸€ä»¶ã‚‚ç„¡ã„ã®ã‹ã€å˜ã«ãã®çµ„ã¿åˆã‚ã›ã§æœªæ¡ç”¨ãªã®ã‹ã‚’åˆ¤å®š
  const hasAny = Array.isArray(g?.pois) && g.pois.length > 0;

  // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  console.log('[showTop3Combos] trigger', i+1,
              'pois=', g?.pois?.length || 0,
              'chosen=', chosen,
              'label=', hasAny ? 'æœªæ¡ç”¨' : 'å€™è£œãªã—');

  row.textContent = hasAny ? 'ãƒ»ï¼ˆæœªæ¡ç”¨ï¼‰' : 'ãƒ»ï¼ˆå€™è£œãªã—ï¼‰';
  row.style.color = '#777';
}

      ul.appendChild(row);
      li.appendChild(ul);
      ol.appendChild(li);
    });

    list.appendChild(ol);
    wrap.appendChild(list);

    const btnWrap = document.createElement('div');
    btnWrap.style.marginTop='8px';
    const btn = document.createElement('button');
    btn.textContent = 'ã“ã®ãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤º';
    btn.onclick = async () => {
      btn.disabled = true;
      btn.textContent = 'ãƒ«ãƒ¼ãƒˆç”Ÿæˆä¸­...';
      try {
        let feature = r.feature;
        if (!feature) {
          const start = pts.find(p=>p.type==='start') || pts[0];
          const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
          if (!start || !goal) { alert('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'); return; }
          const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
            ? r.picksByTrigger.filter(Boolean)
            : (r.picks || []);
          const wps = [start, ...picksArray, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name || 'POI'}));
          const profile = 'cycling-road';
          const out = await routeLegStatsForWaypoints(wps, profile);
          feature = out.feature;
        }
        if (!feature) { alert('ãƒ«ãƒ¼ãƒˆã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚'); return; }

        clearRouteLayers();
        const color = '#00aa88';
        const layer = L.geoJSON(feature, { style:{ color, weight: 7 } }).addTo(map);
        routeLayers['combo#'+rank] = layer;

        const start = pts.find(p=>p.type==='start') || pts[0];
        const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
        const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
          ? r.picksByTrigger.filter(Boolean)
          : (r.picks || []);
        setComboMarkers(start, picksArray, goal);

        // ï¼ˆshowTop3Combos å†…ã®ä¸€éƒ¨ï¼‰
const bounds = layer.getBounds?.();
if (bounds && bounds.isValid && bounds.isValid()) {
  map.fitBounds(bounds.pad(0.1));
} else {
  const fallback = (r.picks && r.picks[0]) || pts[0];
  if (fallback) map.flyTo([fallback.lat, fallback.lon], 14);
}

        setActiveButton(null);
      } catch (e){
  console.error(e);
  const hints = [
    !ORS_KEY ? 'ORS_KEY ãŒæœªè¨­å®š' : null,
    !(pts && pts.length>=2) ? 'Start/Goal ãŒä¸æ­£' : null,
    !routeData.fastest ? 'æœ€é€Ÿãƒ«ãƒ¼ãƒˆæœªç”Ÿæˆï¼ˆå…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œï¼‰' : null
  ].filter(Boolean).join(' / ');
  alert('ãƒ«ãƒ¼ãƒˆæç”»ã§ã‚¨ãƒ©ãƒ¼: ' + (e.message || e) + (hints ? '\nãƒ’ãƒ³ãƒˆ: ' + hints : ''));
} finally {
        btn.disabled = false;
        btn.textContent = 'ã“ã®ãƒ«ãƒ¼ãƒˆã‚’è¡¨ç¤º';
      }
    };
    btnWrap.appendChild(btn);
    wrap.appendChild(btnWrap);

    box.appendChild(wrap);
  });
}

// 1ãƒ¬ã‚°ã®MSEï¼ˆè·é›¢ãƒ»æ™‚é–“ãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰
// function legMseCost(d, t, e, ideald, idealt, ideale){
//   const dd = d - ideald;
//   const tt = t - idealt;
//   const ee = e - ideale;
//   return dd*dd + tt*tt + ee*ee;
// }
  function legMseCost(d, t, e, ideald, idealt, ideale){
  const ee = e - ideale;
  return ee*ee;
}


// stats({dist[], time[], energy[]}) ã‹ã‚‰ãƒ«ãƒ¼ãƒˆå…¨ä½“ã®MSEã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
function routeMseScoreFromStats(stats, idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg){
  const dArr = stats?.dist   || [];
  const tArr = stats?.time   || [];
  const eArr = stats?.energy || [];

  const n = Math.min(dArr.length, tArr.length, eArr.length);
  if (!n) return NaN; // â† ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šç›´ç·šè·é›¢ãªã©ã€Œtime/energyãªã—ã€ã¯ MSE è¨ˆç®—ä¸å¯

  let sum = 0;
  for (let i = 0; i < n; i++){
    sum += legMseCost(
      dArr[i],
      tArr[i],
      eArr[i],
      idealDistPerLeg,
      idealTimePerLeg,
      idealEnergyPerLeg
    );
  }
  return sum; // å°ã•ã„ã»ã©ã€Œç†æƒ³ãƒšãƒ¼ã‚¹ã«è¿‘ã„ã€
}


/* ===== ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼ˆPOIè©•ä¾¡ï¼‰ ===== */
// ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒï¼ˆç„¡ã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
let SCORE_WEIGHTS = (()=>{
  try{
    const raw = localStorage.getItem('route_score_weights');
    if(!raw) return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
    const obj = JSON.parse(raw);
    // ä¸è¶³ã‚­ãƒ¼ã¯è£œå®Œ
    return {
      wAlign: Number.isFinite(obj?.wAlign) ? obj.wAlign : 1.0,
      wPerp:  Number.isFinite(obj?.wPerp)  ? obj.wPerp  : 1.0,
      wTrig:  Number.isFinite(obj?.wTrig)  ? obj.wTrig  : 0.5,
    };
  }catch(e){
    return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
  }
})();

function getScoreMetric(){
  const sel = document.getElementById('scoreMetricSelect');
  return sel ? sel.value : SCORE_METRIC;
}
function setScoreMetric(v){
  SCORE_METRIC = v;
  localStorage.setItem('route_score_metric', v);
}


function targetCumDForIndex(i, R, totalD){
  if (!Number.isFinite(totalD) || totalD<=0) return 0;
  return totalD * (i + 1) / (R + 1);
}

function nodeCost(p, targetCumD){
  if (!p) return 1e9;
  const perpM   = Number(p?._proj?.perpM) ?? 0;
  const trigM   = Number(p?.distFromTriggerM) ?? 0;
  const alignM  = Math.abs((Number(p?._proj?.cumD) ?? targetCumD) - targetCumD);
return (SCORE_WEIGHTS.wAlign * (alignM/1000)) +
       (SCORE_WEIGHTS.wPerp  * (perpM/1000))  +
       (SCORE_WEIGHTS.wTrig  * (trigM/1000));
}


/* ===== çµ„ã¿åˆã‚ã›ãƒ«ãƒ¼ãƒˆæ¢ç´¢ï¼†è©•ä¾¡ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===== */

/* ===== ç›´ç·šè·é›¢: å…¨çµ„ã¿åˆã‚ã›ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ã§1ä»¶ï¼‰ ===== */

// ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«å–å¾—ï¼ˆä¿é™ºã¤ãï¼‰
function getStartGoalPoints(){
  const start = pts.find(p=>p.type==='start') || pts[0];
  const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
  if(!start || !goal) throw new Error('ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  return {start, goal};
}

// POIç¾¤ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼ï¼‰ã‹ã‚‰ã€Œæœ€å¤§5ä»¶ã ã‘ã€å–ã‚Šå‡ºã™ï¼ˆå°„å½±ãŒç„¡ãã¦ã‚‚OKï¼‰
function topPoisPerTriggerForLinear(maxPer=5){
  if(!Array.isArray(restGroups) || !restGroups.length) throw new Error('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“');
  // ã¨ã‚Šã‚ãˆãšã€Œãƒˆãƒªã‚¬ãƒ¼ã‹ã‚‰ã®è·é›¢ + ãƒ«ãƒ¼ãƒˆç›´äº¤è·é›¢ã€ã®å°ã•ã„é †ã§åˆ‡ã‚Šå‡ºã—ï¼ˆç„¡ã‘ã‚Œã°ã‚ã‚‹æƒ…å ±ã ã‘ï¼‰
  return restGroups.map((g,i)=>{
    const arr = (g?.pois || []).slice();
    // ã€Œå€™è£œãªã—ã€ã®ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚‹ã¨çµ„ã¿åˆã‚ã›ãŒæˆç«‹ã—ãªã„ã®ã§ã€ã“ã“ã§å¼¾ã
    if(!arr.length) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã«å€™è£œPOIãŒã‚ã‚Šã¾ã›ã‚“`);
    const score = p=>{
      const a = Number(p?.distFromTriggerM) || 0;
      const b = Number(p?._proj?.perpM) || 0;
      return a + b;
    };
    arr.sort((x,y)=> score(x)-score(y));
    return arr.slice(0, Math.max(1, Math.min(maxPer, arr.length)));
  });
}



// 2ç‚¹é–“ã®åœ°ä¸Šè·é›¢ï¼ˆmï¼‰
function llDist(a,b){
  return L.latLng(a.lat, a.lon).distanceTo([b.lat, b.lon]);
}

// ã‚ã‚‹çµ„ã¿åˆã‚ã›ï¼ˆpicks: å„ãƒˆãƒªã‚¬ãƒ¼ã§1ä»¶ï¼‰ã«å¯¾ã—ã€
// start -> picks[0] -> picks[1] -> ... -> goal ã®ç›´ç·šåˆè¨ˆè·é›¢ï¼ˆmï¼‰ã‚’è¿”ã™
function comboLinearDistanceMeters(start, picks, goal){
  let sum = 0;
  let prev = start;
  for(const p of picks){
    sum += llDist(prev, p);
    prev = p;
  }
  sum += llDist(prev, goal);
  return sum;
}

// å…¨çµ„ã¿åˆã‚ã›ã‚’åˆ—æŒ™ï¼ˆå„ãƒˆãƒªã‚¬ãƒ¼1ä»¶å¿…ãšé¸ã¶ï¼‰
function enumerateAllOnePerTrigger(groups, hardCap=200000){
  // groups ã¯ [ [p,p,p...], [p,p...], ... ]
  const out = [];
  const idx = new Array(groups.length).fill(0);
  const lens = groups.map(g=>g.length);
  let total = lens.reduce((a,b)=>a*b,1);
  if(total>hardCap) total = hardCap; // çˆ†ç™ºé˜²æ­¢

  for(let n=0; n<total; n++){
    // ç¾åœ¨ã®é¸æŠã‚’ push
    out.push(groups.map((g,i)=> g[idx[i]]));
    // æ¬¡ã®çµ„ã¿åˆã‚ã›ã¸
    for(let i=groups.length-1;i>=0;i--){
      idx[i]++;
      if(idx[i] < lens[i]) break;
      idx[i]=0;
      if(i===0) return out; // å…¨æ¢ç´¢å®Œäº†
    }
  }
  return out;
}

// ç›´ç·šè·é›¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç”¨ã«ã€å…¨çµ„åˆã›ã‚’ã€Œè¡Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã«å¤‰æ›ã—ã¦è¿”ã™ãƒ˜ãƒ«ãƒ‘ãƒ¼
function buildLinearAlgoRows(start, goal, groups, hardCap = 200000) {
  const combos = enumerateAllOnePerTrigger(groups, hardCap);

  const rows = combos.map(picks => {
    const meters = comboLinearDistanceMeters(start, picks, goal);
    const km = meters / 1000;

    const idxes = picks.map((p, gi) => {
      const idx = groups[gi].indexOf(p);
      return idx >= 0 ? idx : null;
    });

    return {
      score: km,
      rawScore: meters,
      stats: {
        dist: [km],
        time: [],
        energy: []
      },
      picks,
      picksByTrigger: picks,
      km,
      idxes
    };
  });

  rows.sort((a, b) => (a.score ?? Infinity) - (b.score ?? Infinity));
  return rows;
}

async function calcLegCostWithApi(from, to, profile){
  if (!from || !to) throw new Error('calcLegCostWithApi: from/to ãŒä¸æ­£ã§ã™');

  const t0 = performance.now();

  const fromLat = from.lat ?? from.latitude ?? from.y;
  const fromLon = from.lon ?? from.lng ?? from.longitude ?? from.x;
  const toLat   = to.lat   ?? to.latitude   ?? to.y;
  const toLon   = to.lon   ?? to.lng ?? to.longitude   ?? to.x;

  // â˜…åº§æ¨™ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆé‡è¦ï¼‰
  if (!Number.isFinite(fromLat) || !Number.isFinite(fromLon) ||
      !Number.isFinite(toLat)   || !Number.isFinite(toLon)) {
    const msg = `calcLegCostWithApi: lat/lon ãŒä¸æ­£ from(${fromLat},${fromLon}) to(${toLat},${toLon})`;
    if (window.__collectViterbiEdges) {
      window.__viterbiAllEdgeRows = window.__viterbiAllEdgeRows || [];
      window.__viterbiAllEdgeRows.push({
        fromName: 'INVALID', toName: 'INVALID',
        fromLat, fromLon, toLat, toLon,
        distKm:'', timeMin:'', energyKj:'',
        profile,
        ms: Math.round(performance.now() - t0),
        ok:false,
        errMsg: msg
      });
    }
    throw new Error(msg);
  }

  const short = (lat,lon)=> `${Number(lat).toFixed(5)},${Number(lon).toFixed(5)}`;
  const fromName = (from.name || from.label) ? (from.name || from.label)
                : (from.type ? `${from.type}(${short(fromLat,fromLon)})` : `FROM(${short(fromLat,fromLon)})`);
  const toName   = (to.name || to.label) ? (to.name || to.label)
                : (to.type ? `${to.type}(${short(toLat,toLon)})` : `TO(${short(toLat,toLon)})`);

  const wps = [ { lat: fromLat, lon: fromLon }, { lat: toLat, lon: toLon } ];

  try {
    const out = await routeLegStatsForWaypoints(wps, profile);
    const summary = out?.feature?.properties?.summary || {};

    const distKm  = (Number(summary.distance) || 0) / 1000;
    const timeMin = (Number(summary.duration) || 0) / 60;

    // --- energy æŠ½å‡ºï¼ˆè¿”ã‚Šå€¤ã®æºã‚Œã‚’å¸åï¼‰ ---
const ene =
  out?.stats?.energy ??   // æœŸå¾…å½¢ï¼ˆåŒºé–“é…åˆ— or ç´¯ç©é…åˆ—ï¼‰
  out?.stats?.E ??        // åˆ¥åå€™è£œ
  out?.stats?.cumE ??     // åˆ¥åå€™è£œ
  null;

let energyKj = 0;

// 1) é…åˆ—ãªã‚‰ã€Œç´¯ç©ã£ã½ã„â†’æœ«å°¾ã€ã€ŒåŒºé–“ã£ã½ã„â†’sumã€ã©ã£ã¡ã§ã‚‚ç ´ç¶»ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
if (Array.isArray(ene) && ene.length) {
  const last = Number(ene[ene.length - 1]);
  if (Number.isFinite(last) && last > 0) {
    energyKj = last;           // ç´¯ç©é…åˆ—ãªã‚‰æœ«å°¾ãŒç·é‡
  } else {
    energyKj = sumNums(ene);   // åŒºé–“é…åˆ—ãªã‚‰åˆè¨ˆ
  }
// 2) å˜ç™ºã®æ•°å€¤ã§è¿”ã£ã¦ããŸå ´åˆ
} else if (Number.isFinite(Number(ene))) {
  energyKj = Number(ene);
// 3) ãã‚Œä»¥å¤–ã¯0
} else {
  energyKj = 0;
}

    if (window.__collectViterbiEdges) {
      window.__viterbiAllEdgeRows = window.__viterbiAllEdgeRows || [];
      window.__viterbiAllEdgeRows.push({
        fromName, toName,
        fromLat, fromLon, toLat, toLon,
        distKm, timeMin, energyKj,      // â˜…ã“ã“çµ±ä¸€ï¼
        profile,
        ms: Math.round(performance.now() - t0),
        ok: true,
        errMsg: ''
      });
    }

    return { total: distKm, distKm, timeMin, energyKj };

  } catch (e) {
    if (window.__collectViterbiEdges) {
      window.__viterbiAllEdgeRows = window.__viterbiAllEdgeRows || [];
      window.__viterbiAllEdgeRows.push({
        fromName, toName,
        fromLat, fromLon, toLat, toLon,
        distKm: '', timeMin: '', energyKj: '', // â˜…ã“ã“ã‚‚çµ±ä¸€ï¼
        profile,
        ms: Math.round(performance.now() - t0),
        ok: false,
        errMsg: String(e?.message || e)
      });
    }
    throw e;
  }
}

// Viterbiï¼ˆAPIåˆ©ç”¨ç‰ˆï¼‰
// start, goal: {lat, lon} å½¢å¼
// restGroups: [ [POI, POI, ...], [POI, ...], ... ] å„ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã®å€™è£œPOI
// profile: 'cycling-road' ãªã©
/* ===== ã€ä¿®æ­£ç‰ˆã€‘runViterbiOnce_API (è·é›¢MSEå®Œå…¨å¯¾å¿œãƒ»ã‚¨ãƒ©ãƒ¼ä¿®æ­£æ¸ˆã¿) ===== */
async function runViterbiOnce_API(start, goal, restGroups, profile) {

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!Number.isInteger(T) || T <= 0) {
    console.warn('[Viterbi] restGroups ãŒç©º / ä¸æ­£ã§ã™:', restGroups);
    return [];
  }

  // â˜…è·é›¢ã®ç†æƒ³å€¤ã‚’å–å¾—
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => !Number.isInteger(k) || k <= 0)) {
    console.warn('[Viterbi] å€™è£œ0ä»¶ã®ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã™:', Klist);
    return [];
  }

  const dp   = [];
  const prev = [];
  for (let t = 0; t < T; t++) {
    dp[t]   = new Array(Klist[t]).fill(Infinity);
    prev[t] = new Array(Klist[t]).fill(-1);
  }

  // --- start â†’ æœ€åˆã®ãƒˆãƒªã‚¬ãƒ¼ ---
  for (let k = 0; k < Klist[0]; k++) {
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);

    // â˜…è·é›¢MSEã‚’è¨ˆç®—
    const mse = legDistMseCost(leg.distKm, idealDistPerLeg);
    dp[0][k] = mse;

    // â˜…ä¿®æ­£: ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—(de, idealEnergyPerLeg)ã‚’å‰Šé™¤
    recordViterbiEdge({
      t: 0,
      fromIdx: -1,
      toIdx: k,
      fromName: start.name || 'start',
      toName: poi.name || `g0[${k}]`,
      fromLat: start.lat, fromLon: start.lon,
      toLat: poi.lat,     toLon: poi.lon,
      distKm: leg.distKm,
      timeMin: leg.timeMin,
      energyKj: leg.energyKj,
      cost: mse,      // ã‚³ã‚¹ãƒˆã¨ã—ã¦MSEã‚’ä¿å­˜
      mseDist: mse
    });
  }

  // --- t-1 â†’ t ---
  for (let t = 1; t < T; t++) {
    const curGroup  = restGroups[t];
    const prevGroup = restGroups[t - 1];

    for (let j = 0; j < Klist[t]; j++) {
      const toPoi = curGroup[j];
      let bestCost = Infinity;
      let bestIdx  = -1;

      for (let i = 0; i < Klist[t - 1]; i++) {
        const fromPoi = prevGroup[i];
        if (!Number.isFinite(dp[t - 1][i])) continue;

        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);

        // â˜…è·é›¢MSEã‚’è¨ˆç®—
        const mse = legDistMseCost(leg.distKm, idealDistPerLeg);
        
        recordViterbiEdge({
          t,
          fromIdx: i,
          toIdx: j,
          fromName: fromPoi.name || `g${t-1}[${i}]`,
          toName: toPoi.name || `g${t}[${j}]`,
          fromLat: fromPoi.lat, fromLon: fromPoi.lon,
          toLat: toPoi.lat,     toLon: toPoi.lon,
          distKm: leg.distKm,
          timeMin: leg.timeMin,
          energyKj: leg.energyKj,
          cost: mse,
          mseDist: mse,
          prevDp: dp[t-1][i],
          candDp: dp[t-1][i] + mse
        });

        const cand = dp[t - 1][i] + mse;

        if (cand < bestCost) {
          bestCost = cand;
          bestIdx  = i;
        }
      }
      dp[t][j]   = bestCost;
      prev[t][j] = bestIdx;
    }
  }

  // --- æœ€å¾Œã®ãƒˆãƒªã‚¬ãƒ¼ â†’ goal ---
  const lastT = T - 1;
  let bestFinalCost = Infinity;
  let bestFinalIdx  = -1;

  for (let k = 0; k < Klist[lastT]; k++) {
    if (!Number.isFinite(dp[lastT][k])) continue;

    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApi(poi, goal, profile);

    // â˜…è·é›¢MSEã‚’è¨ˆç®—
    const mse = legDistMseCost(leg.distKm, idealDistPerLeg);

    recordViterbiEdge({
      t: lastT + 1,
      fromIdx: k,
      toIdx: -1,
      fromName: poi.name || `g${lastT}[${k}]`,
      toName: goal.name || 'goal',
      fromLat: poi.lat,  fromLon: poi.lon,
      toLat: goal.lat,   toLon: goal.lon,
      distKm: leg.distKm,
      timeMin: leg.timeMin,
      energyKj: leg.energyKj,
      cost: mse,
      mseDist: mse,
      prevDp: dp[lastT][k],
      candDp: dp[lastT][k] + mse
    });

    const cand = dp[lastT][k] + mse;

    if (cand < bestFinalCost) {
      bestFinalCost = cand;
      bestFinalIdx  = k;
    }
  }

  if (bestFinalIdx < 0 || !Number.isFinite(bestFinalCost)) {
    console.warn('[Viterbi] ã‚´ãƒ¼ãƒ«ã¾ã§åˆ°é”ã™ã‚‹ãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
    return [];
  }

  // çµŒè·¯å¾©å…ƒ
  const picks = new Array(T);
  let curIdx  = bestFinalIdx;

  for (let t = lastT; t >= 0; t--) {
    picks[t] = restGroups[t][curIdx];
    curIdx   = prev[t][curIdx];

    if (t > 0 && curIdx < 0) {
      console.warn('[Viterbi] prev ã®è¾»è¤„ãŒåˆã„ã¾ã›ã‚“ t=', t);
      break;
    }
  }

  // æœ€çµ‚ã‚¹ã‚³ã‚¢è¨ˆç®—
  let feature = null;
  let stats   = { dist:[], time:[], energy:[] };
  let finalScore = bestFinalCost;

  try {
    const wps = [start, ...picks, goal].map(p => ({
      lat: p.lat,
      lon: p.lon,
      name: p.name || 'POI'
    }));

    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if (out?.stats) stats = out.stats;

    // â˜…æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚‚è·é›¢MSEã§è¨ˆç®—
    const exact = finalScoreFromStats(stats, ideals); 
    if (Number.isFinite(exact)) finalScore = exact;

  } catch (e) {
    console.warn('[Viterbi] çµ±è¨ˆè¨ˆç®—ç”¨ãƒ«ãƒ¼ãƒˆç”Ÿæˆã«å¤±æ•—', e);
  }

  return [{
    score:    finalScore,
    rawScore: bestFinalCost,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// è¡¨ç¤ºã¨CSVå‡ºåŠ›
function renderLinearResults(rows){
  const cont = document.getElementById('linearList');
  const sum  = document.getElementById('linearSummary');
  if(!cont || !sum) return;

  // --- ä¸Šä½3ä»¶ã®ã¿è¡¨ç¤º ---
  const SHOW = 3;
  const shown = rows.slice(0, SHOW);

  // CSVå…¨ä»¶ã¯ä¿æŒï¼ˆUIã¯3ä»¶ï¼‰
  window.__linear_rows_for_csv = rows;
  const csvBtn = document.getElementById('btnDownloadLinearCsv');
  if(csvBtn) csvBtn.disabled = rows.length===0;

  cont.innerHTML = ''; // ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã«å¤‰æ›´
  shown.forEach((r, i) => {
    const rank = i + 1;
    const names = r.picks.map(p=> p?.name || 'POI').join(' â†’ ');

    const wrap = document.createElement('div');
    wrap.style.border = '1px solid #ddd';
    wrap.style.borderRadius = '8px';
    wrap.style.padding = '8px';
    wrap.style.marginBottom = '8px';
    wrap.style.fontFamily = 'system-ui,ui-sans-serif';

    const head = document.createElement('div');
    head.style.fontWeight = '700';
    head.style.marginBottom = '4px';
    head.textContent = `#${rank}  åˆè¨ˆç›´ç·šè·é›¢: ${r.km.toFixed(2)} km`;
    wrap.appendChild(head);

    const meta = document.createElement('div');
    meta.style.color = '#555';
    meta.style.fontSize = '0.92rem';
    meta.textContent = `idx=${JSON.stringify(r.idxes)} | ${names}`;
    wrap.appendChild(meta);

    const btnRow = document.createElement('div');
    btnRow.style.marginTop = '6px';

    const btn = document.createElement('button');
    btn.textContent = 'ã“ã®çµ„ã¿åˆã‚ã›ã§ãƒ«ãƒ¼ãƒˆè¡¨ç¤º';
    btn.onclick = async () => {
      btn.disabled = true;
      const oldTxt = btn.textContent;
      btn.textContent = 'ç”Ÿæˆä¸­â€¦';
      try {
        await showLinearComboRoute(r);   // â† ä¸‹ã®æ–°é–¢æ•°ã§æç”»
      } catch (e) {
        const hints = [
          !ORS_KEY ? 'ORS_KEY æœªè¨­å®š' : null,
          !(pts && pts.length>=2) ? 'Start/Goal æœªè¨­å®š' : null
        ].filter(Boolean).join(' / ');
        alert('ãƒ«ãƒ¼ãƒˆæç”»ã«å¤±æ•—: ' + (e.message || e) + (hints ? '\nãƒ’ãƒ³ãƒˆ: ' + hints : ''));
        console.error(e);
      } finally {
        btn.disabled = false;
        btn.textContent = oldTxt;
      }
    };
    btnRow.appendChild(btn);
    wrap.appendChild(btnRow);

    cont.appendChild(wrap);
  });

  const msg = `ç·çµ„åˆã›æ•°: ${rows.length.toLocaleString()} ä»¶ï¼ˆä¸Šä½ ${Math.min(SHOW, rows.length)} ä»¶ã‚’è¡¨ç¤ºï¼CSVã¯å…¨ä»¶å‡ºåŠ›å¯èƒ½ï¼‰`;
  sum.textContent = msg;
}

function downloadLinearCsv(){
  const rows = window.__linear_rows_for_csv || [];
  if (!rows.length) return;

  const header = ['rank','total_km','indices_per_trigger','poi_names'];

  const bodyRows = rows.map((r, i)=>{
    const names = r.picks.map(p=> (p?.name ?? 'POI')).join(' -> ');
    return [
      String(i+1),
      r.km.toFixed(3),
      `"${csvEscape(JSON.stringify(r.idxes))}"`,
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'linear_combinations.csv');
}

// ãƒœã‚¿ãƒ³å‹•ä½œï¼šè¨ˆç®— â†’ ä¸¦ã¹æ›¿ãˆ â†’ è¡¨ç¤º
function bindLinearButtonsOnce(){
  const calcBtn = document.getElementById('btnCalcLinear');
  const csvBtn  = document.getElementById('btnDownloadLinearCsv');
  if(!calcBtn) return;
  if(calcBtn.__bound) return; // äºŒé‡ãƒã‚¤ãƒ³ãƒ‰é˜²æ­¢
  calcBtn.__bound = true;

  calcBtn.onclick = ()=>{
    try{
      const {start, goal} = getStartGoalPoints();
      const groups = makeCandGroupsFromRestGroups(restGroups, 5, defaultLinearSorter);
      // ç·çµ„åˆã›ãƒã‚§ãƒƒã‚¯ï¼ˆå¤šã™ãã‚‹å ´åˆã¯æ³¨æ„ã ã‘å‡ºã™ï¼‰
      const total = groups.reduce((a,b)=>a*b.length,1);
      if(total > 200000){
        if(!confirm(`çµ„åˆã›ãŒ ${total.toLocaleString()} ä»¶ã‚ã‚Šã¾ã™ã€‚ä¸Šé™20ä¸‡ä»¶ã¾ã§è¨ˆç®—ã—ã¾ã™ã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`)) return;
      }
      const combos = enumerateAllOnePerTrigger(groups, /*hardCap*/200000);

      // è·é›¢è¨ˆç®—
      const rows = combos.map(idxPicks=>{
        const meters = comboLinearDistanceMeters(start, idxPicks, goal);
        return {
          meters,
          km: meters/1000,
          picks: idxPicks,
          idxes: idxPicks.map((p, i)=> groups[i].indexOf(p)) // ã©ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é¸ã‚“ã ã‹
        };
      });

      // åˆè¨ˆè·é›¢ãŒçŸ­ã„é †ã«ã‚½ãƒ¼ãƒˆ
      rows.sort((a,b)=>a.meters - b.meters);

      renderLinearResults(rows);
    }catch(e){
      alert('ç›´ç·šè·é›¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼: ' + (e.message || e));
      console.error(e);
    }
  };

  if(csvBtn){
    csvBtn.onclick = ()=> downloadLinearCsv();
  }
}

// åˆæœŸåŒ–æ™‚ã«ãƒã‚¤ãƒ³ãƒ‰
//window.addEventListener('DOMContentLoaded', bindLinearButtonsOnce);


// ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã«1åœ°ç‚¹ãšã¤é¸ã¶å…¨çµ„ã¿åˆã‚ã›ã‚’åˆ—æŒ™ï¼ˆä¸Šé™ã‚ã‚Šï¼‰
function enumerateCombinations(poiGroups, perGroupLimit = 3){
  const groups = poiGroups.map(arr => (arr || []).slice(0, perGroupLimit));
  const combos = [];

  function dfs(i, acc){
    if (i === groups.length){
      combos.push(acc.slice());
      return;
    }
    const g = groups[i];
    if (!g.length){
      acc.push(null);
      dfs(i+1, acc);
      acc.pop();
      return;
    }
    for (const p of g){
      acc.push(p);
      dfs(i+1, acc);
      acc.pop();
    }
  }

  dfs(0, []);
  return combos;
}

// çµ„ã¿åˆã‚ã›ãƒ«ãƒ¼ãƒˆã®ãƒ¬ã‚°çµ±è¨ˆã‚’å–å¾—ï¼ˆORSå‘¼ã³å‡ºã—ï¼‰
async function routeLegStatsForWaypoints(wps, profile){
  const body = { coordinates: wps.map(p=>[p.lon,p.lat]), elevation:true, extra_info:['steepness'], preference:'fastest' };
  const feature = (await dir(body, profile)).features[0];
  const mass=75, flat=18;
  const stats = await calcLegStats(feature, mass, flat);
  return { feature, stats };
}

// ãƒ«ãƒ¼ãƒˆã®ç´¯ç©è·é›¢[m]/æ™‚é–“[s]/ã‚¨ãƒãƒ«ã‚®ãƒ¼[kJ]ã‚’æ§‹ç¯‰
function buildCums(feature, mass=75, flat=18){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length>=3;
  const segs   = feature.properties.segments||[];
  const cum = { D:[0], T:[0], E:[0] };
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, t=st.duration||0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cum.D.push(cum.D.at(-1)+d);
      cum.T.push(cum.T.at(-1)+t);
      cum.E.push(cum.E.at(-1)+dE);
    }
  }
  return {cum, coords};
}

// POIã‚’ãƒ«ãƒ¼ãƒˆæŠ˜ã‚Œç·šã¸å°„å½±ã—ã€ãã®åœ°ç‚¹ã®ç´¯ç©å€¤ã‚’å†…æŒ¿ã§å–å¾—
function projectToRoute(lat,lon, coords, cum){
  let best={i0:0,i1:1,frac:0,dist:Infinity, stepIdx:1};
  let stepIdx=1;
  for(let i=1;i<coords.length;i++, stepIdx++){
    const A=L.latLng(coords[i-1][1],coords[i-1][0]);
    const B=L.latLng(coords[i][1],  coords[i][0]);
    const P=L.latLng(lat,lon);
    const AB=[B.lat-A.lat, B.lng-A.lng];
    const AP=[P.lat-A.lat, P.lng-A.lng];
    const ab2=AB[0]*AB[0]+AB[1]*AB[1]||1e-12;
    let t=(AP[0]*AB[0]+AP[1]*AB[1])/ab2; t=Math.max(0,Math.min(1,t));
    const Q=L.latLng(A.lat+AB[0]*t, A.lng+AB[1]*t);
    const d=P.distanceTo(Q);
    if(d<best.dist){ best={i0:i-1,i1:i,frac:t,dist:d, stepIdx:i}; }
  }
  const i = best.stepIdx;
  const lerp=(arr)=>{ const v0=arr[i-1], v1=arr[i]??v0; return v0 + (v1-v0)*best.frac; };
  return { cumD:lerp(cum.D), cumT:lerp(cum.T), cumE:lerp(cum.E), perpM: best.dist };
}

/* ===== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼šå€™è£œæ¤œæŸ»ï¼†æœªæ¡ç”¨ã®å¼·åˆ¶è£œä¿® ===== */

// iç•ªç›®ãƒˆãƒªã‚¬ãƒ¼ã«æœ‰åŠ¹å€™è£œ(_proj.cumDãŒæœ‰é™)ãŒã‚ã‚‹ã‹ï¼Ÿ
function hasValidCand(restGroups, i){
  const g = restGroups[i];
  if (!g) return false;
  const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
  return valid.length > 0;
}

// æœªæ¡ç”¨(null)ã‚’æ®‹ã•ãªã„ãŸã‚ã®è£œä¿®ï¼š
// å€™è£œãŒã‚ã‚‹ãƒˆãƒªã‚¬ãƒ¼ã§ã¯ã€ç­‰é–“éš”ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«æœ€ã‚‚è¿‘ã„å€™è£œã§ç©´åŸ‹ã‚ã™ã‚‹
function repairNullPicks(restGroups, cumTotals, picks){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;
  if (!R || !Number.isFinite(totalD) || totalD <= 0) return picks;

  const out = picks.slice();
  for (let i = 0; i < R; i++){
    if (out[i]) continue;                        // æ—¢ã«æ¡ç”¨æ¸ˆã¿
    if (!hasValidCand(restGroups, i)) continue;  // ç‰©ç†çš„ã«å€™è£œãªã—ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—

    const g = restGroups[i];
    const target = totalD * (i + 1) / (R + 1);
    const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    if (!valid.length) continue;

    valid.sort((a,b)=>Math.abs(a._proj.cumD - target) - Math.abs(b._proj.cumD - target));
    out[i] = valid[0];
  }
  return out;
}

// ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒã‚’1å›å®Ÿè¡Œã—ã¦çµæœé…åˆ—ã‚’è¿”ã™ï¼ˆUIã«ã¯ã¾ã è¡¨ç¤ºã—ãªã„ï¼‰
function runBeamSearchOnce(restGroups, cumTotals) {
  const triggersWithCand = (restGroups || []).reduce((n, g) => {
    const valid = (g?.pois || []).filter(
      p => p && p._proj && Number.isFinite(p._proj.cumD)
    );
    return n + (valid.length ? 1 : 0);
  }, 0);

  const top = beamSearch(
    restGroups,
    cumTotals,
    /*width*/ 3,
    /*minRest*/ triggersWithCand,
    /*nullPenalty*/ 1e6,
    /*forbidNullWhenCand*/ true
  );

  // è¡¨ç¤ºç”¨ã« picks/picksByTrigger ã‚’æ•´å½¢ã—ã¦è¿”ã™
  return top.map(t => ({
    score: t.score,
    stats: t.stats,
    picksByTrigger: t.picksByTrigger,
    picks: t.picksByTrigger.filter(Boolean)
  }));
}

async function viterbiRouteCost(p1, p2, profile){
  const coords = [[p1.lon,p1.lat], [p2.lon,p2.lat]];
  const res = await orsDirections(coords, profile);

  const dist = res.features[0].properties.summary.distance;
  const time = res.features[0].properties.summary.duration;
  const elev = res.features[0].properties.ascent;  // æ¨™é«˜å·®

  const energy = energyFromRoute(res); // kJè¨ˆç®—

  return { dist, time, energy };
}

/* ===== ã€ä¿®æ­£ç‰ˆã€‘ç·å½“ãŸã‚Š (åŒºé–“å˜ä½ã§æ­£ã—ãè©•ä¾¡ã™ã‚‹ç‰ˆ) ===== */
async function runBruteforceOnce(start, goal, restGroups, profile){
  // ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã® POI ã‚’å–å¾—
  const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
  const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);

  // çµ„ã¿åˆã‚ã›ä½œæˆ
  const combos = enumerateCombinations(poiGroups, perGroupLimit);
  if (!combos.length) {
    throw new Error('çµ„ã¿åˆã‚ã›å€™è£œãŒä½œã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚');
  }

  // ç†æƒ³è·é›¢ï¼ˆä¾‹: å…¨ä½“100km Ã· 4åŒºé–“ = 25kmï¼‰
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg; 

  const results = [];
  let okCount = 0;
  let failCount = 0;

  for (const cmb of combos){
    const picks = cmb.filter(Boolean);
    const wps = [start, ...picks, goal].map(p => ({
      lat: p.lat, lon: p.lon, name: p.name || 'POI'
    }));

    try {
      // APIå‘¼ã³å‡ºã—ï¼ˆä¸€æ‹¬è¨ˆç®—ï¼‰
      const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);

      let distScore = 0;
      
      // â–¼â–¼â–¼â–¼â–¼ ã“ã“ãŒä¿®æ­£ã®æ ¸å¿ƒ â–¼â–¼â–¼â–¼â–¼
      // stats(ç´°ã‹ã„ã‚¹ãƒ†ãƒƒãƒ—)ã§ã¯ãªãã€feature.properties.segments(åŒºé–“)ã‚’ä½¿ã†
      const segments = feature?.properties?.segments || [];
      
      if (segments.length > 0) {
        let sumSq = 0;
        segments.forEach(seg => {
          // APIã®å˜ä½ã¯ãƒ¡ãƒ¼ãƒˆãƒ«ãªã®ã§ km ã«ç›´ã™
          const dKm = (Number(seg.distance) || 0) / 1000;
          
          // (åŒºé–“è·é›¢ - ç†æƒ³è·é›¢) ã®äºŒä¹—
          const diff = dKm - idealDistPerLeg;
          sumSq += diff * diff;
        });
        // å¹³å‡äºŒä¹—èª¤å·® (MSE)
        distScore = sumSq / segments.length;

      } else {
        // ä¸‡ãŒä¸€ segments ãŒãªã„å ´åˆï¼ˆåŸºæœ¬ã‚ã‚Šãˆãªã„ãŒå¿µã®ãŸã‚ï¼‰
        distScore = Infinity;
      }
      // â–²â–²â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²â–²â–²

      const score = distScore;
      const rawScore = distScore;

      results.push({
        score,        // ã“ã‚Œã§æ­£ã—ã„ã€Œè·é›¢ã®ãƒãƒ©ã¤ãå…·åˆã€ã«ãªã‚Šã¾ã™
        rawScore,
        feature,
        picks,
        picksByTrigger: cmb,
        stats
      });
      okCount++;
    } catch (e){
      console.warn('runBruteforceOnce: combo route fail', e);
      failCount++;
    }
  }

  // ã‚¹ã‚³ã‚¢ãŒè‰¯ã„ï¼ˆå°ã•ã„ï¼‰é †ã«ä¸¦ã¹ã‚‹
  results.sort((a,b)=>a.score - b.score);

  console.log('[runBruteforceOnce] ok=', okCount, ' fail=', failCount, ' results=', results.length);

  return results;
}
  
// ======================================================
// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°æœ¬ä½“
//   - ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆã‚¼ãƒ­APIï¼‰
//   - ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ï¼‰
//   - ç›´ç·šè·é›¢ï¼ˆå…¨çµ„åˆã›ãƒ»ã‚¼ãƒ­APIï¼‰
//   - Viterbiï¼ˆAPIåˆ©ç”¨ãƒ»DPï¼‰
//   - å¯¾ç­–A: Viterbi TopK â†’ ç·é‡MSEã§å†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆAPIï¼‰
//   - å¯¾ç­–B: Viterbiï¼ˆL1åŠ æ³•ãƒ»APIï¼‰
// ======================================================
// ======================================================
// ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°æœ¬ä½“ï¼ˆON/OFFåˆ‡æ›¿å¯¾å¿œï¼‰
// ======================================================
/* ======================================================
   ã€ä¿®æ­£ç‰ˆã€‘ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°æœ¬ä½“ï¼ˆAPIä¼‘æ†©ï¼†ã‚¨ãƒ©ãƒ¼å¯¾ç­–æ¸ˆã¿ï¼‰
   ====================================================== */
async function runAlgoCompareDebug(){
  const panel = $('algoComparePanel');
  panel.textContent = '';

  const tAll0 = performance.now();
  window.__algoCompareRows = [];

  // APIè² è·è»½æ¸›ç”¨ï¼šæŒ‡å®šãƒŸãƒªç§’å¾…æ©Ÿã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
  const waitApi = async (ms) => {
    panel.textContent += `(APIè² è·è»½æ¸›ã®ãŸã‚ ${ms/1000}ç§’ å¾…æ©Ÿä¸­...)\n`;
    await new Promise(r => setTimeout(r, ms));
  };

  try {
    if (!routeData || !routeData.fastest) {
      panel.textContent = 'å…ˆã«ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã§ãƒ«ãƒ¼ãƒˆï¼‹POIã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚';
      return;
    }
    if (!restGroups || !restGroups.length) {
      panel.textContent = 'ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';
      return;
    }

    ensureProjections();
    const cumTotals = window.__cumTotals;

    const start = pts.find(p => p.type === 'start') || pts[0];
    const goal  = pts.find(p => p.type === 'goal')  || pts[pts.length - 1];
    const profile = 'cycling-road';

    panel.textContent += '====== ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚° ======\n\n';

    // bf_rank ç”¨
    let bfList = [];
    let bfRankMap = null;

    // ----------------------------------------------------------
    // 1ï¼‰ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰ => bfRankMap ã‚’ä½œã‚‹
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_bf')) {
      panel.textContent += '\n--- ç·å½“ãŸã‚Šï¼ˆAPIå¤šã‚ãƒ»é«˜ç²¾åº¦ï¼‰ ---\n';
      {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        bfList = await runBruteforceOnce(start, goal, restGroups, profile);
        // â˜…é›†ç´„ãƒ­ã‚°é–‹å§‹
        window.__viterbiEdgeAgg = new Map();
        window.__viterbiAllEdgeRows = [];           
        window.__collectViterbiEdges = true;

        const t1 = performance.now();

        const ms = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
        panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n`;
        panel.textContent += `çµ„åˆã›æ•°: ${bfList.length} ä»¶\n\n`;

        bfRankMap = buildBfRankMap(bfList);
        attachBfRank(bfList, bfRankMap);

        showAlgoListInPanel(panel, bfList, 'bruteforce');
        pushAlgoResultsForCsv('bruteforce','ç·å½“ãŸã‚Š',bfList,ms,ors,ov);
      }
      // â˜…ç·å½“ãŸã‚Šã®å¾Œã¯ç–²ã‚Œã¦ã„ã‚‹ã®ã§é•·ã‚ã«ä¼‘ã‚€
      await waitApi(10000);

    } else {
      panel.textContent += '\n--- ç·å½“ãŸã‚Šï¼šOFFï¼ˆbf_rankæœªè¨ˆç®—ï¼‰ ---\n';
    }

    // ----------------------------------------------------------
    // 2ï¼‰ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆã‚¼ãƒ­APIï¼‰
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_beam')) {
      panel.textContent += '\n--- ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ãƒ»ã‚¼ãƒ­APIï¼‰ ---\n';
      {
        const orsBefore = API_USED.orsTotal; // å¿µã®ãŸã‚
        const t0 = performance.now();
        const beamList = runBeamSearchOnce(restGroups, cumTotals);
        const t1 = performance.now();

        const ms = t1 - t0;
        // APIå›æ•°ã¯0ã®ã¯ãšã ãŒå·®åˆ†ã‚’å–ã‚‹
        const ors = API_USED.orsTotal - orsBefore;

        attachBfRank(beamList, bfRankMap);

        panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n\n`;

        showAlgoListInPanel(panel, beamList, 'beam3');
        pushAlgoResultsForCsv('beam3','ãƒ“ãƒ¼ãƒ ã‚µãƒ¼ãƒï¼ˆå¹…3ï¼‰',beamList.slice(0,3),ms,ors,0);
      }
      // ã‚¼ãƒ­APIãªã®ã§å¾…æ©Ÿä¸è¦
    }

    // ----------------------------------------------------------
    // 3ï¼‰ç›´ç·šè·é›¢ï¼ˆå…¨çµ„åˆã›ãƒ»ã‚¼ãƒ­APIï¼‰
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_linear')) {
      panel.textContent += '\n--- ç›´ç·šè·é›¢ï¼ˆå…¨çµ„ã¿åˆã‚ã›ãƒ»ã‚¼ãƒ­APIï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const t0 = performance.now();
        const groups = topPoisPerTriggerForLinear(5);

        if (!groups || !groups.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          const linearRows = buildLinearAlgoRows(start, goal, groups);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;

          window.__linearResults = linearRows;
          attachBfRank(linearRows, bfRankMap);

          panel.textContent += `çµ„åˆã›æ•°: ${linearRows.length} ä»¶\n`;
          panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n\n`;

          showAlgoListInPanel(panel, linearRows.slice(0, 3), 'linear');
          pushAlgoResultsForCsv('linear','ç›´ç·šè·é›¢ï¼ˆå…¨çµ„åˆã›ï¼‰',linearRows,ms,ors,0);
        }
      } catch (e) {
        console.error('[linear] error', e);
        panel.textContent += '\n[ç›´ç·šè·é›¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // ã‚¼ãƒ­APIãªã®ã§å¾…æ©Ÿä¸è¦
    }

    // ----------------------------------------------------------
    // 4ï¼‰Viterbiï¼ˆAPIåˆ©ç”¨ãƒ»DPï¼šMSEã®ã¿ï¼‰
    // ----------------------------------------------------------
    // å¤‰æ•° vitGroups ã‚’å¤–ã§ã‚‚å‚ç…§ã§ãã‚‹ã‚ˆã†ã«å®£è¨€ã—ã¦ãŠã
    let vitGroups = null;

    if (isAlgoEnabled('dbg_vit')) {
      panel.textContent += '\n--- Viterbiï¼ˆAPIåˆ©ç”¨ãƒ»DPï¼šMSEã®ã¿ï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const capPerTrigger = Math.max(1, Number($('poiLimit')?.value) || 5);
        vitGroups = makeCandGroupsFromRestGroups(restGroups, capPerTrigger);

        if (!vitGroups || !vitGroups.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          const t0 = performance.now();
          const vitList = await runViterbiOnce_API(start, goal, vitGroups, profile);
          
          // â˜…é›†ç´„ãƒ­ã‚°åœæ­¢ï¼†ç¢ºå®š
          window.__collectViterbiEdges = false;
          window.__viterbiAllEdgeRows = Array.from(window.__viterbiEdgeAgg.values()).map(x=>{
            const n = Math.max(1, x.count);
            return {
              fromIdx: x.fromIdx, toIdx: x.toIdx,
              fromName: x.fromName, toName: x.toName,
              fromLat: x.fromLat, fromLon: x.fromLon,
              toLat: x.toLat, toLon: x.toLon,
              count: x.count,
              energyKj: x.sumEnergyKj / n,
              distKm: x.sumDistKm / n,
              timeMin: x.sumTimeMin / n,
              cost: x.sumCost / n,
              idealEnergyKj: x.idealEnergyKj
            };
          });

          const t1 = performance.now();
          const ms  = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!vitList || !vitList.length) {
            panel.textContent += '(å€™è£œãªã—)\n';
          } else {
            attachBfRank(vitList, bfRankMap);
            panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
            panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

            showAlgoListInPanel(panel, vitList, 'viterbi');
            pushAlgoResultsForCsv('viterbi','Viterbiï¼ˆAPIãƒ»DPï¼šMSEã®ã¿ï¼‰',vitList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi] error', e);
        panel.textContent += '\n[viterbi ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 5ï¼‰å¯¾ç­–Aï¼šTopKå¢— + beamWidthå¢—ï¼ˆå†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼‰
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_A')) {
      panel.textContent += '\n--- å¯¾ç­–Aï¼šViterbi TopKâ†’ç·é‡MSEå†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆAPIï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const groupsA = makeCandGroupsFromRestGroups(restGroups, 5, defaultLinearSorter);

        if (!groupsA || !groupsA.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          const t0 = performance.now();
          const aOpt  = getAbViterbiOpt();
          const aList = await runViterbiTopK_Rerank_All_API(start, goal, groupsA, profile, aOpt);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!aList || !aList.length) {
            panel.textContent += '(å€™è£œãªã—)\n';
          } else {
            attachBfRank(aList, bfRankMap);
            panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
            panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

            showAlgoListInPanel(panel, aList.slice(0,3), 'viterbi_topk_rerank');
            pushAlgoResultsForCsv(
              'viterbi_topk_rerank',
              'å¯¾ç­–Aï¼šViterbi TopKâ†’ç·é‡MSEå†ãƒ©ãƒ³ã‚­ãƒ³ã‚°',
              aList, ms, ors, ov
            );
          }
        }
      } catch (e) {
        console.error('[viterbi_topk_rerank] error', e);
        panel.textContent += '\n[å¯¾ç­–A ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 6ï¼‰å¯¾ç­–Bï¼šA + é‡è¤‡æ’é™¤ï¼ˆå†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼‰
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_B')) {
      panel.textContent += '\n--- å¯¾ç­–Bï¼šViterbiï¼ˆL1åŠ æ³•ãƒ»APIï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const groupsB = makeCandGroupsFromRestGroups(restGroups, 5, defaultLinearSorter);

        if (!groupsB || !groupsB.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          const t0 = performance.now();
          const bOpt  = getAbViterbiOpt();
          const bList = await runViterbiTopK_Rerank_All_API_Dedupe(start, goal, groupsB, profile, bOpt);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!bList || !bList.length) {
            panel.textContent += '(å€™è£œãªã—)\n';
          } else {
            attachBfRank(bList, bfRankMap);
            panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
            panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

            showAlgoListInPanel(panel, bList.slice(0,3), 'viterbi_l1');
            pushAlgoResultsForCsv('viterbi_l1','å¯¾ç­–Bï¼šViterbiï¼ˆL1åŠ æ³•ï¼‰',bList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi_l1] error', e);
        panel.textContent += '\n[å¯¾ç­–B ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 7ï¼‰å¯¾ç­–C
    // ----------------------------------------------------------
    // å¤‰æ•° groupsC ã‚’å¤–ã§ã‚‚å‚ç…§ã§ãã‚‹ã‚ˆã†ã«å®£è¨€
    let groupsC = null;

    if (isAlgoEnabled('dbg_C')) {
      panel.textContent += '\n--- å¯¾ç­–Cï¼šViterbiï¼ˆç«¯é™¤å¤– + ç«¯ãƒˆãƒªã‚¬ãƒ¼æ¡ä»¶çµŒç”±ï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const capPerTrigger = Math.max(1, Number($('poiLimit')?.value) || 5);
        groupsC = makeCandGroupsFromRestGroups(restGroups, capPerTrigger)
          .map(g => Array.isArray(g) ? g.filter(Boolean) : [])
          .filter(g => g.length > 0);

        if (!groupsC || !groupsC.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          const t0 = performance.now();
          const cList = await runViterbiOnce_API_C_BeamFull(start, goal, groupsC, profile, {
            beamWidth: 12
          });
          const t1 = performance.now();
          const ms  = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!cList || !cList.length) {
            panel.textContent += '(å€™è£œãªã—)\n';
          } else {
            attachBfRank(cList, bfRankMap);
            panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
            panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

            showAlgoListInPanel(panel, cList, 'viterbi_c');
            pushAlgoResultsForCsv('viterbi_c','å¯¾ç­–Cï¼šç«¯é™¤å¤–Viterbi + ç«¯ãƒˆãƒªã‚¬ãƒ¼æ¡ä»¶çµŒç”±',cList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi_c] error', e);
        panel.textContent += '\n[å¯¾ç­–C ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 8ï¼‰å¯¾ç­–Dï¼šæ®µéšçš„ã«å›ºå®šè§£é™¤ã—ã¦Viterbi
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_D')) {
      panel.textContent += '\n--- å¯¾ç­–Dï¼šæ®µéšçš„ã«å›ºå®šè§£é™¤ã—ã¦Viterbi ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        const prog = await runViterbi_D_Progressive(start, goal, restGroups, profile, {
          capPerTrigger: 5,
          sorter: defaultLinearSorter
        });
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        const last = prog[prog.length - 1]?.best ? [prog[prog.length - 1].best] : [];

        panel.textContent += `æ®µéšæ•°: ${prog.length}\n`;
        panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
        panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

        if (last.length){
          attachBfRank(last, bfRankMap);
          showAlgoListInPanel(panel, last, 'viterbi_D_prog');
          pushAlgoResultsForCsv('viterbi_D_prog','å¯¾ç­–Dï¼šæ®µéšçš„å›ºå®šè§£é™¤Viterbi', last, ms, ors, ov);
        } else {
          panel.textContent += '(å€™è£œãªã—)\n';
        }
      } catch (e) {
        console.error('[viterbi_D_prog] error', e);
        panel.textContent += '\n[å¯¾ç­–D ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 9ï¼‰å¯¾ç­–Eï¼šViterbiï¼ˆ2ç‚¹DPï¼‰+åŒºé–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_E')) {
      panel.textContent += '\n--- å¯¾ç­–Eï¼šViterbiï¼ˆ2ç‚¹DP + åŒºé–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        if (window.__legCache && typeof window.__legCache.clear === 'function'){
          window.__legCache.clear();
        } else if (typeof __legCache !== 'undefined' && __legCache?.clear){
          __legCache.clear();
        }

        const capPerTrigger = Math.max(1, Number($('poiLimit')?.value) || 5);
        const groupsE = makeCandGroupsFromRestGroups(restGroups, capPerTrigger);

        const t0 = performance.now();
        const eList = await runViterbiOnce_API_E_Cached(start, goal, groupsE, profile);
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!eList || !eList.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          attachBfRank(eList, bfRankMap);
          panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
          panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

          showAlgoListInPanel(panel, eList, 'viterbi_E_cache');
          pushAlgoResultsForCsv('viterbi_E_cache','å¯¾ç­–Eï¼šViterbiï¼ˆ2ç‚¹DP + ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰',eList,ms,ors,ov);
        }
      } catch (e) {
        console.error('[viterbi_E_cache] error', e);
        panel.textContent += '\n[å¯¾ç­–E ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

    // ----------------------------------------------------------
    // 10ï¼‰å¯¾ç­–Fï¼šTopKå€™è£œâ†’ä¸€æ°—ã«çµŒç”±åœ°ä»˜ãORSã§å†è©•ä¾¡ï¼ˆå…¨ä»¶ï¼‰
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_F')) {
      panel.textContent += '\n--- å¯¾ç­–Fï¼šTopKå€™è£œâ†’ä¸€æ°—ã«çµŒç”±åœ°ä»˜ãORSã§å†è©•ä¾¡ ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const capPerTrigger = Math.max(1, Number($('poiLimit')?.value) || 5);
        const groupsF = makeCandGroupsFromRestGroups(restGroups, capPerTrigger, defaultLinearSorter);

        const t0 = performance.now();
        const fOpt = getAbViterbiOpt();
        const fList = await runViterbi_F_TopN_ThenFullORS(start, goal, groupsF, profile, fOpt);
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!fList || !fList.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          attachBfRank(fList, bfRankMap);
          panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
          panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

          showAlgoListInPanel(panel, fList.slice(0,3), 'viterbi_F_fullrerank');
          pushAlgoResultsForCsv('viterbi_F_fullrerank','å¯¾ç­–Fï¼šTopKâ†’ä¸€æ°—ã«ORSå†è©•ä¾¡',fList,ms,ors,ov);
        }
      } catch (e) {
        console.error('[viterbi_F_fullrerank] error', e);
        panel.textContent += '\n[å¯¾ç­–F ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      // â˜…APIä¼‘æ†©
      await waitApi(3000);
    }

/* ---------- ã€ä¿®æ­£ç‰ˆã€‘å¯¾ç­–G: SGæ’é™¤ + Viterbi (UIè¡¨ç¤ºãƒ»é †ä½å¯¾å¿œ) ---------- */
    if (isAlgoEnabled('dbg_G') || true) { 
      // è¦‹å‡ºã—ã‚’è¡¨ç¤º
      panel.textContent += '\n--- å¯¾ç­–Gï¼šSGæ’é™¤ + Viterbi (è·é›¢MSE) ---\n';

      const orsBefore = API_USED.orsTotal;
      const ovpBefore = API_USED.overpassTotal;
      const t0 = performance.now();

      try {
        // 1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ãªã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ±ºã‚ã‚‹
        let targetGroups = null;

        if (typeof groupsC !== 'undefined' && groupsC && groupsC.length) {
          targetGroups = groupsC;
        } else if (typeof vitGroups !== 'undefined' && vitGroups && vitGroups.length) {
          targetGroups = vitGroups;
        } else {
          const cap = Math.max(1, Number($('poiLimit')?.value) || 5);
          targetGroups = makeCandGroupsFromRestGroups(restGroups, cap);
        }

        // 2. å®Ÿè¡Œ
        const gList = await solveMeasureG(start, goal, targetGroups, profile);
        
        const t1 = performance.now();
        const ms = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!gList || !gList.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          // â˜…è¿½åŠ 1: ç·å½“ãŸã‚Šçµæœ(bfRankMap)ã¨ã®ç…§åˆã‚’è¡Œã„ã€é †ä½ã‚’ä»˜ä¸ã™ã‚‹
          attachBfRank(gList, bfRankMap);

          // â˜…è¿½åŠ 2: å‡¦ç†æ™‚é–“ãªã©ã‚’ãƒ‘ãƒãƒ«ã«è¡¨ç¤º
          panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
          panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

          // â˜…è¿½åŠ 3: çµæœãƒªã‚¹ãƒˆã‚’ãƒ‘ãƒãƒ«ã«è¡¨ç¤º (ã“ã‚Œã§ä»–ã®ã¨åŒã˜è¦‹ãŸç›®ã«ãªã‚Šã¾ã™)
          showAlgoListInPanel(panel, gList.slice(0, 3), 'measure_G');

          // CSVç”¨ãƒ‡ãƒ¼ã‚¿è“„ç©
          pushAlgoResultsForCsv('G', 'SGæ’é™¤+Viterbi', gList, ms, ors, ov);
        }

      } catch (e) {
        console.error('Algo G fail:', e);
        panel.textContent += '\n[å¯¾ç­–G ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      
      // â˜…APIä¼‘æ†©
      if(typeof waitApi === 'function') await waitApi(5000); 
    }

    /* ---------- ã€è¿½åŠ ã€‘å¯¾ç­–H: SGæ’é™¤ + Viterbi (DPå®Œå…¨ç‰ˆ) ---------- */
    if (isAlgoEnabled('dbg_H')) { 
      panel.textContent += '\n--- å¯¾ç­–Hï¼šSGæ’é™¤ + Viterbi (å„POIæœ€é©ç¶­æŒ) ---\n';

      const orsBefore = API_USED.orsTotal;
      const ovpBefore = API_USED.overpassTotal;
      const t0 = performance.now();

      try {
        // ã‚°ãƒ«ãƒ¼ãƒ—æº–å‚™ï¼ˆGã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
        let targetGroups = null;
        if (typeof groupsC !== 'undefined' && groupsC && groupsC.length) {
          targetGroups = groupsC;
        } else if (typeof vitGroups !== 'undefined' && vitGroups && vitGroups.length) {
          targetGroups = vitGroups;
        } else {
          const cap = Math.max(1, Number($('poiLimit')?.value) || 5);
          targetGroups = makeCandGroupsFromRestGroups(restGroups, cap);
        }

        // å®Ÿè¡Œ
        const hList = await solveMeasureH(start, goal, targetGroups, profile);
        
        const t1 = performance.now();
        const ms = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!hList || !hList.length) {
          panel.textContent += '(å€™è£œãªã—)\n';
        } else {
          attachBfRank(hList, bfRankMap);

          panel.textContent += `å‡¦ç†æ™‚é–“: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORSå‘¼ã³å‡ºã—: ${ors} å›\n`;
          panel.textContent += `Overpasså‘¼ã³å‡ºã—: ${ov} å›\n\n`;

          showAlgoListInPanel(panel, hList.slice(0, 3), 'measure_H');
          pushAlgoResultsForCsv('H', 'SGæ’é™¤+Viterbi(DP)', hList, ms, ors, ov);
        }

      } catch (e) {
        console.error('Algo H fail:', e);
        panel.textContent += '\n[å¯¾ç­–H ã‚¨ãƒ©ãƒ¼] ' + (e.message || e) + '\n';
      }
      
      // APIä¼‘æ†©
      if(typeof waitApi === 'function') await waitApi(5000); 
    }

    // ----------------------------------------------------------
    // å…¨ä½“æ™‚é–“
    // ----------------------------------------------------------
    const totalMs = performance.now() - tAll0;
    panel.textContent += `\n====== å…¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å‡¦ç†æ™‚é–“: ${totalMs.toFixed(1)} ms ======\n`;

  } catch (err) {
    console.error('[runAlgoCompareDebug] ã‚¨ãƒ©ãƒ¼', err);
    panel.textContent += '\n[runAlgoCompareDebug ã‚¨ãƒ©ãƒ¼] ' + (err.message || err);
  }
}
  
function ensureProjections() {
  const base = routeData.arterial || routeData.fastest;
  // ãƒ«ãƒ¼ãƒˆæƒ…å ±ã‚„ä¼‘æ†©ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
  if (!base || !Array.isArray(restGroups) || !restGroups.length) return;

  // ãƒ«ãƒ¼ãƒˆä¸Šã®ç´¯ç©ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
  const { cum, coords } = buildCums(base);

  window.__routeCums = { cum, coords };
  window.__cumTotals = {
    D: cum.D.at(-1),
    T: cum.T.at(-1),
    E: cum.E.at(-1)
  };

  // å„ä¼‘æ†©ã‚°ãƒ«ãƒ¼ãƒ—ã® POI ã«å°„å½±ãƒ‡ãƒ¼ã‚¿ã‚’ä»˜ã‘ã‚‹
for (let ti = 0; ti < restGroups.length; ti++){
  const g = restGroups[ti];
  const arr = g?.pois || [];

  for (let pi = 0; pi < arr.length; pi++){
    const p = arr[pi];
    if (!p) continue;

    
    // â˜…è¿½åŠ ï¼šå®‰å®šIDã‚’åŸ‹ã‚è¾¼ã‚€ï¼ˆæ¯å›åŒã˜POIã«åŒã˜IDãŒä»˜ãï¼‰
    p._triggerId = ti;
    p._poiIdInTrigger = pi;
    // â˜…ã“ã“ã§ã€Œåå‰ãŒç„¡ã‘ã‚Œã°è‡ªå‹•å‘½åã€
    ensurePoiName(p, ti, pi);

    // æ—¢ã« _proj ãŒã‚ã‚Š cumD ãŒæœ‰é™å€¤ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
    if (p._proj && Number.isFinite(p._proj.cumD)) continue;

    // _proj ã‚’è¨ˆç®—ã—ã¦ä»˜ä¸
    p._proj = projectToRoute(p.lat, p.lon, coords, cum);
  }
}
  console.log("[ensureProjections] å°„å½±ã‚’å†è¨ˆç®—ã—ã¾ã—ãŸ");
}

// å¹¹ç·šåº¦ï¼ˆå¤§ãã„ã»ã©â€œå¹¹ç·šã£ã½ã„â€ï¼‰
// ã“ã“ã§ã¯ã€Œè·é›¢ãŒé•·ãã¦å¹³å‡é€Ÿåº¦ãŒé«˜ã„ï¼å¹¹ç·šã£ã½ã„ã€ã¨ã„ã†å˜ç´”ãªæŒ‡æ¨™ã«ã—ã¦ã„ã¾ã™ã€‚
function arterialScore(feature){
  if (!feature || !feature.properties || !feature.properties.summary) {
    return -Infinity;
  }

  const sum = feature.properties.summary;
  const distM = Number(sum.distance) || 0;   // m
  const timeS = Number(sum.duration) || 1;   // sï¼ˆ0é™¤ç®—ã‚’é¿ã‘ã‚‹ãŸã‚ 1 ã§ä¿é™ºï¼‰

  const distKm   = distM / 1000;
  const timeH    = timeS / 3600;
  const avgSpeed = distKm / timeH;           // km/h ç›¸å½“

  // ãƒ»å¹³å‡é€Ÿåº¦ãŒé«˜ã„ã»ã©ãƒ—ãƒ©ã‚¹
  // ãƒ»ã‚ã‚‹ç¨‹åº¦ã®è·é›¢ãŒã‚ã‚‹ã»ã©ãƒ—ãƒ©ã‚¹
  // â†’ å¹¹ç·šé“è·¯ã‚’é•·ãèµ°ã‚‹ãƒ«ãƒ¼ãƒˆã»ã©ã‚¹ã‚³ã‚¢ãŒå¤§ãããªã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸
  return avgSpeed * distKm;
}

// ä¸Šä½3ä»¶ã‚«ãƒ¼ãƒ‰ã®ã€Œã“ã®çµ„ã¿åˆã‚ã›ã§ãƒ«ãƒ¼ãƒˆè¡¨ç¤ºã€ã‹ã‚‰å‘¼ã°ã‚Œã‚‹
async function showLinearComboRoute(row){
  if (!row || !Array.isArray(row.picks)) {
    throw new Error('ä¸æ­£ãªè¡Œãƒ‡ãƒ¼ã‚¿');
  }

  const { start, goal } = getStartGoalPoints();
  const profile = document.getElementById('profileSelect')?.value || 'cycling-road';

  // çµŒç”±é †ã¯ã€Œãƒˆãƒªã‚¬ãƒ¼é †ã® picks ã‚’ãã®ã¾ã¾ã€
  const wps = [start, ...row.picks, goal].map(p => ({
    lat: p.lat,
    lon: p.lon,
    name: p.name || 'POI'
  }));

  // ORSã§ãƒ«ãƒ¼ãƒˆç”Ÿæˆï¼ˆæ—¢å­˜ãƒ˜ãƒ«ãƒ‘ã‚’å†åˆ©ç”¨ï¼‰
  const out = await routeLegStatsForWaypoints(wps, profile);
  const feature = out?.feature;
  if (!feature) {
    throw new Error('ORS ãƒ«ãƒ¼ãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  // æ—¢å­˜ãƒ¬ã‚¤ãƒ¤ã‚’ã‚¯ãƒªã‚¢ã—ã¦æç”»
  clearRouteLayers();
  const layer = L.geoJSON(feature, {
    style: { color: '#0096ff', weight: 7 }
  }).addTo(map);
  routeLayers['linearTopRoute'] = layer;

  // æ¡ç”¨POIï¼†Start/Goalã®ãƒãƒ¼ã‚«ãƒ¼ã‚’è¨­å®šï¼ˆæ—¢å­˜é–¢æ•°ï¼‰
  setComboMarkers(start, row.picks, goal);

  // åã¾ã‚Šèª¿æ•´ï¼ˆgetBounds ã¯ä¸€åº¦ã ã‘å‘¼ã‚“ã§ã‹ã‚‰ isValid() ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
  const bounds = layer.getBounds?.();
  if (bounds && bounds.isValid && bounds.isValid()) {
    map.fitBounds(bounds.pad(0.1));
  } else {
    const fallback = row.picks[0] || start;
    if (fallback) {
      map.flyTo([fallback.lat, fallback.lon], 14);
    }
  }

  // ãƒ«ãƒ¼ãƒˆç¨®åˆ¥ãƒœã‚¿ãƒ³ã®ã€Œactiveã€ã‚’å…¨éƒ¨å¤–ã—ã¦ãŠãï¼ˆä»»æ„ï¼‰
  setActiveButton(null);
}

/* ===== ã€å¤‰æ›´ã€‘CSVå‡ºåŠ›ç”¨ãƒ‡ãƒ¼ã‚¿è“„ç©ï¼ˆè·é›¢MSEå¯¾å¿œï¼‰ ===== */
function pushAlgoResultsForCsv(algoCode, label, resultList, elapsedMs, orsCalls, overpassCalls){
  if (!Array.isArray(resultList) || !resultList.length) return;
  if (!Array.isArray(window.__algoCompareRows)) window.__algoCompareRows = [];

  // â˜…å¿µã®ãŸã‚ç†æƒ³å€¤ã‚’å–å¾—ï¼ˆsortResultsByUnifiedScoreå†…ã§ä½¿ã‚ã‚Œã¾ã™ï¼‰
  const ideals = getIdealPerLegs();

  // â˜…é‡è¦ï¼šã“ã“ã§ã€Œè·é›¢MSEã€ã®ã‚¹ã‚³ã‚¢ãŒè‰¯ã„é †ã«ä¸¦ã³æ›¿ãˆã‚‰ã‚Œã¾ã™
  // (sortResultsByUnifiedScore ãŒ unifiedScoreForCompare ã‚’å‘¼ã¶ãŸã‚)
  const sorted = sortResultsByUnifiedScore(resultList, null);

  sorted.forEach((r, idx)=>{
    const rank = idx + 1; // ã“ã‚ŒãŒExcelã®é †ä½ã«ãªã‚Šã¾ã™

    // çµ±è¨ˆå€¤ï¼ˆå‚è€ƒæƒ…å ±ã¨ã—ã¦å‡ºåŠ›ï¼‰
    const sigmaDist   = stdDev(r.stats && r.stats.dist ? r.stats.dist : []);
    const sigmaTime   = stdDev(r.stats && r.stats.time ? r.stats.time : []);
    const sigmaEnergy = stdDev(r.stats && r.stats.energy ? r.stats.energy : []);

    // â˜…å¤‰æ›´ï¼šCSVã«å‡ºã‚‹ã‚¹ã‚³ã‚¢ã‚‚ã€Œè·é›¢MSEã€ã§çµ±ä¸€
    const scoreForCsv = unifiedScoreForCompare(r, null);

    // POIåã®æ•´å½¢
    let poiList = (r.picks || r.picksByTrigger || []).filter(Boolean);
    if (Array.isArray(poiList[0])) poiList = poiList.flat().filter(Boolean);

    const poiNames = poiList.map(p => p.name || 'POI').join(' -> ');
    const poiLatLngs = poiList
      .map(p => `${(p.lat ?? p.latitude)?.toFixed(6)},${(p.lon ?? p.lng ?? p.longitude)?.toFixed(6)}`)
      .filter(Boolean)
      .join(' | ');

    window.__algoCompareRows.push({
      algo: algoCode,
      label,
      rank,                   // è·é›¢MSEé †ã®ãƒ©ãƒ³ã‚¯
      bfRank: (r.bfRank ?? ''), // ç·å½“ãŸã‚Šã§ã®ãƒ©ãƒ³ã‚¯ï¼ˆç·å½“ãŸã‚Šã‚‚è·é›¢MSEåŒ–æ¸ˆã¿ãªã‚‰OKï¼‰
      score: scoreForCsv,     // è·é›¢MSEã‚¹ã‚³ã‚¢
      rawScore: r.rawScore,
      sigmaDist,
      sigmaTime,
      sigmaEnergy,
      timeMs: elapsedMs ?? null,
      orsCalls,
      overpassCalls,
      poiNames,
      poiLatLngs
    });
  });
}
  
function showAlgoListInPanel(panel, list, algoCode){
  if (!panel) return;
  if (!Array.isArray(list) || !list.length){
    panel.textContent += '(å€™è£œãªã—)\n';
    return;
  }
  
  const MAX_SHOW = 3;
  const ideals = getIdealPerLegs();
  const sorted = sortResultsByUnifiedScore(list, ideals.idealEnergyPerLeg);
  const top = sorted.slice(0, MAX_SHOW);

  top.forEach((r, idx)=>{
    const rank = idx + 1;

    const score    = r.score    ?? null;
    const rawScore = r.rawScore ?? null;

    const stats   = r.stats || {};
    const distArr = Array.isArray(stats.dist)   ? stats.dist   : [];
    const timeArr = Array.isArray(stats.time)   ? stats.time   : [];
    const eneArr  = Array.isArray(stats.energy) ? stats.energy : [];

    const sigDist = distArr.length ? stdDev(distArr) : null;
    const sigTime = timeArr.length ? stdDev(timeArr) : null;
    const sigEn   = eneArr.length  ? stdDev(eneArr)  : null;

    const picksArr = (r.picks || r.picksByTrigger || []);
    const poiNames = picksArr
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    panel.textContent += `#${rank}  score=${score}\n`;
    if (rawScore != null) panel.textContent += `  rawScore=${rawScore}\n`;

    // â˜…è¿½åŠ ï¼šç·å½“ãŸã‚Šé †ä½
    if (r.bfRank != null) {
      panel.textContent += `  bf_rank=${r.bfRank}\n`;
    } else {
      panel.textContent += `  bf_rank=(åœå¤–/ä¸ä¸€è‡´)\n`;
    }

    if (sigDist != null) panel.textContent += `  Ïƒè·é›¢=${sigDist.toFixed(3)}\n`;
    if (sigTime != null) panel.textContent += `  Ïƒæ™‚é–“=${sigTime.toFixed(3)}\n`;
    if (sigEn   != null) panel.textContent += `  Ïƒã‚¨ãƒãƒ«ã‚®ãƒ¼=${sigEn.toFixed(3)}\n`;

    panel.textContent += `  POI: ${poiNames}\n\n`;
  });
}

function downloadAlgoCompareCsv(){
  const rows = window.__algoCompareRows || [];
  if (!rows.length){
    alert('å…ˆã«ã€Œã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æ¯”è¼ƒãƒ‡ãƒãƒƒã‚°ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }

  const header = [
    'algo',
    'label',
    'rank',
    'bf_rank',          // â˜…è¿½åŠ 
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'time_ms',
    'ors_calls',
    'overpass_calls',
    'poi_names',
    'poi_latlngs'
  ];

  const bodyRows = rows.map(r => [
    r.algo ?? '',
    `"${csvEscape(r.label ?? '')}"`,
    r.rank ?? '',
    r.bfRank ?? '',     // â˜…è¿½åŠ 
    r.score ?? '',
    r.rawScore ?? '',
    r.sigmaDist ?? '',
    r.sigmaTime ?? '',
    r.sigmaEnergy ?? '',
    r.timeMs ?? '',
    r.orsCalls ?? '',
    r.overpassCalls ?? '',
    `"${csvEscape(r.poiNames ?? '')}"`,
    `"${csvEscape(r.poiLatLngs ?? '')}"`
  ]);

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'algo_compare_debug.csv');
}

function renderBruteforceAllResults(results){
  const box = $('bruteforceAllList');
  const btn = $('btnDownloadBruteforceCsv');
  if (!box) return;

  if (!results || !results.length){
    box.textContent = 'ï¼ˆç·å½“ãŸã‚Šã®çµæœãŒã‚ã‚Šã¾ã›ã‚“ï¼‰';
    if (btn) btn.disabled = true;
    return;
  }

  if (btn) btn.disabled = false;

  window.__bruteforceAllResults = results;
  
  const lines = [];
  results.forEach((r, idx) => {
    const rank = idx + 1;
    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };
    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    lines.push(
      `#${rank} score=${(r.score ?? 0).toFixed(4)} raw=${(r.rawScore ?? r.score ?? 0).toFixed(4)} ` +
      `Ïƒd=${sig.dist.toFixed(2)}km Ïƒt=${sig.time.toFixed(2)}min ÏƒE=${sig.energy.toFixed(1)}kJ`
    );
    lines.push(
      `   picks: ${names}`
    );
  });

  box.textContent = lines.join('\n');
}

function downloadBruteforceCsv(){
  const rows = window.__bruteforceAllResults || [];
  if (!rows.length){
    alert('ç·å½“ãŸã‚ŠãŒã¾ã å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“');
    return;
  }

  const header = [
    'rank',
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'poi_names'
  ];

  const bodyRows = rows.map((r, idx) => {
    const rank = idx + 1;

    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };

    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    return [
      rank,
      r.score ?? '',
      r.rawScore ?? '',
      sig.dist.toFixed(3),
      sig.time.toFixed(3),
      sig.energy.toFixed(3),
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'bruteforce_all_combos.csv');
}

// ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ãƒ“ãƒ¼ãƒ ã‚’å…¨éƒ¨æ¶ˆã™
function clearRestBeams() {
  if (restBeamLayer) {
    restBeamLayer.clearLayers();
  }
}

// restGroups ã‚’ã‚‚ã¨ã«ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ãƒ“ãƒ¼ãƒ ã‚’å¼•ã
function drawRestBeams() {
  if (!restBeamLayer) return;
  if (!window.restGroups || !Array.isArray(window.restGroups)) return;

  // ã„ã£ãŸã‚“å…¨éƒ¨æ¶ˆã™
  clearRestBeams();

  window.restGroups.forEach(group => {
    if (!group) return;

    // group.rest ã«ã€Œä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ã®åœ°ç‚¹ã€ãŒå…¥ã£ã¦ã„ã‚‹æƒ³å®š
    const r = group.rest;
    const pois = group.pois || [];
    if (!r || !Array.isArray(pois) || !pois.length) return;

    const baseLat = Number(r.lat);
    const baseLon = Number(r.lon);
    if (!Number.isFinite(baseLat) || !Number.isFinite(baseLon)) return;

    const baseLL = L.latLng(baseLat, baseLon);

    pois.forEach(p => {
      if (!p) return;
      const lat = Number(p.lat);
      const lon = Number(p.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      const poiLL = L.latLng(lat, lon);

      // ãƒˆãƒªã‚¬ãƒ¼ â†” POI ã®ç›´ç·šï¼ˆé“ã®ã‚Šãƒ“ãƒ¼ãƒ ï¼‰
      const line = L.polyline([baseLL, poiLL], {
        color: 'orange',     // ãŠå¥½ã¿ã§
        weight: 2,
        opacity: 0.7,
        dashArray: '4,4'     // ç‚¹ç·šã£ã½ã
      });

      line.addTo(restBeamLayer);
    });
  });
}

// ---- å¯¾ç­–Aï¼šViterbié¢¨ï¼ˆAPIï¼‰ã§ TopK å€™è£œã‚’ä½œã‚‹ï¼ˆãƒ“ãƒ¼ãƒ ï¼‰ ----
async function runViterbiTopK_API(start, goal, restGroups, profile, opt = {}) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  // const beamWidth = Math.max(1, Number(opt.beamWidth) || 10); // å„ã‚¹ãƒ†ãƒƒãƒ—ã§æ®‹ã™æœ¬æ•°
  // const topK      = Math.max(1, Number(opt.topK) || 50);      // æœ€çµ‚å€™è£œæ•°
  const ap = autoBeamParams(restGroups, opt);
const beamWidth = ap.beamWidth;
const topK      = ap.topK;

// ãƒ‡ãƒãƒƒã‚°ã—ãŸã„ãªã‚‰ï¼ˆä»»æ„ï¼‰
console.log('[autoBeamParams]', ap);


  // ideal 1 legï¼ˆæ—¢å­˜ã¨åŒã˜ï¼‰
const ideals = getIdealPerLegs();
const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  // äº‹å‰ãƒã‚§ãƒƒã‚¯
  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  // beam state: {cost, idxes:[...], lastPoi}
  let beam = [];

  // step0: start -> group0
  for (let k = 0; k < Klist[0]; k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);
    const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
    beam.push({ cost: mse, idxes: [k], lastPoi: poi });
  }
  beam.sort((a,b)=>a.cost-b.cost);
  beam = beam.slice(0, beamWidth);

  // step t: group(t-1) -> group(t)
  for (let t = 1; t < T; t++){
    const next = [];
    const curGroup = restGroups[t];

    for (const st of beam){
      for (let j = 0; j < curGroup.length; j++){
        const toPoi = curGroup[j];
        const leg = await calcLegCostWithApi(st.lastPoi, toPoi, profile);
        const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
        next.push({ cost: st.cost + mse, idxes: [...st.idxes, j], lastPoi: toPoi });
      }
    }
    next.sort((a,b)=>a.cost-b.cost);
    beam = next.slice(0, beamWidth);
  }

  // last -> goal
  const finals = [];
  for (const st of beam){
    const leg = await calcLegCostWithApi(st.lastPoi, goal, profile);
    const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
    finals.push({ cost: st.cost + mse, idxes: st.idxes });
  }
  finals.sort((a,b)=>a.cost-b.cost);

  // idxes ã‹ã‚‰ picks ã‚’å¾©å…ƒã—ã¦è¿”ã™ï¼ˆã“ã“ã§ã¯ã¾ã  â€œè¿‘ä¼¼costâ€ï¼‰
  const cand = finals.slice(0, topK).map(x=>{
    const picksByTrigger = x.idxes.map((j, t)=> restGroups[t][j]);
    return {
      approxScore: x.cost,
      picksByTrigger,
      picks: picksByTrigger.filter(Boolean)
    };
  });

  return cand;
}

// ======================================================
// å…±é€šï¼šTopKå€™è£œï¼ˆrunViterbiTopK_APIã®è¿”ã‚Šå€¤ï¼‰ã‚’
// 1) é‡è¤‡æ’é™¤ï¼ˆä»»æ„ï¼‰
// 2) ORSã§ stats ã‚’ä½œã‚Šç›´ã—ã¦ energyMSE ã§å†è©•ä¾¡
// 3) ä¸¦ã¹æ›¿ãˆ
// 4) 1æœ¬è¿”ã™ or å…¨ä»¶è¿”ã™ ã‚’åˆ‡æ›¿
// ======================================================
async function rerankTopKCandsByExactScore(start, goal, candList, profile, opt = {}){
  const list = Array.isArray(candList) ? candList : [];
  if (!list.length) return [];

  const ideals = getIdealPerLegs();
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const doDedupe = !!opt.dedupe;
  const returnAll = !!opt.returnAll;

  // 1) é‡è¤‡æ’é™¤ï¼ˆä»»æ„ï¼‰
  let work = list;
  if (doDedupe){
    const seen = new Set();
    const uniq = [];
    for (const c of list){
      const key = comboKeyFromPicksByTrigger(c && c.picksByTrigger, 6);
      if (seen.has(key)) continue;
      seen.add(key);
      uniq.push(c);
    }
    work = uniq;
  }
  if (!work.length) return [];

  // 2) ORSã§æ­£ç¢ºãªstatsã‚’ä½œã£ã¦ energyMSE ã§å†è©•ä¾¡
  const rescored = [];
  for (const c of work){
    try{
      const picks = Array.isArray(c && c.picks) ? c.picks : [];
      const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
      const out = await routeLegStatsForWaypoints(wps, profile);
      const feature = out && out.feature ? out.feature : null;
      const stats = out && out.stats ? out.stats : null;

      const score = (stats ? routeEnergyMseFromStats(stats, idealEnergyPerLeg) : NaN);

      rescored.push({
        score: score,
        rawScore: c.approxScore,
        feature,
        stats,
        picks,
        picksByTrigger: c.picksByTrigger
      });
    }catch(e){
      console.warn('[rerankTopKCandsByExactScore] candidate fail', e);
    }
  }

  if (!rescored.length) return [];

  // 3) scoreã§ä¸¦ã¹æ›¿ãˆï¼ˆNaNã¯å¾Œã‚ã¸ï¼‰
  rescored.sort((a,b)=>{
    const sa = unifiedScoreForCompare(a, idealEnergyPerLeg);
    const sb = unifiedScoreForCompare(b, idealEnergyPerLeg);
    return sa - sb;
  });

  // 4) è¿”ã™å½¢ã‚’åˆ‡æ›¿
  return returnAll ? rescored : [rescored[0]];
}

// ---- å¯¾ç­–Aï¼šTopKã‚’ç·é‡MSEã§å†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã—ã¦ â€œ1æœ¬â€ ã ã‘è¿”ã™ ----
async function runViterbiTopK_Rerank_API(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: false,
    returnAll: false
  });
}
  
function legL1Cost(d, t, e, ideald, idealt, ideale){
  return Math.abs(d-ideald) + Math.abs(t-idealt) + Math.abs(e-ideale);
}

// â˜…è¿½åŠ ï¼šViterbi(DP)ã®åŒºé–“ã‚³ã‚¹ãƒˆã‚’ã€Œã‚¨ãƒãƒ«ã‚®ãƒ¼ã®ã¿(MSE)ã€ã«ã™ã‚‹
function legEnergyMseCost(energyKj, idealEnergyPerLeg){
  const e  = Number(energyKj);
  const ie = Number(idealEnergyPerLeg);
  if (!Number.isFinite(e) || !Number.isFinite(ie)) return Infinity;
  const de = e - ie;
  return de * de;
}

function recordViterbiEdge(row){
  if (!window.__collectViterbiEdges) return;

  // å—ã‘çš¿ï¼ˆé›†ç´„Mapï¼‰
  if (!window.__viterbiEdgeAgg) window.__viterbiEdgeAgg = new Map();

  // from/to ã®åŒä¸€åˆ¤å®šã‚­ãƒ¼ï¼ˆåŒä¸€çµ„ã¿åˆã‚ã›ã‚’1è¡ŒåŒ–ï¼‰
  // start/goal ã¯ idx ãŒ -1 ãªã®ã§åŒºåˆ¥å¯èƒ½
  const fromIdx = (row?.fromIdx ?? '');
  const toIdx   = (row?.toIdx ?? '');
  const fromName = row?.fromName ?? '';
  const toName   = row?.toName ?? '';

  const key = `${fromIdx}|${toIdx}|${fromName}|${toName}`;

  const cur = window.__viterbiEdgeAgg.get(key) || {
    fromIdx, toIdx,
    fromName, toName,
    fromLat: row?.fromLat ?? null,
    fromLon: row?.fromLon ?? null,
    toLat:   row?.toLat ?? null,
    toLon:   row?.toLon ?? null,

    count: 0,
    sumEnergyKj: 0,
    sumDistKm: 0,
    sumTimeMin: 0,
    sumCost: 0,
    // â–¼â–¼ è¿½åŠ : ç†æƒ³å€¤ã‚’ä¿å­˜ï¼ˆæœ€åˆã®1å›ç›®ã®å€¤ã‚’æ¡ç”¨ï¼‰ â–¼â–¼
    idealEnergyKj: row.idealEnergyPerLeg
  };

  cur.count += 1;

  const e = Number(row?.energyKj);
  if (Number.isFinite(e)) cur.sumEnergyKj += e;

  const d = Number(row?.distKm);
  if (Number.isFinite(d)) cur.sumDistKm += d;

  const tm = Number(row?.timeMin);
  if (Number.isFinite(tm)) cur.sumTimeMin += tm;

  // costã¯ã€ŒmseEnergyã€ãªã©ã€ã‚ãªãŸãŒä½¿ã„ãŸã„ä»£è¡¨å€¤ã‚’å…¥ã‚Œã‚‹
  // ã“ã“ã§ã¯ mseEnergy ã‚’ cost ã¨ã—ã¦é›†ç´„
  const c = Number(row?.mseEnergy ?? row?.cost);
  if (Number.isFinite(c)) cur.sumCost += c;

  window.__viterbiEdgeAgg.set(key, cur);
}

function legEnergyL1Cost(energyKj, idealEnergyPerLeg){
  const e  = Number(energyKj);
  const ie = Number(idealEnergyPerLeg);
  if (!Number.isFinite(e) || !Number.isFinite(ie)) return Infinity;
  return Math.abs(e - ie);
}
  
async function runViterbiOnce_API_L1(start, goal, restGroups, profile) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  const ideals = getIdealPerLegs();
const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  const dp=[], prev=[];
  for(let t=0;t<T;t++){
    dp[t]=new Array(Klist[t]).fill(Infinity);
    prev[t]=new Array(Klist[t]).fill(-1);
  }

  // start -> 0
  for (let k=0;k<Klist[0];k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);
    const c = legEnergyL1Cost(leg.energyKj, idealEnergyPerLeg);
    dp[0][k]=c;
  }

  // t-1 -> t
  for (let t=1;t<T;t++){
    for (let j=0;j<Klist[t];j++){
      const toPoi = restGroups[t][j];
      let best=Infinity, bestIdx=-1;

      for (let i=0;i<Klist[t-1];i++){
        if (!Number.isFinite(dp[t-1][i])) continue;
        const fromPoi = restGroups[t-1][i];
        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);
        const c = legEnergyL1Cost(leg.energyKj, idealEnergyPerLeg);
        const cand = dp[t-1][i] + c;
        if (cand < best){ best=cand; bestIdx=i; }
      }
      dp[t][j]=best;
      prev[t][j]=bestIdx;
    }
  }

  // last -> goal
  const lastT=T-1;
  let bestFinal=Infinity, bestIdx=-1;
  for (let k=0;k<Klist[lastT];k++){
    if (!Number.isFinite(dp[lastT][k])) continue;
    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApi(poi, goal, profile);
    const c = legEnergyL1Cost(leg.energyKj, idealEnergyPerLeg);
    const cand = dp[lastT][k] + c;
    if (cand < bestFinal){ bestFinal=cand; bestIdx=k; }
  }
  if (bestIdx<0) return [];

  // å¾©å…ƒ
  const picks=new Array(T);
  let cur=bestIdx;
  for(let t=lastT;t>=0;t--){
    picks[t]=restGroups[t][cur];
    cur=prev[t][cur];
  }

  // çµ±è¨ˆï¼ˆæ—¢å­˜ã¨åŒã˜ï¼‰
  let feature=null, stats={dist:[],time:[],energy:[]};
  try{
    const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out.feature;
    if(out.stats) stats = out.stats;
  }catch(e){
    console.warn('[Viterbi_L1] stats build fail', e);
  }

  return [{
    score: bestFinal,     // â† L1æœ€é©åŒ–ã®ã‚¹ã‚³ã‚¢
    rawScore: bestFinal,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// -------------------------------
// bf_rank ä»˜ä¸ç”¨ï¼šçµ„åˆã›ã‚­ãƒ¼ç”Ÿæˆ
//  - picksByTrigger ã‚’å‰æã«ã€Œãƒˆãƒªã‚¬ãƒ¼é †ã€ã‚’å›ºå®šã—ã¦æ¯”è¼ƒ
//  - POIåŒä¸€åˆ¤å®šã¯ lat/lon ã‚’ä¸¸ã‚ã¦æ–‡å­—åˆ—åŒ–ï¼ˆèª¤å·®å¸åï¼‰
// -------------------------------
function comboKeyFromPicksByTrigger(picksByTrigger, decimals = 6){
  const arr = Array.isArray(picksByTrigger) ? picksByTrigger : [];
  const f = (x)=> Number(x).toFixed(decimals);

  return arr.map(p=>{
    if(!p) return 'null';
    const lat = (p.lat ?? p.latitude);
    const lon = (p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

// bfListï¼ˆç·å½“ãŸã‚Šçµæœï¼‰ã‹ã‚‰ rank ãƒãƒƒãƒ—ã‚’ä½œã‚‹
function buildBfRankMap(bfList){
  const map = new Map();
  (bfList || []).forEach((r, idx)=>{
    const key = comboKeyFromPicksByTrigger(r.picksByTrigger);
    // åŒä¸€ã‚­ãƒ¼ãŒè¤‡æ•°å‡ºã¦ã‚‚ã€Œæœ€ä¸Šä½ã€ã‚’æ¡ç”¨
    if(!map.has(key)) map.set(key, idx + 1);
  });
  return map;
}

// ä»»æ„ã‚¢ãƒ«ã‚´çµæœã« bfRank ã‚’ä»˜ä¸ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° nullï¼‰
function attachBfRank(resultList, bfRankMap){
  if(!bfRankMap || !(bfRankMap instanceof Map)) return resultList;
  if(!Array.isArray(resultList)) return resultList;

  resultList.forEach(r=>{
    const pbt = Array.isArray(r.picksByTrigger) ? r.picksByTrigger
              : Array.isArray(r.picks) ? r.picks
              : null;

    const key = pbt ? comboKeyFromPicksByTrigger(pbt) : 'bad';
    r.bfRank = bfRankMap.has(key) ? bfRankMap.get(key) : null;
  });
  return resultList;
}

function autoBeamParams(restGroups, opt = {}){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;

  // å„ãƒˆãƒªã‚¬ãƒ¼å€™è£œæ•°ï¼ˆé…åˆ—ã®é…åˆ—ã‚’æƒ³å®šï¼‰
  const Klist = (Array.isArray(restGroups) ? restGroups : []).map(g => Array.isArray(g) ? g.length : 0);
  const Kmin = Klist.length ? Math.min(...Klist) : 0;
  const Kavg = Klist.length ? (Klist.reduce((a,b)=>a+b,0) / Klist.length) : 0;

  // --- ãƒ™ãƒ¼ã‚¹ï¼šTãŒå¢—ãˆã‚‹ã»ã©å°‘ã—ã ã‘åºƒã’ã‚‹ï¼ˆçˆ†ç™ºã•ã›ãªã„ï¼‰ ---
  let beamWidth =
      (T <= 1) ? 12 :
      (T === 2) ? 18 :
      (T === 3) ? 24 :
      (T === 4) ? 30 :
      (T === 5) ? 36 :
                 40; // 6ä»¥ä¸Šã¯ä¸Šé™

  // å€™è£œãŒå°‘ãªã„ãªã‚‰ãƒ“ãƒ¼ãƒ ã‚’åºƒã’ã¦ã‚‚æ„å‘³ãŒè–„ã„ã®ã§æŠ‘ãˆã‚‹
  // é€†ã«å€™è£œãŒå¤šã„ã¨ãã¯å°‘ã—å¢—ã‚„ã™
  if (Kavg <= 3) beamWidth = Math.min(beamWidth, 18);
  if (Kavg >= 10) beamWidth = Math.min(60, Math.floor(beamWidth * 1.25));

  // beamWidth ã¯ã€Œå„æ®µã§æ®‹ã™æœ¬æ•°ã€ãªã®ã§ã€å„ãƒˆãƒªã‚¬ãƒ¼å€™è£œã‚ˆã‚Šå¤§ããã—ã¦ã‚‚ãƒ ãƒ€ã«ãªã‚ŠãŒã¡
  // ç›®å®‰ã¨ã—ã¦ Kmin*3 ãã‚‰ã„ã‚’ä¸Šé™ã«ã—ã¦ãŠãï¼ˆKminãŒå°ã•ã„ã¨ãã®ç„¡é§„é˜²æ­¢ï¼‰
  if (Kmin > 0) beamWidth = Math.min(beamWidth, Kmin * 3);

  // --- topKï¼šæœ€çµ‚å€™è£œæ•°ã€‚TãŒå¢—ãˆã‚‹ã»ã©å°‘ã—å¢—ã‚„ã™ãŒä¸Šé™ä»˜ã ---
  let topK =
      (T <= 1) ? 30 :
      (T === 2) ? 60 :
      (T === 3) ? 90 :
      (T === 4) ? 120 :
      (T === 5) ? 150 :
                 180; // 6ä»¥ä¸Šã¯ä¸Šé™

  // rerank ã‚’ã™ã‚‹ãªã‚‰ topK ã¯å¤§ãã™ãã‚‹ã¨ ORS è¿½åŠ å‘¼ã³å‡ºã—ãŒå¢—ãˆãŒã¡ â†’ ä¸Šé™
  topK = Math.min(topK, 200);

  // --- ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šãŒã‚ã‚Œã°å„ªå…ˆï¼ˆæ˜ç¤ºæŒ‡å®šã¯æœ€å¼·ï¼‰ ---
  if (opt.beamWidth != null) beamWidth = Math.max(1, Number(opt.beamWidth) || 1);
  if (opt.topK != null)      topK      = Math.max(1, Number(opt.topK) || 1);

  return { beamWidth, topK, T, Kmin, Kavg };
}

// ---- å¯¾ç­–Bï¼šTopKã‚’é‡è¤‡æ’é™¤ã—ã¦ã‹ã‚‰ç·é‡MSEã§å†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆAPIï¼‰ ----
async function runViterbiTopK_Rerank_API_Dedupe(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: false
  });
}

// ---- å¯¾ç­–A(å…¨ä»¶)ï¼šTopKã‚’ç·é‡MSEã§å†ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆå…¨ä»¶è¿”ã™ãƒ»é‡è¤‡æ’é™¤ãªã—ï¼‰ ----
async function runViterbiTopK_Rerank_All_API(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: false,
    returnAll: true
  });
}

function routeEnergyMseFromStats(stats, idealEnergyPerLeg){
  const eArr = stats && Array.isArray(stats.energy) ? stats.energy : [];
  const n = eArr.length;
  if (!n) return NaN;

  let sum = 0;
  for (let i = 0; i < n; i++){
    const ei = Number(eArr[i]);
    const de = (Number.isFinite(ei) ? ei : 0) - idealEnergyPerLeg;
    sum += de * de;
  }
  return sum / n;
}

// ã€æ–°è¦è¿½åŠ ã€‘1åŒºé–“ã®è·é›¢ã‚³ã‚¹ãƒˆï¼ˆMSEï¼‰: (åŒºé–“è·é›¢ - ç†æƒ³è·é›¢)^2
function legDistMseCost(distKm, idealDistPerLeg){
  const d  = Number(distKm);
  const id = Number(idealDistPerLeg);
  if (!Number.isFinite(d) || !Number.isFinite(id)) return Infinity;
  const diff = d - id;
  return diff * diff;
}

// ã€æ–°è¦è¿½åŠ ã€‘ãƒ«ãƒ¼ãƒˆå…¨ä½“ã®è·é›¢MSEã‚’è¨ˆç®—
function routeDistMseFromStats(stats, idealDistPerLeg){
  const dArr = stats && Array.isArray(stats.dist) ? stats.dist : [];
  const n = dArr.length;
  if (!n) return NaN;

  let sum = 0;
  for (let i = 0; i < n; i++){
    const val = Number(dArr[i]);
    const diff = (Number.isFinite(val) ? val : 0) - idealDistPerLeg;
    sum += diff * diff;
  }
  return sum / n;
}

function defaultLinearSorter(a, b){
  const score = p =>
    (Number(p?.distFromTriggerM) || 0) +
    (Number(p?._proj?.perpM) || 0);
  return score(a) - score(b);
}

function sumNums(arr){
  return (arr || []).reduce((a,b)=>a + (Number(b)||0), 0);
}

function finalScoreFromStats(stats, ideals){
  // â˜…å¤‰æ›´ï¼šè·é›¢ã®å‡ç­‰æ€§(MSE)ã‚’è¿”ã™
  return routeDistMseFromStats(stats, ideals.idealDistPerLeg);
}

// ======================================================
// å…±é€šï¼šç†æƒ³ãƒ¬ã‚°ï¼ˆideal per legï¼‰ã‚’è¨ˆç®—
// ======================================================
function getIdealPerLegs(){
  const cumTotals = window.__cumTotals || {};
  const totalDkm  = (Number(cumTotals.D) || 0) / 1000;
  const totalTmin = (Number(cumTotals.T) || 0) / 60;
  const totalEkJ  = Number(cumTotals.E)  || 0;

  const T = Array.isArray(window.restGroups) ? window.restGroups.length : 0;
  const R = T + 1;

  return {
    totalDkm, totalTmin, totalEkJ,
    T, R,
    idealDistPerLeg:   R > 0 ? totalDkm  / R : 0,
    idealTimePerLeg:   R > 0 ? totalTmin / R : 0,
    idealEnergyPerLeg: R > 0 ? totalEkJ  / R : 0,
  };
}

// ======================================================
// å…±é€šï¼šæ¯”è¼ƒç”¨ã®ã‚¹ã‚³ã‚¢ï¼ˆä¸¦ã³é †ãƒ»CSVãƒ»è¡¨ç¤ºã‚’ä¸€è‡´ã•ã›ã‚‹ï¼‰
// stats ãŒã‚ã‚Œã° energyMSE ã‚’æœ€å„ªå…ˆï¼ˆç·å½“ãŸã‚Šã¨åŒã˜åœŸä¿µï¼‰
// ======================================================
function unifiedScoreForCompare(r, _unused){ // ç¬¬2å¼•æ•°ã¯ä½¿ã„ã¾ã›ã‚“
  const ideals = getIdealPerLegs(); // ç†æƒ³å€¤ã‚’å†å–å¾—
  // â˜…å¤‰æ›´ï¼šè·é›¢MSEã‚’ä½¿ç”¨
  const e = (r && r.stats) ? routeDistMseFromStats(r.stats, ideals.idealDistPerLeg) : NaN;
  if (Number.isFinite(e)) return e;

  const s = Number(r && r.score);
  if (Number.isFinite(s)) return s;

  const rs = Number(r && r.rawScore);
  if (Number.isFinite(rs)) return rs;

  return Infinity;
}

// å…±é€šï¼šç ´å£Šã—ãªã„ã‚½ãƒ¼ãƒˆï¼ˆå…ƒé…åˆ—ã‚’å£Šã•ãªã„ï¼‰
function sortResultsByUnifiedScore(list, idealEnergyPerLeg){
  const arr = Array.isArray(list) ? list : [];
  return arr.slice().sort((a,b)=>{
    return unifiedScoreForCompare(a, idealEnergyPerLeg) - unifiedScoreForCompare(b, idealEnergyPerLeg);
  });
}

async function runViterbiTopK_Rerank_All_API_Dedupe(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: true
  });
}

function getAbViterbiOpt(){
  const auto = !!document.getElementById('abAutoParams')?.checked;

  const bw = Number(document.getElementById('abBeamWidth')?.value);
  const tk = Number(document.getElementById('abTopK')?.value);

  const opt = {};
  if (!auto){
    if (Number.isFinite(bw) && bw > 0) opt.beamWidth = Math.floor(bw);
    if (Number.isFinite(tk) && tk > 0) opt.topK      = Math.floor(tk);
  }
  return opt; // auto=true ã®ã¨ãã¯ {} ã‚’è¿”ã™ï¼ˆautoBeamParamsãŒåŠ¹ãï¼‰
}

// lat/lonæ­£è¦åŒ–ï¼ˆæºã‚Œå¸åï¼‰
function normLL(p){
  if(!p) return null;
  const lat = Number(p.lat ?? p.latitude ?? p.y);
  const lon = Number(p.lon ?? p.lng ?? p.longitude ?? p.x);
  if(!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
  return { lat, lon };
}

function distMeters(a, b){
  const A = normLL(a), B = normLL(b);
  if(!A || !B) return Infinity;

  if (window.L && L.latLng){
    return L.latLng(A.lat, A.lon).distanceTo(L.latLng(B.lat, B.lon));
  }
  // ç°¡æ˜“ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆé›‘ã§OKï¼‰
  const dx = (A.lat - B.lat) * 111320;
  const dy = (A.lon - B.lon) * 111320;
  return Math.hypot(dx, dy);
}

// start/goalã«è¿‘ã„ç«¯ãƒˆãƒªã‚¬ãƒ¼ã‚’waypointsã«å·®ã—è¾¼ã‚€ã‹åˆ¤æ–­
function maybeEndTriggersAsWaypoints(start, goal, restGroups, opt){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!T) return { addStartTrig:false, addGoalTrig:false, startTrig:null, goalTrig:null };

  const thr = Number(opt?.adjacentMeters) || 80;

  const startTrig = restGroups[0]?.rest || null;
  const goalTrig  = restGroups[T-1]?.rest || null;

  const addStartTrig = !!(opt?.includeEndTriggers && startTrig && distMeters(start, startTrig) <= thr);
  const addGoalTrig  = !!(opt?.includeEndTriggers && goalTrig  && distMeters(goal,  goalTrig)  <= thr);

  return { addStartTrig, addGoalTrig, startTrig, goalTrig };
}

// è¡¨ç¤ºãƒ»statsè¨ˆç®—ç”¨ã®waypointsã‚’ä½œã‚‹ï¼ˆå¿…è¦ãªã‚‰ç«¯ãƒˆãƒªã‚¬ãƒ¼ã‚’å·®ã—è¾¼ã‚€ï¼‰
function buildWaypointsForRoute(start, goal, picks, restGroups, opt){
  const ends = maybeEndTriggersAsWaypoints(start, goal, restGroups, opt);

  const wps = [];
  wps.push(start);

  if (ends.addStartTrig) wps.push(ends.startTrig);

  (picks || []).forEach(p=>{ if (p) wps.push(p); });

  if (ends.addGoalTrig) wps.push(ends.goalTrig);

  wps.push(goal);

  // ORSå…¥åŠ›ç”¨ã« lat/lon ã‚’ç¢ºå®ŸåŒ–
  return wps.map(p => {
    const ll = normLL(p) || {lat:NaN, lon:NaN};
    return {
      lat: ll.lat,
      lon: ll.lon,
      name: p?.name || 'POI'
    };
  });
}

async function runViterbiOnce_API_C(start, goal, restGroups, profile, opt = {}) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!Number.isInteger(T) || T <= 0) return [];

const ideals = getIdealPerLegs();
const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => !Number.isInteger(k) || k <= 0)) return [];

  const dp   = [];
  const prev = [];
  for (let t = 0; t < T; t++) {
    dp[t]   = new Array(Klist[t]).fill(Infinity);
    prev[t] = new Array(Klist[t]).fill(-1);
  }

  // â˜…å¯¾ç­–Cï¼šç«¯ï¼ˆstartâ†’1st / lastâ†’goalï¼‰ã‚’DPã‚¹ã‚³ã‚¢ã‹ã‚‰é™¤å¤–
  // dp[0][k] ã¯å…¨éƒ¨0ã‚¹ã‚¿ãƒ¼ãƒˆ
  for (let k = 0; k < Klist[0]; k++) dp[0][k] = 0;

  // â˜…ãƒˆãƒªã‚¬ãƒ¼é–“ã ã‘è©•ä¾¡ï¼ˆt-1 â†’ tï¼‰
  for (let t = 1; t < T; t++) {
    const curGroup  = restGroups[t];
    const prevGroup = restGroups[t - 1];

    for (let j = 0; j < Klist[t]; j++) {
      const toPoi = curGroup[j];

      let bestCost = Infinity;
      let bestIdx  = -1;

      for (let i = 0; i < Klist[t - 1]; i++) {
        const prevCost = dp[t - 1][i];
        if (!Number.isFinite(prevCost)) continue;

        const fromPoi = prevGroup[i];
        const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
        if (cand < bestCost) {
          bestCost = cand;
          bestIdx  = i;
        }
      }

      dp[t][j]   = bestCost;
      prev[t][j] = bestIdx;
    }
  }

  // â˜…æœ€å¾Œâ†’goalã‚‚è¶³ã•ãªã„ï¼šdp[last] ã®æœ€å°ã‚’æ¡ç”¨
  const lastT = T - 1;
  let bestFinalCost = Infinity;
  let bestFinalIdx  = -1;
  for (let k = 0; k < Klist[lastT]; k++){
    const v = dp[lastT][k];
    if (Number.isFinite(v) && v < bestFinalCost){
      bestFinalCost = v;
      bestFinalIdx = k;
    }
  }
  if (bestFinalIdx < 0 || !Number.isFinite(bestFinalCost)) return [];

  // å¾©å…ƒ
  const picks = new Array(T);
  let curIdx  = bestFinalIdx;
  for (let t = lastT; t >= 0; t--) {
    picks[t] = restGroups[t][curIdx];
    curIdx   = prev[t][curIdx];
  }

  // â˜…è¡¨ç¤ºãƒ»CSVç”¨ï¼šå®Œå…¨çµŒè·¯(start..goal)ã§1å›ã ã‘statsã‚’ä½œã‚‹
  let feature = null;
  let stats   = { dist:[], time:[], energy:[] };
  let finalScore = bestFinalCost; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

  try {
    // ç«¯ãƒˆãƒªã‚¬ãƒ¼ã‚’æ¡ä»¶ã§å·®ã—è¾¼ã‚€ï¼ˆã“ã“ãŒã€Œå…ˆã»ã©ã®Cã€ï¼‰
    const wps = buildWaypointsForRoute(start, goal, picks, window.restGroups, opt);

    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if (out?.stats) stats = out.stats;

    const exact = finalScoreFromStats(stats, { idealEnergyPerLeg });
    if (Number.isFinite(exact)) finalScore = exact;
  } catch (e) {
    console.warn('[Viterbi_C] stats build fail', e);
  }

  return [{
    score: finalScore,       // è¡¨ç¤ºãƒ»æ¯”è¼ƒã¯ã“ã£ã¡ï¼ˆç·å½“ãŸã‚Šã¨åŒã˜åœŸä¿µï¼‰
    rawScore: bestFinalCost, // DPè¿‘ä¼¼ï¼ˆç«¯é™¤å¤–ï¼‰
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// ======================================================
// NEW å¯¾ç­–Cï¼ˆç½®ãæ›ãˆæ¡ˆï¼‰:
//  - DPã§ã¯ãªã Beamï¼ˆè¿‘ä¼¼ï¼‰
//  - å„æ®µã§ã€Œstart + ã“ã‚Œã¾ã§ã®picks + æ¬¡å€™è£œ (+ goal)ã€ã‚’1å›ã®ORSã§è©•ä¾¡
//  - beamWidth æœ¬ã ã‘æ®‹ã™
//  - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§åŒã˜waypointsåˆ—ã®å†è¨ˆç®—ã‚’é¿ã‘ã‚‹
// ======================================================
function wpsKey(points, decimals = 6){
  const f = (x)=> Number(x).toFixed(decimals);
  return (points || []).map(p=>{
    if(!p) return 'null';
    const lat = Number(p.lat ?? p.latitude);
    const lon = Number(p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

async function orsRouteCached(wps, profile, cache){
  const key = wpsKey(wps, 6);
  if (cache && cache.has(key)) return cache.get(key);

  const out = await routeLegStatsForWaypoints(
    wps.map(p=>({ lat:p.lat, lon:p.lon, name:p.name || 'POI' })),
    profile
  );

  const packed = {
    key,
    feature: out?.feature || null,
    stats: out?.stats || null
  };

  if (cache) cache.set(key, packed);
  return packed;
}

// â˜… å¯¾ç­–Cï¼ˆBeam + çµŒç”±åœ°å¢—ã‚„ã™ORSï¼‰
async function runViterbiOnce_API_C_BeamFull(start, goal, groups, profile, opt = {}){
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  const beamWidth = Math.max(1, Number(opt.beamWidth) || 12);

  // ã‚¹ã‚³ã‚¢ã¯ã€Œæœ€çµ‚çµŒè·¯statsã‹ã‚‰ energyMSEã€ã‚’å„ªå…ˆï¼ˆæ—¢å­˜æ–¹é‡ã«åˆã‚ã›ã‚‹ï¼‰
  const ideals = getIdealPerLegs();

  // ORSçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåŒã˜waypointsåˆ—ã¯äºŒåº¦å‘¼ã°ãªã„ï¼‰
  const cache = new Map();

  // beam state:
  // { score, picks, picksByTrigger, feature, stats }
  let beam = [];

  // --- t=0ï¼ˆæœ€åˆã®ãƒˆãƒªã‚¬ãƒ¼å€™è£œã‚’å±•é–‹ï¼‰ ---
  for (let j = 0; j < groups[0].length; j++){
    const p0 = groups[0][j];
    const wps0 = [start, p0]; // ã¾ã goalã¯å…¥ã‚Œãªã„
    const out0 = await orsRouteCached(wps0, profile, cache);

    // â€»ä¸­é–“æ®µã¯statsãŒã€Œæœ€å¾Œã¾ã§ã€ã˜ã‚ƒãªã„ã®ã§ã€æš«å®šã‚¹ã‚³ã‚¢ã¨ã—ã¦ energyMSE ã‚’ä½¿ã†
    //   ã“ã“ã¯ã€Œè·é›¢/æ™‚é–“/ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®éƒ¨åˆ†MSEã€ã§ã‚‚OKã ãŒã€ã¾ãšã¯ç°¡å˜ã«çµ±ä¸€ã‚¹ã‚³ã‚¢ã§ã€‚
    const s0 = (out0.stats ? finalScoreFromStats(out0.stats, ideals) : Infinity);

    beam.push({
      score: Number.isFinite(s0) ? s0 : Infinity,
      picks: [p0],
      picksByTrigger: [p0],
      feature: out0.feature,
      stats: out0.stats
    });
  }

  beam.sort((a,b)=>a.score-b.score);
  beam = beam.slice(0, beamWidth);

  // --- t=1..T-1 ---
  for (let t = 1; t < T; t++){
    const next = [];

    for (const st of beam){
      for (let j = 0; j < groups[t].length; j++){
        const pt = groups[t][j];
        const picks = [...st.picks, pt];

        // æœ€å¾Œã®ãƒˆãƒªã‚¬ãƒ¼ãªã‚‰ goal ã¾ã§å«ã‚ã¦ â€œå®Œæˆå½¢â€ ã‚’è©•ä¾¡
        const wps = (t === T-1)
          ? [start, ...picks, goal]
          : [start, ...picks];

        try{
          const out = await orsRouteCached(wps, profile, cache);
          const s = (out.stats ? finalScoreFromStats(out.stats, ideals) : Infinity);

          next.push({
            score: Number.isFinite(s) ? s : Infinity,
            picks,
            picksByTrigger: picks, // ãƒˆãƒªã‚¬ãƒ¼é †ã®åˆ—
            feature: out.feature,
            stats: out.stats
          });
        }catch(e){
          // å¤±æ•—ã¯æ¨ã¦ã‚‹
          console.warn('[C_BeamFull] expand fail', e);
        }
      }
    }

    if (!next.length) return [];

    next.sort((a,b)=>a.score-b.score);
    beam = next.slice(0, beamWidth);
  }

  // beam[0] ãŒæœ€è‰¯ï¼ˆå®Œæˆå½¢ï¼‰
  return beam.length ? [beam[0]] : [];
}

function buildVitGroupsWithFixedRest(restGroups, capPerTrigger, variableCount, sorter){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  const out = [];

  for (let i = 0; i < T; i++){
    const g = restGroups[i];

    if (i < variableCount){
      // å ´åˆåˆ†ã‘ã™ã‚‹
      let pois = Array.isArray(g?.pois) ? g.pois.slice() : [];
      if (typeof sorter === 'function') pois.sort(sorter);
      pois = pois.slice(0, capPerTrigger);

      out.push(pois);
    } else {
      // å›ºå®šã™ã‚‹: ãƒˆãƒªã‚¬ãƒ¼åœ°ç‚¹ã‚’å€™è£œ1å€‹ã¨ã—ã¦å…¥ã‚Œã‚‹
      const r = g?.rest;
      out.push(r ? [r] : []);
    }
  }
  return out;
}

async function runViterbi_D_Progressive(start, goal, restGroups, profile, opt = {}){
  const capPerTrigger = Math.max(1, Number(opt.capPerTrigger) || 5);
  const sorter = opt.sorter || null;

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  const allResults = [];

  for (let variableCount = 1; variableCount <= T; variableCount++){
    const vitGroups = buildVitGroupsWithFixedRest(
      restGroups,
      capPerTrigger,
      variableCount,
      sorter
    );

    const list = await runViterbiOnce_API(start, goal, vitGroups, profile);
    const best = (Array.isArray(list) && list.length) ? list[0] : null;

    allResults.push({
      variableCount,
      best
    });
  }

  return allResults;
}

// åå‰ãŒç„¡ã„POIã« POI{triggerIndex}.{id} ã‚’ä»˜ã‘ã‚‹
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const raw = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();

  // â˜…ã€Œä¸æ˜æ‰±ã„ã€åˆ¤å®šã‚’è¿½åŠ ï¼šç©ºæ–‡å­—ã ã‘ã§ãªã 'POI' / 'poi' ã‚‚ç½®æ›å¯¾è±¡ã«ã™ã‚‹
  const isUnknown =
    !raw ||
    /^poi$/i.test(raw) ||                 // "POI" ã ã‘
    /^poi[_\-\s]*$/i.test(raw);           // "POI_" ã¿ãŸã„ãªã®ã‚‚ä¸€å¿œ

  if (!isUnknown) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // 0å§‹ã¾ã‚Š
  return poi;
}

// ======================================================
// 2ç‚¹åŒºé–“ORSã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆåŒã˜from/to/profileãªã‚‰å†åˆ©ç”¨ï¼‰
// ======================================================
const __legCache = new Map();

function legKey(from, to, profile, decimals=6){
  const f = x => Number(x).toFixed(decimals);
  const aLat = from?.lat ?? from?.latitude ?? from?.y;
  const aLon = from?.lon ?? from?.lng ?? from?.longitude ?? from?.x;
  const bLat = to?.lat   ?? to?.latitude   ?? to?.y;
  const bLon = to?.lon   ?? to?.lng ?? to?.longitude ?? to?.x;
  return `${profile}::${f(aLat)},${f(aLon)}=>${f(bLat)},${f(bLon)}`;
}

async function calcLegCostWithApiCached(from, to, profile){
  const key = legKey(from, to, profile);
  if (__legCache.has(key)) return __legCache.get(key);

  const leg = await calcLegCostWithApi(from, to, profile);
  __legCache.set(key, leg);
  return leg;
}

// ======================================================
// å¯¾ç­–Eï¼šViterbiï¼ˆ2ç‚¹DPï¼‰+ 2ç‚¹åŒºé–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
//   - æœ€é©æ€§ã¯ç¶­æŒ
//   - â€œåŒã˜åŒºé–“ã®é‡è¤‡å‘¼ã³å‡ºã—â€ãŒæ¸›ã‚‹ã¨APIå›æ•°ãŒæ¸›ã‚‹
// ======================================================
async function runViterbiOnce_API_E_Cached(start, goal, restGroups, profile){
  // ã“ã“ã¯ runViterbiOnce_API ã‚’ã‚³ãƒ”ã£ã¦
  // calcLegCostWithApi(...) ã‚’ calcLegCostWithApiCached(...) ã«ç½®æ›ã™ã‚‹ã ã‘ã§OK

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  const ideals = getIdealPerLegs();
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;
  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  const dp=[], prev=[];
  for(let t=0;t<T;t++){
    dp[t]=new Array(Klist[t]).fill(Infinity);
    prev[t]=new Array(Klist[t]).fill(-1);
  }

  // start -> 0
  for (let k=0;k<Klist[0];k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApiCached(start, poi, profile);
    const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
    dp[0][k]=mse;
  }

  // t-1 -> t
  for (let t=1;t<T;t++){
    for (let j=0;j<Klist[t];j++){
      const toPoi = restGroups[t][j];
      let best=Infinity, bestIdx=-1;

      for (let i=0;i<Klist[t-1];i++){
        if (!Number.isFinite(dp[t-1][i])) continue;
        const fromPoi = restGroups[t-1][i];
        const leg = await calcLegCostWithApiCached(fromPoi, toPoi, profile);
        const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
        const cand = dp[t-1][i] + mse;
        if (cand < best){ best=cand; bestIdx=i; }
      }
      dp[t][j]=best;
      prev[t][j]=bestIdx;
    }
  }

  // last -> goal
  const lastT=T-1;
  let bestFinal=Infinity, bestIdx=-1;
  for (let k=0;k<Klist[lastT];k++){
    if (!Number.isFinite(dp[lastT][k])) continue;
    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApiCached(poi, goal, profile);
    const mse = legEnergyMseCost(leg.energyKj, idealEnergyPerLeg);
    const cand = dp[lastT][k] + mse;
    if (cand < bestFinal){ bestFinal=cand; bestIdx=k; }
  }
  if (bestIdx<0) return [];

  // å¾©å…ƒ
  const picks=new Array(T);
  let cur=bestIdx;
  for(let t=lastT;t>=0;t--){
    picks[t]=restGroups[t][cur];
    cur=prev[t][cur];
  }

  // è¡¨ç¤ºç”¨ stats ã‚’1å›ä½œã‚‹
  let feature=null, stats={dist:[],time:[],energy:[]};
  try{
    const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if(out?.stats) stats = out.stats;
  }catch(e){}

  return [{
    score: finalScoreFromStats(stats, { idealEnergyPerLeg }),
    rawScore: bestFinal,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// ======================================================
// å¯¾ç­–Fï¼šTopKå€™è£œã‚’ä½œã£ã¦ã‹ã‚‰ â€œä¸€æ°—ã«çµŒç”±åœ°ä»˜ãORSâ€ã§å†è©•ä¾¡
//   - TopKç”Ÿæˆã¯è¿‘ä¼¼ï¼ˆãƒ“ãƒ¼ãƒ ï¼‰
//   - æœ€çµ‚é †ä½ã¯ routeLegStatsForWaypoints ã®1å›å‘¼ã³ã§ç¢ºå®š
// ======================================================
async function runViterbi_F_TopN_ThenFullORS(start, goal, groups, profile, opt = {}){
  // 1) è¿‘ä¼¼ã§TopKå€™è£œï¼ˆãƒ“ãƒ¼ãƒ ï¼‰
  const topKList = await runViterbiTopK_API(start, goal, groups, profile, opt);

  // 2) ä¸€æ°—ã«çµŒç”±åœ°ä»˜ãORSã§å†è©•ä¾¡ï¼ˆæ—¢å­˜ï¼‰
  // returnAll=true ã«ã™ã‚‹ã¨ â€œå†è©•ä¾¡æ¸ˆã¿ä¸€è¦§â€ ãŒå–ã‚Œã‚‹
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: true
  });
}

function isAlgoEnabled(id){
  const el = document.getElementById(id);
  return !!(el && el.checked);
}

function applyAutoNamesToAllPois(){
  if (!Array.isArray(restGroups)) return;

  for (let ti = 0; ti < restGroups.length; ti++){
    const arr = restGroups[ti]?.pois || [];
    for (let pi = 0; pi < arr.length; pi++){
      const p = arr[pi];
      if (!p) continue;

      // å®‰å®šIDï¼ˆä»»æ„ï¼šãŠã™ã™ã‚ï¼‰
      p._triggerId = ti;
      p._poiIdInTrigger = pi;

      // åå‰ãŒç„¡ã‘ã‚Œã° POI{ti}_{pi}
      ensurePoiName(p, ti, pi);
    }
  }
}

/* ==========================================================
   ã€å¯¾ç­–Gãƒ»å®Œå…¨ç‰ˆã€‘SGæ’é™¤ BeamSearch + ä¸€æ‹¬ãƒªãƒ©ãƒ³ã‚¯
   ãƒ»S/GåŒºé–“ã‚’ç„¡è¦–ã—ã¦ã€ä¸­é–“ã®ã¤ãªãŒã‚ŠãŒè‰¯ã„å€™è£œã‚’TopKå€‹é¸å‡º
   ãƒ»æœ€å¾Œã«ä¸€æ‹¬API(Batch)ã§æ­£ç¢ºãªã‚¹ã‚³ã‚¢ã‚’å‡ºã—ã¦ä¸¦ã³æ›¿ãˆ
   ========================================================== */
/* ===== ã€å¤‰æ›´ã€‘å¯¾ç­–G (SGæ’é™¤) è·é›¢MSEå¯¾å¿œç‰ˆ ===== */
async function solveMeasureG(start, goal, groups, profile) {
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  // 1. è¨­å®š
  const BEAM_WIDTH = 30; // äºˆé¸é€šéã•ã›ã‚‹å€™è£œæ•° (TopK)
  
  // â˜…å¤‰æ›´ç‚¹1ï¼šè·é›¢ã®ç†æƒ³å€¤ã‚’å–å¾—
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg; 

  // APIé–¢æ•° (ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾å¿œç‰ˆã‚’æƒ³å®š)
  const apiFunc = calcLegCostWithApi; 

  // --- Step 0: Start -> Group 0 (Layer 0) ---
  // â˜…SGæ’é™¤: ã‚¹ã‚¿ãƒ¼ãƒˆåŒºé–“ã®ã‚³ã‚¹ãƒˆã¯ç„¡è¦–(=0)
  let currentPaths = groups[0].map(poi => ({
    picks: [poi],           // é¸æŠã•ã‚ŒãŸPOIã®ãƒªã‚¹ãƒˆ
    currentCost: 0,         // ã‚³ã‚¹ãƒˆã¯0ã‚¹ã‚¿ãƒ¼ãƒˆ
    lastNode: poi
  }));

  // --- Step 1..T-1: ä¸­é–“åŒºé–“ (Layer t) ---
  for (let t = 1; t < T; t++) {
    const nextGroup = groups[t];
    let nextCandidates = [];

    // ç¾åœ¨ã®å€™è£œ(currentPaths)ã‹ã‚‰ã€æ¬¡ã®ã‚°ãƒ«ãƒ¼ãƒ—(nextGroup)ã¸ç·å½“ãŸã‚Š
    for (const path of currentPaths) {
      for (const nextPoi of nextGroup) {
        
        // åŒºé–“ã‚³ã‚¹ãƒˆå–å¾— (ã‚­ãƒ£ãƒƒã‚·ãƒ¥ or API)
        const leg = await apiFunc(path.lastNode, nextPoi, profile);
        
        // â˜…å¤‰æ›´ç‚¹2ï¼šè·é›¢(km) ã®ç†æƒ³å€¤ã¨ã®ã‚ºãƒ¬(MSE)ã‚’è¨ˆç®—
        const diff = leg.distKm - idealDistPerLeg;
        const penalty = diff * diff;

        // å€™è£œã«è¿½åŠ 
        nextCandidates.push({
          picks: [...path.picks, nextPoi],
          currentCost: path.currentCost + penalty, // ç´¯ç©
          lastNode: nextPoi
        });
      }
    }

    // ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½(BEAM_WIDTH)ã ã‘æ®‹ã™
    nextCandidates.sort((a, b) => a.currentCost - b.currentCost);
    currentPaths = nextCandidates.slice(0, BEAM_WIDTH);
  }

  // --- Last Step: Group Last -> Goal ---
  // ã‚´ãƒ¼ãƒ«åŒºé–“ã®ã‚³ã‚¹ãƒˆè¨ˆç®—ã¯ã€Œã—ãªã„ã€ï¼ˆä¸­é–“ã‚»ã‚¯ã‚·ãƒ§ãƒ³å„ªç§€ãƒ«ãƒ¼ãƒˆå€™è£œï¼‰

  console.log(`Algo G: äºˆé¸é€šé ${currentPaths.length} ä»¶ã€‚æ±ºå‹(ãƒªãƒ©ãƒ³ã‚¯)é–‹å§‹...`);

  // --- Final Step: ä¸€æ‹¬APIã§ãƒªãƒ©ãƒ³ã‚¯ (æ±ºå‹æˆ¦) ---
  const finalResults = [];

  for (let i = 0; i < currentPaths.length; i++) {
    const candidate = currentPaths[i];
    
    // çµŒè·¯ã‚’æ§‹ç¯‰: [Start] + [ä¸­é–“POIãŸã¡] + [Goal]
    const waypoints = [start, ...candidate.picks, goal];

    try {
      // â˜…å¤‰æ›´ç‚¹3ï¼šå…±é€šé–¢æ•°ã‚’ä½¿ã£ã¦ãƒ«ãƒ¼ãƒˆè©³ç´°ã‚’å–å¾—ã—ã€è·é›¢MSEã§è©•ä¾¡ã™ã‚‹
      const out = await routeLegStatsForWaypoints(waypoints, profile);
      
      // å…¨ä½“ã®è·é›¢MSEã‚¹ã‚³ã‚¢ã‚’ç®—å‡º
      const distScore = routeDistMseFromStats(out.stats, idealDistPerLeg);

      finalResults.push({
        rank: 0, // ã‚ã¨ã§åŸ‹ã‚ã‚‹
        score: distScore,    // â˜…è·é›¢MSE
        rawScore: distScore,
        
        // ãƒ­ã‚°ãƒ»CSVå‡ºåŠ›ç”¨ãƒ‡ãƒ¼ã‚¿
        poi_names: candidate.picks.map(p => p.name).join(' -> '),
        poi_latlngs: candidate.picks.map(p => `${p.lat},${p.lon}`).join(' | '),
        
        // statsã®ä¸­èº«ã‚’å±•é–‹ã—ã¦ä¿å­˜ï¼ˆCSVå‡ºåŠ›ç­‰ã§ä½¿ã†ãŸã‚ï¼‰
        sigmaEnergy: stdDev(out.stats.energy), // å‚è€ƒå€¤ã¨ã—ã¦æ®‹ã™
        dist: out.stats.dist,
        time: out.stats.time,
        
        // æç”»ç”¨ãƒ‡ãƒ¼ã‚¿
        picks: candidate.picks,
        stats: out.stats
      });
      
    } catch (e) {
      console.warn(`Algo G: ãƒªãƒ©ãƒ³ã‚¯å¤±æ•— (Candidate ${i})`, e);
    }
  }

  // ã‚¹ã‚³ã‚¢ã®è‰¯ã„é †(æ˜‡é †)ã«ä¸¦ã³æ›¿ãˆ
  finalResults.sort((a, b) => a.score - b.score);

  // ãƒ©ãƒ³ã‚¯ä»˜ä¸
  finalResults.forEach((r, idx) => r.rank = idx + 1);

  return finalResults;
}

/* ==========================================================
   ã€å¯¾ç­–Hã€‘SGæ’é™¤ Viterbi (DP) + ä¸€æ‹¬ãƒªãƒ©ãƒ³ã‚¯
   ãƒ»Start/GoalåŒºé–“ã‚’ç„¡è¦–ã™ã‚‹ã®ã¯Gã¨åŒã˜
   ãƒ»ãŸã ã—ã€ä¸­é–“ã¯ã€Œå„POIã¸ã®æœ€è‰¯ãƒ‘ã‚¹ã‚’1ã¤æ®‹ã™(Viterbi)ã€æ–¹å¼
   ========================================================== */
async function solveMeasureH(start, goal, groups, profile) {
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  // â˜…å¤‰æ›´1: è·é›¢ã®ç†æƒ³å€¤ã‚’å–å¾—
  const ideals = getIdealPerLegs();
  const idealDistPerLeg = ideals.idealDistPerLeg; 

  const apiFunc = calcLegCostWithApi; 

  // --- Step 0: Start -> Group 0 (Layer 0) ---
  // StartåŒºé–“ã¯ã‚³ã‚¹ãƒˆç„¡è¦–(=0)ã§åˆæœŸåŒ–
  // currentPaths[i] ã«ã¯ã€Œgroups[0][i] ã«è‡³ã‚‹ã¾ã§ã®ãƒ‘ã‚¹æƒ…å ±ã€ãŒå…¥ã‚‹
  let currentPaths = groups[0].map(poi => ({
    picks: [poi],
    currentCost: 0,
    lastNode: poi,
    valid: true // ç”Ÿå­˜ãƒ•ãƒ©ã‚°
  }));

  // --- Step 1..T-1: ä¸­é–“åŒºé–“ (Layer t) ---
  for (let t = 1; t < T; t++) {
    const nextGroup = groups[t];
    
    // æ¬¡ã®å±¤ã®å„POIã«ã¤ã„ã¦ã€Œãƒ™ã‚¹ãƒˆãªè¦ªã€ã‚’æ¢ã™
    // nextPaths[j] = groups[t][j] ã«è‡³ã‚‹æœ€è‰¯ãƒ‘ã‚¹
    const nextPaths = new Array(nextGroup.length).fill(null);

    // æ¬¡ã®å±¤ã®å„ãƒãƒ¼ãƒ‰(j)ã«å¯¾ã—ã¦ãƒ«ãƒ¼ãƒ—
    for (let j = 0; j < nextGroup.length; j++) {
      const nextPoi = nextGroup[j];
      let bestCost = Infinity;
      let bestPathObj = null;

      // å‰ã®å±¤ã®å…¨ãƒãƒ¼ãƒ‰(i)ã‹ã‚‰ã€jã¸ã®é·ç§»ã‚’è©¦ã™
      for (let i = 0; i < currentPaths.length; i++) {
        const parent = currentPaths[i];
        if (!parent || !parent.valid) continue;

        try {
          // APIè² è·è»½æ¸›ï¼ˆãƒ«ãƒ¼ãƒ—å†…å¾…æ©Ÿï¼‰
          await new Promise(r => setTimeout(r, 1000)); 

          const leg = await apiFunc(parent.lastNode, nextPoi, profile);
          
          // è·é›¢MSEãƒšãƒŠãƒ«ãƒ†ã‚£
          const diff = leg.distKm - idealDistPerLeg;
          const penalty = diff * diff;
          const newCost = parent.currentCost + penalty;

          // Viterbi: æœ€å°ã‚³ã‚¹ãƒˆãªã‚‰æ›´æ–°
          if (newCost < bestCost) {
            bestCost = newCost;
            bestPathObj = {
              picks: [...parent.picks, nextPoi],
              currentCost: newCost,
              lastNode: nextPoi,
              valid: true
            };
          }
        } catch (e) {
          console.warn(`Algo H: edge calc failed at layer ${t}, node ${j}`, e);
        }
      }
      
      // j ã«è‡³ã‚‹ãƒ™ã‚¹ãƒˆãƒ‘ã‚¹ã‚’ä¿å­˜
      nextPaths[j] = bestPathObj;
    }

    // ç”Ÿå­˜ã—ã¦ã„ã‚‹ãƒ‘ã‚¹ã ã‘ã§æ›´æ–°ï¼ˆnullã¯é™¤å¤–ã—ãªã„ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ºãƒ¬ã‚‹ã®ã§ã€validãƒ•ãƒ©ã‚°ç­‰ã§ç®¡ç†ã™ã‚‹ã‹ã€nullã®ã¾ã¾ã«ã—ã¦æ¬¡ã§å¼¾ãï¼‰
    // ã“ã“ã§ã¯å˜ç´”ã«æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã§ !parent ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã‚‹ã®ã§ nextPaths ã‚’ãã®ã¾ã¾æ¸¡ã™
    currentPaths = nextPaths;
  }

  // --- Last Step: å€™è£œã®ç¢ºå®š ---
  // currentPaths ã«ã¯ã€Œæœ€å¾Œã®ä¼‘æ†©åœ°ç‚¹ã®å„POIã€ã«è‡³ã‚‹ãƒ™ã‚¹ãƒˆãƒ‘ã‚¹ãŒå…¥ã£ã¦ã„ã‚‹
  const candidates = currentPaths.filter(p => p && p.valid);

  console.log(`Algo H: äºˆé¸é€šé ${candidates.length} ä»¶ (å„POIã®ãƒ™ã‚¹ãƒˆ)ã€‚æ±ºå‹(ãƒªãƒ©ãƒ³ã‚¯)é–‹å§‹...`);

  // --- Final Step: ä¸€æ‹¬APIã§ãƒªãƒ©ãƒ³ã‚¯ (æ±ºå‹æˆ¦) ---
  const finalResults = [];

  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    const waypoints = [start, ...candidate.picks, goal];

    try {
      await new Promise(r => setTimeout(r, 2000));

      const out = await routeLegStatsForWaypoints(waypoints, profile);
      const distScore = routeDistMseFromStats(out.stats, idealDistPerLeg);

      finalResults.push({
        rank: 0,
        score: distScore,
        rawScore: distScore,
        poi_names: candidate.picks.map(p => p.name).join(' -> '),
        poi_latlngs: candidate.picks.map(p => `${p.lat},${p.lon}`).join(' | '),
        sigmaEnergy: stdDev(out.stats.energy),
        dist: out.stats.dist,
        time: out.stats.time,
        picks: candidate.picks,
        stats: out.stats
      });
      
    } catch (e) {
      console.warn(`Algo H: ãƒªãƒ©ãƒ³ã‚¯å¤±æ•— (Candidate ${i})`, e);
    }
  }

  finalResults.sort((a, b) => a.score - b.score);
  finalResults.forEach((r, idx) => r.rank = idx + 1);

  return finalResults;
}
  
function formatNum(x, digits=3){
  const n = Number(x);
  if (!Number.isFinite(n)) return '';
  return n.toFixed(digits);
}

function renderViterbiEdgePanel(limit=400){
  const pre  = document.getElementById('viterbiEdgePanel');
  const stat = document.getElementById('viterbiEdgeStat');

  // â–¼â–¼ è¿½åŠ : è¡¨ç¤ºæ™‚ã‚‚æœ€æ–°ãƒ‡ãƒ¼ã‚¿ï¼ˆç†æƒ³å€¤å…¥ã‚Šï¼‰ã‚’å†ç”Ÿæˆã—ã¦åæ˜ ã•ã›ã‚‹ â–¼â–¼
  if (window.__viterbiEdgeAgg) {
    window.__viterbiAllEdgeRows = Array.from(window.__viterbiEdgeAgg.values()).map(x => {
      const n = Math.max(1, x.count);
      return {
        fromIdx: x.fromIdx, toIdx: x.toIdx,
        fromName: x.fromName, toName: x.toName,
        fromLat: x.fromLat, fromLon: x.fromLon,
        toLat: x.toLat, toLon: x.toLon,
        count: x.count,
        energyKj: x.sumEnergyKj / n,
        distKm: x.sumDistKm / n,
        timeMin: x.sumTimeMin / n,
        cost: x.sumCost / n,
        idealEnergyKj: x.idealEnergyKj // ç†æƒ³å€¤ã‚’å–ã‚Šè¾¼ã‚€
      };
    });
  }

  const rows = window.__viterbiAllEdgeRows || [];

  if (stat) stat.textContent = `ä»¶æ•°: ${rows.length}`;
  if (!pre) return;

  if (!rows.length){
    pre.textContent = '(ã‚¨ãƒƒã‚¸ãƒ­ã‚°ãªã—ï¼šViterbiå®Ÿè¡Œå¾Œã«è¡¨ç¤ºã—ã¦ãã ã•ã„)';
    return;
  }

  const slice = rows.slice(0, limit);

  const lines = [];
  // â˜… ãƒ˜ãƒƒãƒ€ãƒ¼ã« ideal_kJ ã‚’è¿½åŠ 
  lines.push('from\tto\tcount\tdist_km\ttime_min\tenergy_kJ\tideal_kJ\tcost');

  for (const r of slice){
    lines.push([
      r.fromName ?? '',
      r.toName ?? '',
      r.count ?? 1,
      formatNum(r.distKm, 3),
      formatNum(r.timeMin, 2),
      formatNum(r.energyKj, 2),
      formatNum(r.idealEnergyKj, 2), // â˜…ã“ã“ã«å€¤ã‚’è¿½åŠ 
      formatNum(r.cost, 3)
    ].join('\t'));
  }

  if (rows.length > limit) lines.push(`... (è¡¨ç¤ºã¯å…ˆé ­${limit}ä»¶ã¾ã§ã€‚å…¨ä»¶ã¯CSVã§ç¢ºèª)`);

  pre.textContent = lines.join('\n');
}

function downloadViterbiEdgesCsv(){
  // â–¼â–¼ è¿½åŠ : MapãŒã‚ã‚‹ãªã‚‰ã€ãã“ã‹ã‚‰æœ€æ–°ã®ãƒªã‚¹ãƒˆ(ç†æƒ³å€¤ä»˜ã)ã‚’å†ç”Ÿæˆã™ã‚‹ â–¼â–¼
  if (window.__viterbiEdgeAgg) {
    window.__viterbiAllEdgeRows = Array.from(window.__viterbiEdgeAgg.values()).map(x => {
      const n = Math.max(1, x.count);
      return {
        fromIdx: x.fromIdx,
        toIdx: x.toIdx,
        fromName: x.fromName,
        toName: x.toName,
        fromLat: x.fromLat,
        fromLon: x.fromLon,
        toLat: x.toLat,
        toLon: x.toLon,
        count: x.count,
        energyKj: x.sumEnergyKj / n,
        distKm: x.sumDistKm / n,
        timeMin: x.sumTimeMin / n,
        cost: x.sumCost / n,
        idealEnergyKj: x.idealEnergyKj // æ–°ã—ã„é …ç›®
      };
    });
  }
  const rows = window.__viterbiAllEdgeRows || [];
  if (!rows.length){
    alert('Viterbiã®ã‚¨ãƒƒã‚¸ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«Viterbiã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    return;
  }

  const esc = s => String(s ?? '').replace(/"/g,'""');

  // â˜… é›†ç´„å¾Œã‚¨ãƒƒã‚¸ç”¨ãƒ˜ãƒƒãƒ€
  const header = [
    'from_idx','to_idx',
    'from_name','to_name',
    'from_lat','from_lon','to_lat','to_lon',
    'count',
    'energy_kJ',
    'ideal_energy_kJ', // è¿½åŠ 
    'dist_km',
    'time_min',
    'cost'
  ];

  const lines = [];
  lines.push(header.join(','));

  for (const r of rows){
    // â˜…ã“ã“ã‚’ä¿®æ­£ï¼šideal_energy_kJ ã‚’æŒ¿å…¥ã—ã€formatNumã§æ•´å½¢
    lines.push([
      r.fromIdx ?? '',
      r.toIdx ?? '',
      `"${esc(r.fromName)}"`,
      `"${esc(r.toName)}"`,
      r.fromLat ?? '',
      r.fromLon ?? '',
      r.toLat ?? '',
      r.toLon ?? '',
      r.count ?? 1,
      formatNum(r.energyKj, 2),
      formatNum(r.idealEnergyKj, 2), // â˜…ã“ã“ã«å€¤ã‚’è¿½åŠ ï¼
      formatNum(r.distKm, 3),
      formatNum(r.timeMin, 2),
      formatNum(r.cost, 3)
    ].join(','));
  }

  // Excelå¯¾ç­–ï¼šUTF-8 BOM
  const bom = new Uint8Array([0xEF,0xBB,0xBF]);
  const blob = new Blob([bom, lines.join('\n')], {type:'text/csv;charset=utf-8'});
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `viterbi_edges_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function bindViterbiEdgeUi(){
  const btnShow = document.getElementById('btnShowViterbiEdges');
  const btnHide = document.getElementById('btnHideViterbiEdges');
  const btnDl   = document.getElementById('btnDlViterbiEdgesCsv');
  const pre     = document.getElementById('viterbiEdgePanel');

  if (btnShow) btnShow.onclick = () => {
    if (pre) pre.style.display = 'block';
    renderViterbiEdgePanel();
  };
  if (btnHide) btnHide.onclick = () => {
    if (pre) pre.style.display = 'none';
  };
  if (btnDl) btnDl.onclick = () => downloadViterbiEdgesCsv();
}

function bindViterbiEdgeButtons(){
  const $ = (id)=>document.getElementById(id);

  const btnShow = $('btnShowViterbiEdges');
  const btnHide = $('btnHideViterbiEdges');
  const btnCsv  = $('btnDlViterbiEdgesCsv');

  console.log('[bind] show=', !!btnShow, 'hide=', !!btnHide, 'csv=', !!btnCsv);

  // æ—¢ã«åŒã˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¤šé‡ç™»éŒ²ã—ãªã„ãŸã‚ã®ã‚¬ãƒ¼ãƒ‰ï¼ˆä»»æ„ã ãŒãŠã™ã™ã‚ï¼‰
  if (btnShow && !btnShow.dataset.bound) {
    btnShow.addEventListener('click', () => {
      console.log('[click] show viterbi edges');
      window.__collectViterbiEdges = true;        // åé›†ONï¼ˆã‚ãªãŸã®è¨­è¨ˆã«åˆã‚ã›ã¦ï¼‰
      renderViterbiEdgesPanel?.(true);            // UIæç”»ï¼ˆã‚ã‚‹ãªã‚‰ï¼‰
    });
    btnShow.dataset.bound = '1';
  }

  if (btnHide && !btnHide.dataset.bound) {
    btnHide.addEventListener('click', () => {
      console.log('[click] hide viterbi edges');
      window.__collectViterbiEdges = false;       // åé›†OFF
      renderViterbiEdgesPanel?.(false);
    });
    btnHide.dataset.bound = '1';
  }

  if (btnCsv && !btnCsv.dataset.bound) {
    btnCsv.addEventListener('click', () => {
      console.log('[click] download viterbi edges csv');
      downloadViterbiEdgesCsv();                  // CSV DLé–¢æ•°ï¼ˆå¾Œè¿°ã®å½¢ã§ç”¨æ„ï¼‰
    });
    btnCsv.dataset.bound = '1';
  }
}

// DOMãŒã§ãã¦ã‹ã‚‰ç¢ºå®Ÿã«bind
document.addEventListener('DOMContentLoaded', bindViterbiEdgeButtons);


function renderViterbiEdgesPanel(show){
  const el = document.getElementById('viterbiEdgesPanel');
  if (!el) return;

  if (!show){
    el.style.display = 'none';
    return;
  }

  el.style.display = 'block';

  const rows = window.__viterbiAllEdgeRows || [];
  if (!rows.length){
    el.textContent = 'ï¼ˆã¾ã Viterbiã‚¨ãƒƒã‚¸ãŒåé›†ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚Viterbiã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼‰';
    return;
  }

  // è¦‹ã‚„ã™ã„ã‚ˆã†ã«ä¸Šä½ã ã‘è¡¨ç¤ºï¼ˆå…¨éƒ¨è¡¨ç¤ºã—ãŸã„ãªã‚‰ slice ã‚’å¤–ã™ï¼‰
  const head = rows.slice(0, 200);

  const lines = [];
  lines.push(`Viterbi edges: ${rows.length}ä»¶ï¼ˆå…ˆé ­200ä»¶è¡¨ç¤ºï¼‰`);
  lines.push('from -> to | dist_km | time_min | energy_kj');
  lines.push('------------------------------------------------');

  for (const r of head){
    lines.push(
      `${r.fromName ?? 'from'} -> ${r.toName ?? 'to'} | ` +
      `${(r.distKm ?? '').toString()} | ${(r.timeMin ?? '').toString()} | ${(r.energyKj ?? '').toString()}`
    );
  }

  el.textContent = lines.join('\n');
}

/* ==============================================
   æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒæ©Ÿèƒ½ï¼ˆå¼·åŠ›ç‰ˆï¼‰
   ============================================== */
let manualRouteLayerGroup = null;

// ãƒ‡ãƒ¼ã‚¿ã‚’å®‰å…¨ã«å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
function getGlobalRestGroups() {
  // window.restGroups ã‹ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã® restGroups ã‚’æ¢ã™
  if (typeof restGroups !== 'undefined' && Array.isArray(restGroups)) return restGroups;
  if (window.restGroups && Array.isArray(window.restGroups)) return window.restGroups;
  return [];
}

// 1. ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã®UIã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateManualRouteUI() {
  console.log('[ManualRoute] updateManualRouteUI called');
  
  const container = document.getElementById('manualRouteSelectors');
  if (!container) return;
  container.innerHTML = '';

  const groups = getGlobalRestGroups();
  console.log('[ManualRoute] restGroups count:', groups.length);

  if (!groups || !groups.length) {
    container.innerHTML = '<span style="color:red;">ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚<br>1. ã€Œä¼‘æ†©å ´æ‰€æ¤œç´¢ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚<br>2. ãã‚Œã§ã‚‚å‡ºãªã„å ´åˆã¯ã“ã®ä¸Šã®ã€Œæ›´æ–°ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</span>';
    return;
  }

  // ãƒˆãƒªã‚¬ãƒ¼ã”ã¨ã«ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ä½œæˆ
  groups.forEach((g, idx) => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '8px';

    const label = document.createElement('span');
    label.textContent = `ãƒˆãƒªã‚¬ãƒ¼#${idx + 1}:`;
    label.style.minWidth = '70px';
    label.style.fontWeight = 'bold';

    const select = document.createElement('select');
    select.id = `manualSel_${idx}`;
    select.style.flex = '1';

    // å€™è£œPOIã‚’optionã«è¿½åŠ 
    const pois = Array.isArray(g.pois) ? g.pois : [];
    
    if (pois.length === 0) {
      const opt = document.createElement('option');
      opt.text = '(å€™è£œãªã—)';
      opt.value = -1;
      select.add(opt);
      select.disabled = true;
    } else {
      pois.forEach((p, pIdx) => {
        const name = p.name || `POI${idx}_${pIdx}`;
        const opt = document.createElement('option');
        opt.text = name;
        opt.value = pIdx;
        select.add(opt);
      });
      select.selectedIndex = 0;
    }

    row.appendChild(label);
    row.appendChild(select);
    container.appendChild(row);
  });
  
  console.log('[ManualRoute] UI updated successfully');
}
/* ==============================================
   ã€å†ã€…ä¿®æ­£ç‰ˆã€‘æ‰‹å‹•ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒæ©Ÿèƒ½ï¼ˆè©³ç´°ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»NaNå¯¾ç­–ãƒ»ãƒ­ã‚°ä»˜ãï¼‰
   ============================================== */
window.drawManualComparison = async function() {
  console.log('[ManualRoute] Start');
    
  const infoBox = document.getElementById('manualRouteInfo');
  const btn = document.getElementById('btnDrawManualRoute');
  const profile = document.getElementById('profileSelect')?.value || 'cycling-road'; 

  // æ•°å€¤ã‚’å®‰å…¨ã«å–ã‚Šå‡ºã™ãƒ˜ãƒ«ãƒ‘ãƒ¼
  const safeNum = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  // ç‰©ç†è¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆåŒºé–“ç”¨ï¼‰
  const calcSegEnergy = (seg, mass=75, flat=18) => {
    let e = 0;
    const steps = seg.steps || [];
    // ç°¡æ˜“çš„ã«é«˜ã•ã‚’å–å¾—ã™ã‚‹ã®ã¯é›£ã—ã„ã®ã§ã€flatä¿‚æ•°ã®ã¿ã§è¿‘ä¼¼ã™ã‚‹ã‹ã€
    // ã‚‚ã—Stepsã«elevationæƒ…å ±ãŒãªã‘ã‚Œã°è·é›¢ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ã€‚
    // ã“ã“ã§ã¯ã€å…¨ä½“ã®çµ±ä¸€æ€§ã‚’ä¿ã¤ãŸã‚ã€Œè·é›¢ä¿‚æ•°ã€ã ã‘ã§ç°¡æ˜“æ¯”è¼ƒã™ã‚‹å®‰å…¨ç­–ã‚’ã¨ã‚‹ã‹ã€
    // ã‚ã‚‹ã„ã¯ `energyStepKJ` ãŒä½¿ãˆã‚‹ãªã‚‰ä½¿ã†ã€‚
    // â€»ä»Šå›ã¯æ¯”è¼ƒç”¨ãªã®ã§ã€æ­£ç¢ºæ€§ã‚ˆã‚Šã€Œä¸€æ‹¬ã¨åˆ†å‰²ã®å·®ã€ã‚’è¦‹ã‚‹ãŸã‚ã«
    //   åŒã˜ãƒ­ã‚¸ãƒƒã‚¯(energyStepKJ)ã‚’é€šã™ã‚ˆã†ã«åŠªåŠ›ã™ã‚‹ã€‚
    steps.forEach(st => {
       const d = st.distance || 0;
       // heightæƒ…å ±ã¯ coordinates ã‹ã‚‰å–ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯stepã”ã¨ã®dzãŒä¸æ˜ãªã“ã¨ãŒå¤šã„ã€‚
       // ãã®ãŸã‚ã€Œå¹³åœ°æ›ç®—ã€ã¨ã—ã¦è¨ˆç®—ã™ã‚‹ï¼ˆã‚ºãƒ¬ã®åŸå› ç‰¹å®šã«ã¯ååˆ†ï¼‰
       e += flat * (d/1000); 
    });
    return e;
  };

  if (btn) {
    btn.disabled = true;
    btn.textContent = 'åˆæœŸåŒ–ä¸­...';
  }
  if (infoBox) infoBox.textContent = 'æº–å‚™ä¸­...';

  try {
    // 1. ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯
    let groups = [];
    if (typeof getGlobalRestGroups === 'function') groups = getGlobalRestGroups();
    else if (typeof restGroups !== 'undefined') groups = restGroups;
    else if (window.restGroups) groups = window.restGroups;

    if (!groups || !groups.length) throw new Error('ä¼‘æ†©ãƒˆãƒªã‚¬ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    if (typeof pts === 'undefined' || !Array.isArray(pts)) throw new Error('åœ°ç‚¹ãƒ‡ãƒ¼ã‚¿(pts)ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    
    const start = pts.find(p => p.type === 'start') || pts[0];
    const goal = pts.find(p => p.type === 'goal') || pts[pts.length - 1];
    if (!start || !goal) throw new Error('ã‚¹ã‚¿ãƒ¼ãƒˆã¾ãŸã¯ã‚´ãƒ¼ãƒ«åœ°ç‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');

    // 2. UIå›å
    const picks = [];
    for (let i = 0; i < groups.length; i++) {
      const sel = document.getElementById(`manualSel_${i}`);
      if (!sel || sel.disabled || sel.value == -1) throw new Error(`ãƒˆãƒªã‚¬ãƒ¼#${i+1} ã®POIãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`);
      const p = groups[i].pois[Number(sel.value)];
      if (!p) throw new Error(`ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼: é¸æŠã•ã‚ŒãŸPOIãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
      picks.push(p);
    }

    // 3. åœ°å›³ãƒªã‚»ãƒƒãƒˆ
    if (typeof clearRouteLayers === 'function') clearRouteLayers();
    if (typeof markerLayer !== 'undefined') markerLayer.clearLayers();
    if (typeof clearRestBeams === 'function') clearRestBeams();
    if (typeof manualRouteLayerGroup === 'undefined' || manualRouteLayerGroup === null) {
      manualRouteLayerGroup = L.layerGroup().addTo(map);
    } else {
      manualRouteLayerGroup.clearLayers();
    }

    // 4. APIè¨ˆç®—
    if (btn) btn.textContent = 'ãƒ«ãƒ¼ãƒˆè¨ˆç®—ä¸­...';
    
    const showBatch = document.getElementById('chkManBatch')?.checked;
    const showSeg   = document.getElementById('chkManSeg')?.checked;
    
    // è©³ç´°æ¯”è¼ƒç”¨ã®é…åˆ—
    // { dist(km), time(min), energy(kJ) }
    const batchLegs = [];
    const segLegs   = [];

    // --- A. ä¸€æ‹¬ (Batch) ---
    if (showBatch) {
      const wps = [start, ...picks, goal].map(p => ({ lat: p.lat, lon: p.lon, name: p.name || 'WP' }));
      const out = await routeLegStatsForWaypoints(wps, profile);
      
      if (out && out.feature) {
        L.geoJSON(out.feature, {
          style: { color: '#0055aa', weight: 8, opacity: 0.6 }
        }).bindTooltip("ä¸€æ‹¬ãƒ«ãƒ¼ãƒˆ").addTo(manualRouteLayerGroup);
        
        // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆåŒºé–“ï¼‰ã”ã¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
        const segments = out.feature.properties.segments || [];
        
        // stats.energy ã¯ã€Œã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã€ã®é…åˆ—ãªã®ã§ã€åŒºé–“ã«åˆ‡ã‚Šåˆ†ã‘ã‚‹ã®ã¯é›£ã—ã„ã€‚
        // ã“ã“ã§ã¯ segments æƒ…å ±ã‹ã‚‰è·é›¢ã¨æ™‚é–“ã‚’ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯å…¨ä½“ã®æ¯”ç‡ç­‰ã§ç°¡æ˜“é…åˆ†ã™ã‚‹ã‹
        // ã‚‚ã—ãã¯ã€Œè·é›¢ãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“ã‚¨ãƒãƒ«ã‚®ãƒ¼ã€ã§æ¯”è¼ƒã™ã‚‹ã€‚
        // â˜…æ­£ç¢ºã‚’æœŸã™ãŸã‚ã€stats.energyï¼ˆç´¯ç©ï¼‰ã‚’ä½¿ã£ã¦åŒºé–“å·®åˆ†ã‚’ã¨ã‚‹
        
        let processedSteps = 0;
        let prevCumE = 0;
        
        segments.forEach((seg, idx) => {
           // ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«å«ã¾ã‚Œã‚‹ã‚¹ãƒ†ãƒƒãƒ—æ•°
           const stepCount = (seg.steps || []).length;
           
           // stats.energy ã‹ã‚‰ã“ã®åŒºé–“ã®çµ‚äº†åœ°ç‚¹ã®å€¤ã‚’å–å¾—
           // (stats.energyã¯ç´¯ç©é…åˆ—ã¨ä»®å®š)
           let currentLegE = 0;
           if (out.stats && Array.isArray(out.stats.energy) && out.stats.energy.length > 0) {
               // åŒºé–“ã‚¨ãƒãƒ«ã‚®ãƒ¼ = (åŒºé–“çµ‚ã‚ã‚Šã®ç´¯ç©E) - (åŒºé–“å§‹ã¾ã‚Šã®ç´¯ç©E)
               // stats.energyã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯å…¨ã‚¹ãƒ†ãƒƒãƒ—é€šã—ç•ªå·
               const endIndex = Math.min(processedSteps + stepCount - 1, out.stats.energy.length - 1);
               const cumAtEnd = safeNum(out.stats.energy[endIndex]);
               currentLegE = cumAtEnd - prevCumE;
               prevCumE = cumAtEnd;
               processedSteps += stepCount;
           } else {
               // statsãŒãªã„å ´åˆã¯ç°¡æ˜“è¨ˆç®—
               currentLegE = calcSegEnergy(seg);
           }

           batchLegs.push({
               dist: safeNum(seg.distance) / 1000,
               time: safeNum(seg.duration) / 60,
               energy: currentLegE
           });
        });
      }
    }

    // --- B. åŒºé–“ç©ä¸Š (Segmented) ---
    if (showSeg) {
      const points = [start, ...picks, goal];
      
      for (let i = 0; i < points.length - 1; i++) {
        const from = points[i];
        const to = points[i+1];
        
        let legRes = { dist:0, time:0, energy:0 };

        try {
          if (typeof calcLegCostWithApi === 'function') {
             const leg = await calcLegCostWithApi(from, to, profile);
             const e = leg.energyKj ?? leg.energy_kJ ?? leg.energy ?? 0;
             const d = leg.distKm   ?? leg.dist_km   ?? leg.dist   ?? 0;
             const t = leg.timeMin  ?? leg.time_min  ?? leg.time   ?? 0;

             legRes = { dist: safeNum(d), time: safeNum(t), energy: safeNum(e) };

             // æç”»
             const res = await dir({ coordinates: [[from.lon, from.lat], [to.lon, to.lat]], elevation:true }, profile);
             if (res?.features?.[0]) {
                 L.geoJSON(res.features[0], {
                   style: { color: '#aa0000', weight: 4, dashArray: '10, 10', opacity: 1.0 }
                 }).bindTooltip(`åŒºé–“ ${i+1}`).addTo(manualRouteLayerGroup);
             }
          }
        } catch(err) { console.error(err); }
        
        segLegs.push(legRes);
      }
    }

    // 5. çµæœè¡¨ç¤º (HTMLç”Ÿæˆ)
    const fmt = (n, d=1) => safeNum(n).toFixed(d);
    // å·®åˆ†ãŒ0.1ä»¥ä¸Šãªã‚‰èµ¤ãã™ã‚‹
    const diffColor = (a, b) => (Math.abs(safeNum(a) - safeNum(b)) > 0.1) ? '#d00' : '#888';
    
    // åˆè¨ˆè¨ˆç®—
    const sumBatch = batchLegs.reduce((a,b)=>({dist:a.dist+b.dist, time:a.time+b.time, energy:a.energy+b.energy}), {dist:0,time:0,energy:0});
    const sumSeg   = segLegs.reduce((a,b)=>({dist:a.dist+b.dist, time:a.time+b.time, energy:a.energy+b.energy}), {dist:0,time:0,energy:0});

    let html = '<div style="font-size:0.9rem; line-height:1.4;">';

    // --- åˆè¨ˆæ¯”è¼ƒ ---
    html += '<div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-bottom:8px;">';
    
    if (showBatch) {
      html += `
      <div style="padding:6px; border:1px solid #0055aa; border-radius:4px; background:#f0f8ff;">
        <div style="font-weight:bold; color:#0055aa; border-bottom:1px solid #cceeff; margin-bottom:4px;">â–  ä¸€æ‹¬ (Total)</div>
        D: ${fmt(sumBatch.dist, 2)} km<br>
        T: ${fmt(sumBatch.time, 1)} min<br>
        E: <b>${fmt(sumBatch.energy, 0)} kJ</b>
      </div>`;
    }
    if (showSeg) {
      html += `
      <div style="padding:6px; border:1px solid #aa0000; border-radius:4px; background:#fff5f5;">
        <div style="font-weight:bold; color:#aa0000; border-bottom:1px solid #ffcccc; margin-bottom:4px;">â–  ç©ä¸Š (Total)</div>
        D: ${fmt(sumSeg.dist, 2)} km<br>
        T: ${fmt(sumSeg.time, 1)} min<br>
        E: <b>${fmt(sumSeg.energy, 0)} kJ</b>
      </div>`;
    }
    html += '</div>';

    // --- è©³ç´°æ¯”è¼ƒãƒ†ãƒ¼ãƒ–ãƒ« ---
    if (showBatch && showSeg) {
        html += `<table style="width:100%; border-collapse:collapse; font-size:0.85rem; margin-top:8px;">
          <tr style="background:#eee; text-align:center;">
            <th style="border:1px solid #ddd; padding:2px;">åŒºé–“</th>
            <th style="border:1px solid #ddd; padding:2px;">é …ç›®</th>
            <th style="border:1px solid #ddd; padding:2px; color:#0055aa;">ä¸€æ‹¬</th>
            <th style="border:1px solid #ddd; padding:2px; color:#aa0000;">ç©ä¸Š</th>
            <th style="border:1px solid #ddd; padding:2px;">å·®åˆ†</th>
          </tr>`;

        const maxLen = Math.max(batchLegs.length, segLegs.length);
        for(let i=0; i<maxLen; i++){
            const b = batchLegs[i] || {dist:0, time:0, energy:0};
            const s = segLegs[i]   || {dist:0, time:0, energy:0};
            const label = (i===0) ? 'Start' : (i===maxLen-1 ? 'Goal' : `POI ${i}`);
            const nextLabel = (i===maxLen-1) ? '' : (i===maxLen-2 ? 'Goal' : `POI ${i+1}`);
            
            // è·é›¢è¡Œ
            html += `
            <tr>
              <td rowspan="3" style="border:1px solid #ddd; text-align:center; vertical-align:middle; background:#fafafa;">
                <b>Leg ${i+1}</b>
              </td>
              <td style="border:1px solid #ddd; padding:2px;">è·é›¢</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(b.dist,2)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(s.dist,2)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; color:${diffColor(s.dist, b.dist)}">
                ${fmt(s.dist - b.dist, 2)}
              </td>
            </tr>`;
            // æ™‚é–“è¡Œ
            html += `
            <tr>
              <td style="border:1px solid #ddd; padding:2px;">æ™‚é–“</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(b.time,1)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;">${fmt(s.time,1)}</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; color:${diffColor(s.time, b.time)}">
                ${fmt(s.time - b.time, 1)}
              </td>
            </tr>`;
            // ã‚¨ãƒãƒ«ã‚®ãƒ¼è¡Œ
            html += `
            <tr style="border-bottom:2px solid #ccc;">
              <td style="border:1px solid #ddd; padding:2px;">En(kJ)</td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;"><b>${fmt(b.energy,0)}</b></td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right;"><b>${fmt(s.energy,0)}</b></td>
              <td style="border:1px solid #ddd; padding:2px; text-align:right; font-weight:bold; color:${diffColor(s.energy, b.energy)}">
                ${fmt(s.energy - b.energy, 0)}
              </td>
            </tr>`;
        }
        html += `</table>`;
    }
    
    html += '</div>';
    if (infoBox) infoBox.innerHTML = html;

    // ãƒãƒ¼ã‚«ãƒ¼ãƒ»ã‚ºãƒ¼ãƒ 
    if (typeof setComboMarkers === 'function') setComboMarkers(start, picks, goal);
    if (typeof map !== 'undefined') {
       const allLayers = [];
       if (manualRouteLayerGroup) manualRouteLayerGroup.eachLayer(l => allLayers.push(l));
       if (typeof markerLayer !== 'undefined') markerLayer.eachLayer(l => allLayers.push(l));
       if (allLayers.length > 0) {
         const group = new L.featureGroup(allLayers);
         const b = group.getBounds();
         if (b.isValid()) map.fitBounds(b.pad(0.1));
       }
    }

  } catch (e) {
    console.error(e);
    alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n' + e.message);
    if (infoBox) infoBox.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + e.message;
  } finally {
    if (btn) {
      btn.disabled = false;
      btn.textContent = 'é¸æŠã—ãŸPOIã§æ¯”è¼ƒæç”»';
    }
  }
};
</script>
</body>
</html>













