<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>自転車ルート比較＋休憩（統合版 完全）</title>

<!-- ライブラリ -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map { height: 520px; width: 100%; }
html,body { height: 100%; margin: 0; padding: 0; }
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move;display:flex;justify-content:space-between;align-items:center;gap:8px}
#pointList li small{color:#666}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px;cursor:pointer}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
#routeButtons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
#routeButtons button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#f4f4f4;cursor:pointer}
#routeButtons button.active{background:#dfefff;border-color:#7aa7ff}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.92rem}
</style>
</head>
<body>

<!-- 操作パネル -->
<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="searchBtn">検索</button>
  <button id="locBtn">現在地追加</button>
  <button id="drawBtn">休憩場所検索</button>
  <button id="solveCombBtn">ルート検索</button>


  <label>プロファイル
    <select id="profileSelect">
      <option value="cycling-road" selected>ロードバイク</option>
      <option value="cycling-regular">自転車（一般）</option>
    </select>
  </label>
</div>

<!-- ▼▼ ここに追加：地名検索候補リスト ▼▼ -->
<ul id="searchSuggestions"
    style="list-style:none;margin:4px 0;padding:0 8px;background:#fff;
           border:1px solid #ccc;max-height:150px;overflow:auto;">
</ul>

<!-- POI 検索設定 -->
<div class="section">
  <details open>
  <summary>休憩地点まわりのPOI</summary>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <label><input type="checkbox" id="poiToggle" checked> POI表示</label>
    <label>初期半径 <input id="poiRadius" type="number" value="50000" min="50" step="50"> m</label>
    <label>件数上限（近い順） <input id="poiLimit" type="number" value="5" min="1" step="1"> 件</label>
    <label><input type="checkbox" id="chkConvenience" checked> コンビニ</label>
    <label><input type="checkbox" id="chkSuper" checked> スーパー</label>
    <label><input type="checkbox" id="chkDrug"  checked> ドラッグストア</label>
  </div>
</details>
</div>

<!-- 休憩設定パネル -->
<div class="section">
  <details open>
    <summary>休憩設定</summary>
    <div style="display:flex;flex-wrap:wrap;gap:10px">
      <label>基準
        <select id="restBasis">
          <option value="time">時間</option>
          <option value="energy" selected>kJ</option>
        </select>
      </label>
      <label>時間間隔 <input id="restMinutes" type="number" value="60" min="15" step="5"> 分</label>
      <label>kJしきい値 <input id="restKJ" type="number" value="500" min="100" step="50"> kJ</label>
    </div>

    <div style="margin-top:6px">
      <label><input type="checkbox" id="optAccum"> 積算トリガ</label><br>
      <label><input type="checkbox" id="optStatTrigger"> 統計トリガ</label>
      平均 <input id="statMean" type="number" value="20" step="1">km
      分散 <input id="statVar" type="number" value="9" step="0.5">km²<br>
      <label><input type="checkbox" id="optPercentTrigger" checked> 割合トリガ</label>
      %ごと <input id="percentStep" type="number" value="25" step="1"> %
      <select id="percentMetric">
        <option value="distance">距離</option>
        <option value="energy">エネルギー</option>
        <option value="time">時間</option>
      </select>
    </div>
  </details>
</div>

<!-- 休憩ログ表示 -->
<div class="section">
  <details open>
    <summary>休憩トリガ・ヒット状況</summary>
    <div id="restDebug" style="white-space:pre-wrap;font-size:0.9em"></div>
  </details>
</div>

<!-- ▼▼ ここに追加：休憩地点リスト表示 ▼▼ -->
<div class="section">
  <details open>
    <summary>休憩地点リスト</summary>
    <ul id="restListPanel"
        style="list-style:none;margin:0;padding:0;font-size:0.9rem"></ul>
  </details>
</div>

<!-- 休憩トリガー別の候補POI -->
<div class="section">
  <details open>
    <summary>休憩トリガー別の候補POI</summary>
    <ol id="restPoiPanel" style="margin:0;padding-left:1.1rem;font-size:0.9rem"></ol>
  </details>
</div>

<div class="section">
  <details open>
    <summary>デバッグ（累積・射影）</summary>
    <div id="dbgCums" style="font-family:ui-monospace,monospace;white-space:pre-wrap;font-size:12px;"></div>
  </details>
</div>


<!-- 地点リストと地図 -->
<ul id="pointList"></ul>
<div id="map"></div>

<!-- ルート切替ボタン -->
<div id="routeButtons" class="section">
  <button id="btnShowShortest">最短ルート表示</button>
  <button id="btnShowFastest">最速ルート表示</button>
  <button id="btnShowSlope">勾配考慮ルート表示</button>
  <!-- ▼ 追加 -->
  <button id="btnShowArterial">幹線優先ルート表示</button>
</div>


<!-- ルート検索アルゴリズム -->
<div class="section">
  <label>探索アルゴリズム
    <select id="algoSelect">
      <option value="greedy" selected>等間隔貪欲（高速・ゼロAPI）</option>
      <option value="beam3">ビームサーチ（幅3・ゼロAPI）</option>
      <option value="bruteforce">総当たり（API多め・高精度）</option>
      <option value="dp">DP（最短路・ゼロAPI）</option>
    </select>
  </label>
  <small style="color:#666;margin-left:8px">※総当たりはAPI制限に注意</small>
</div>

<!-- 評価ウェイト（整列/直交/トリガー距離） -->
<div class="section" id="scoreWeightsSection">
  <details open>
    <summary>評価ウェイト（整列/直交/トリガー距離）</summary>
    <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:center">
      <label>整列（経路上の累積距離ずれ）
        <input id="wAlign" type="number" step="0.1" min="0" value="1.0" style="width:86px">
      </label>
      <label>直交（経路からの垂直距離）
        <input id="wPerp" type="number" step="0.1" min="0" value="1.0" style="width:86px">
      </label>
      <label>トリガー距離（休憩トリガ点からの距離）
        <input id="wTrig" type="number" step="0.1" min="0" value="0.5" style="width:86px">
      </label>
      <button id="btnWeightsReset" style="margin-left:4px">デフォルトに戻す</button>
    </div>
    <small style="color:#666;display:block;margin-top:6px">
      値が大きいほど<strong>その誤差を強くペナルティ</strong>します（=候補が選ばれにくくなります）。
      値を0にすると、その軸のペナルティは無効化されます。
    </small>
  </details>
</div>



<!-- サマリー -->
<div id="summary">
  <div id="routeInfo">未計算</div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- 区間統計（各ルート） -->
<div class="section">
  <h3>区間統計（各ルート）</h3>
  <div id="legSummaryAll" style="font-size:0.9rem;"></div>
</div>

<!-- 組み合わせ評価：上位3件 -->
<div class="section">
  <h3>最適な休憩組み合わせ（上位3件）</h3>
  <div id="comboTop3" style="font-size:0.9rem;"></div>
</div>


<!-- グラフ描画＆ダウンロード -->
<div id="charts" style="display:none;">
  <canvas id="energyChart"></canvas>
</div>
<div class="section">
  <button id="btnDownloadTime" disabled>PNG（時間×累積kJ）</button>
  <button id="btnDownloadDist" disabled>PNG（距離×累積kJ）</button>
</div>

<script>
/* ====== 設定 ====== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; // ←★OpenRouteService APIキーを入れてください
const ORS_ROOT = 'https://api.openrouteservice.org';

/* ====== ヘルパ ====== */
let map, pts=[], markerLayer, routeLayers={}, lastDirTs=0;
let routeData = { shortest:null, fastest:null, slope:null, arterial:null };

// ▼▼ ここに追加：休憩リスト用変数 ▼▼
let restList = []; // 休憩地点を保存
let restGroups = []; 

const ICON = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
const ICONS = {start:ICON('green'),via:ICON('blue'),goal:ICON('red')};

const OVERPASS_MIN_INTERVAL = 1800; // 1.8s（必要なら 2000～2500 まで上げてOK）
let __overpassLastTs = 0;
const __overpassCache = new Map();  // key=query文字列, value=JSON

function $(id){return document.getElementById(id);}
function formatDist(m){return (m/1000).toFixed(2)+' km';}
function formatDur(s){const m=Math.round(s/60);return m<60? m+' 分' : (Math.floor(m/60)+' 時間 '+(m%60)+' 分');}

/* ====== 初期化 ====== */
window.addEventListener('DOMContentLoaded',()=>{
  /* ===== 評価ウェイト UI 初期化 ===== */
  function reflectWeightsToInputs(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    if(!WA || !WP || !WT) return;
    WA.value = String(SCORE_WEIGHTS.wAlign);
    WP.value = String(SCORE_WEIGHTS.wPerp);
    WT.value = String(SCORE_WEIGHTS.wTrig);
  }

  function saveWeights(){
    localStorage.setItem('route_score_weights', JSON.stringify(SCORE_WEIGHTS));
  }

  function bindWeightsUI(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    const RB = document.getElementById('btnWeightsReset');

    if(WA){
      WA.addEventListener('input', ()=>{
        const v = Number(WA.value);
        SCORE_WEIGHTS.wAlign = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WP){
      WP.addEventListener('input', ()=>{
        const v = Number(WP.value);
        SCORE_WEIGHTS.wPerp = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WT){
      WT.addEventListener('input', ()=>{
        const v = Number(WT.value);
        SCORE_WEIGHTS.wTrig = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(RB){
      RB.addEventListener('click', ()=>{
        SCORE_WEIGHTS = { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
        saveWeights();
        reflectWeightsToInputs();
      });
    }
  }

  // ページ読み込み時に反映＆バインド
  reflectWeightsToInputs();
  bindWeightsUI();

  
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {attribution:'©OpenStreetMap'}).addTo(map);

  // 検索ボタン：検索後に入力欄クリア
  $('searchBtn').onclick = () => {
    const val = $('placeInput').value.trim();
    if (!val) return;
    nomSearch(val);
    $('placeInput').value = ''; // 入力欄リセット
  };

  $('locBtn').onclick=()=>navigator.geolocation.getCurrentPosition(
      p=>addPoint({name:'現在地',lat:p.coords.latitude,lon:p.coords.longitude}),
      ()=>alert('現在地取得失敗'));
  $('drawBtn').onclick=drawRoutes;

  $('solveCombBtn').onclick = async () => {
  try {
    // 0) 前提チェック
    if (!routeData.fastest){
      alert('先に「休憩場所検索」を実行してください。');
      return;
    }
    if (!Array.isArray(restGroups) || !restGroups.length){
      alert('休憩トリガーがありません。');
      return;
    }
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    if (poiGroups.every(a => !a.length)){
      alert('各休憩トリガーにPOIがありません。POI設定（カテゴリ/半径/件数）を見直してください。');
      return;
    }
    ensureProjections();
    injectAlgoDebugButtons(window.__cumTotals);

    // 1) 入力＆共有データ取得
    const algo = $('algoSelect').value; // 'greedy' | 'beam3' | 'bruteforce'
    const start = pts.find(p=>p.type==='start') || pts[0];
    const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
    if (!start || !goal){
      alert('スタート/ゴールが見つかりません。');
      return;
    }
    const cumTotals = window.__cumTotals; // drawRoutes() 実行後に buildCums() で設定済みの累積総量

    // 2) アルゴリズム分岐
    if (algo === 'greedy'){
  // 等間隔ターゲットに近い「上位K候補」を各トリガーから集める
  const K = 3; // ここを2～5で調整可
  const candGroups = greedyTopKCandidates(restGroups, cumTotals, K);

  // 直積（上限をかけて暴走防止）
  const combos = enumerateCombinations(candGroups, /*perGroupLimit=*/K, /*hardCap=*/60);
  if (!combos.length){
    alert('組み合わせ候補が作れませんでした（候補不足）。');
    return;
  }
      

  // 全候補を「累積差分の近似評価」で採点（ゼロAPI）
  const scored = combos.map(cmb => {
    const picksByTrigger = cmb; // null含む（未採用も許容）
    const ev = evalByCums(restGroups, picksByTrigger, cumTotals); // dist/time/energy のσ合計でスコア
    return {
      score: ev.score,
      stats: ev.stats,
      picksByTrigger,
      picks: picksByTrigger.filter(Boolean) // 表示用に null 除去
    };
  });

  // スコア昇順で上位3件を表示
  scored.sort((a,b)=>a.score-b.score);
  showTop3Combos(scored.slice(0,3));
  return;
}


if (algo === 'beam3'){
  // --- ビームサーチ（幅3・ゼロAPI） ---
  // 「候補があるトリガー数」は必ず採用する
  const triggersWithCand = (restGroups || []).reduce((n, g) => {
    const valid = (g?.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    return n + (valid.length ? 1 : 0);
    }, 0);
  const top = beamSearch(restGroups, cumTotals, /*width*/3, /*minRest*/triggersWithCand, /*nullPenalty*/1e6, /*forbidNullWhenCand*/true);
  top.forEach(t => t.picks = t.picksByTrigger.filter(Boolean));
  showTop3Combos(top);
  return;
}


    if (algo === 'bruteforce'){
      // --- 総当たり（API多め・高精度）---
      // ※CORS/429に注意。可能ならプロキシ＋バックオフ/キャッシュを導入してください。
      const perGroupLimit = Math.max(1, Math.min(3, Number($('poiLimit').value)||3)); // 各トリガー最大件数
      const combos = enumerateCombinations(poiGroups, perGroupLimit, 60);             // 総当たり上限60通り
      if (!combos.length){
        alert('組み合わせ候補が作れませんでした。');
        return;
      }

      const profile = $('profileSelect').value; // ORSプロファイル（cycling-road 等）
      const results = [];

      // 逐次でAPI負荷を抑えつつ評価
      for (const cmb of combos){
        const picks = cmb.filter(Boolean); // null除外
        const wps = [start, ...picks, goal].map(p=>({
          lat: p.lat, lon: p.lon, name: p.name || 'POI'
        }));

        try {
          // ORS で実際の経路を引いて、既存の calcLegStats でレグ統計を算出
          const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);
          const rawScore = comboScore(stats); // 距離/時間/エネの標準偏差の合計
       const weights  = picks.map(p => Number(p?._w) || 1);
       const meanW    = weights.length ? (weights.reduce((a,b)=>a+b,0)/weights.length) : 1;
       const score    = rawScore / Math.max(0.1, meanW); // 重みが高い組合せを優遇
       results.push({ score, rawScore, feature, picks, picksByTrigger: cmb, stats });
        } catch(e){
          console.warn('combo route fail', e);
          // 失敗した組合せはスキップ
        }
      }

      // スコア昇順に上位3件
      results.sort((a,b)=>a.score-b.score);
      showTop3Combos(results.slice(0,3));
      return;
    }
    if (algo === 'dp'){
  const best = dpSearch(restGroups, cumTotals);
  best.picks = best.picksByTrigger.filter(Boolean);
  showTop3Combos([best]);  // DPは最適解1本を出す
  return;
}

    // 未知の値（保険）
    alert('未知のアルゴリズム指定です。');
  } catch (err){
    console.error(err);
    alert('ルート探索でエラー: ' + (err.message || err));
  }
};

  new Sortable($('pointList'),{
    animation:150,
    onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li.dataset.idx]);fixType();drawList();}
  });

  $('btnShowShortest').onclick = ()=> toggleSingleRoute('shortest', $('btnShowShortest'));
  $('btnShowFastest').onclick  = ()=> toggleSingleRoute('fastest',  $('btnShowFastest'));
  $('btnShowSlope').onclick    = ()=> toggleSingleRoute('slope',    $('btnShowSlope'));
 $('btnShowArterial').onclick = ()=> toggleSingleRoute('arterial', $('btnShowArterial'));

  // グラフダウンロードボタン
  $('btnDownloadTime').onclick = ()=>{
    if(!routeData.fastest){alert('まずルート計算してください');return;}
    const s = buildEnergySeries(routeData.fastest,75,18,true);
    if(s.labels.length>1) downloadLineChart(s);
  };
  $('btnDownloadDist').onclick = ()=>{
    if(!routeData.fastest){alert('まずルート計算してください');return;}
    const s = buildEnergySeries(routeData.fastest,75,18,false);
    if(s.labels.length>1) downloadLineChart(s);
  };
});

/* ====== 地点管理 ====== */
function addPoint(p){
  p.type=pts.length?'':'start';
  pts.forEach(d=>{if(d.type==='goal')d.type='via';});
  pts.push(p);
  if(pts.length>1) pts[pts.length-1].type='goal';
  drawList();
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li.dataset.idx=i;
    const name = p.name + (p.isRest? '（休憩）':'');
    li.innerHTML = `<span>${name}${p.isRest? ' <small>(' + p.lat.toFixed(5)+','+p.lon.toFixed(5)+')</small>':''}</span><button class="del">×</button>`;
    li.querySelector('.del').onclick=()=>{pts.splice(i,1); fixType(); drawList();};
    ul.appendChild(li);
  });
}

/* ====== 検索処理（候補表示対応版） ====== */
async function nomSearch(q){
  const url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  const arr=await (await fetch(url)).json();
  const sug=$('searchSuggestions');
  sug.innerHTML='';
  if(!arr.length){alert('見つかりません');return;}
  // 候補をリスト表示
  arr.forEach(o=>{
    const li=document.createElement('li');
    li.textContent=o.display_name;
    li.style.cursor='pointer';
    li.style.padding='4px';
    li.onmouseenter=()=>li.style.background='#eee';
    li.onmouseleave=()=>li.style.background='';
    li.onclick=()=>{
      addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
      sug.innerHTML=''; // クリック後クリア
      $('placeInput').value='';
    };
    sug.appendChild(li);
  });
}


/* ====== ORS ====== */
async function post(url,body){
  const r=await fetch(url,{
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':ORS_KEY},
    body:JSON.stringify(body)
  });
  if(!r.ok) throw new Error(r.status);
  return r.json();
}
async function dir(body,profile){
  const wait=1100-(Date.now()-lastDirTs); if(wait>0) await new Promise(r=>setTimeout(r,wait));
  const d=await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`,body);
  lastDirTs=Date.now();
  return d;
}

/* ====== ルート表示関連 ====== */
function clearRouteLayers(){
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); });
  routeLayers={};
}
function setActiveButton(btn){
  document.querySelectorAll('#routeButtons button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
}
function showSingleRoute(type, noFit){
  clearRouteLayers();
  const colorMap = { shortest:'#ff0000', fastest:'#0066ff', slope:'#ff9900', arterial:'#00b26b' };
  const f = routeData[type];
  if(!f){ alert('まだ計算していません'); return; }
  routeLayers[type] = L.geoJSON(f, { style:{ color: colorMap[type], weight: 6 } }).addTo(map);
  if(!noFit) map.fitBounds(routeLayers[type].getBounds().pad(0.1));
}
function toggleSingleRoute(type, btn){
  showSingleRoute(type);
  setActiveButton(btn);
}

/* ====== ルート計算・休憩・POI ====== */
async function drawRoutes(){
  if(pts.length<2){alert('2地点以上登録してください');return;}

  clearRouteLayers();
  if(markerLayer) map.removeLayer(markerLayer);

  markerLayer=L.layerGroup().addTo(map);
  
  pts.forEach(p=>markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ICONS[p.type||'via']}).bindTooltip(p.name)));

  const coords=pts.map(p=>[p.lon,p.lat]);
  const profile = $('profileSelect').value;
  const base={coordinates:coords,elevation:true,extra_info:['steepness']};

  try{
    const shortest = await dir({...base, preference:'shortest'}, profile);
    const fastest  = await dir({...base, preference:'fastest'},  profile);

    let slope = shortest.features[0];
    let arterial = fastest.features[0];
    if(coords.length===2){
      const alt = await dir({...base, preference:'shortest',
        alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}, profile);
      const feats = alt.features || [];
      if(feats.length){
        function steepSum(f){
          const vals=((f.properties||{}).extras||{}).steepness?.values||[];
          let s=0; for(const v of vals){ s+=Math.abs(v[2]||0); }
          return s;
        }
        slope = feats.reduce((a,b)=> steepSum(a)<steepSum(b)?a:b);
        // 幹線優先（代替経路＋fastest の中からスコア最大）
        arterial = feats.concat(fastest.features || [])
        .reduce((best,cand)=> arterialScore(cand) > arterialScore(best) ? cand : best, arterial);
      }
    }

    routeData.shortest = shortest.features[0];
    routeData.fastest  = fastest.features[0];
    routeData.slope    = slope;
    routeData.arterial = arterial;

    const s1 = routeData.shortest.properties.summary;
    const s2 = routeData.fastest.properties.summary;
    const s3 = routeData.slope.properties.summary;
    $('routeInfo').innerHTML =
      `<b>最短</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>最速</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>勾配</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}<br>`+
      (routeData.arterial ? `<b>幹線</b> ${formatDist(routeData.arterial.properties.summary.distance)} / ${formatDur(routeData.arterial.properties.summary.duration)}` : '');
    $('distanceScore').textContent = '距離差（最速-最短）: '+(s2.distance - s1.distance).toFixed(0)+' m';

    /* ===== 休憩地点挿入 ===== */
    const mass = 75; // 体重+バイク質量(例)
    const flat = 18; // 平坦係数
    const baseFeature = routeData.arterial || routeData.fastest;
    const rests = await makeRestPoints(baseFeature, mass, flat);

    restGroups = (rests || []).map(r => ({ rest: r, pois: [] }));

    restList = []; // 前回のリストをリセット

    if (rests.length) {
      // リストに挿入（ゴール直前）
     rests.forEach(r => {
       pts.splice(pts.length-1, 0,
                  { name:'休憩', lat:r.lat, lon:r.lon, type:'via', isRest:true });
        // ▼ r が有効なスコープ内で push
        restList.push({distance:(r.routeD/1000).toFixed(2), lat:r.lat, lon:r.lon});
      });
      drawList();
      updateRestListPanel(); // 休憩地点リスト表示更新

      // 休憩マーカー
      for (const r of rests) {
        L.marker([r.lat, r.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        }).bindTooltip('休憩').addTo(markerLayer);
      }

      // POI検索（半径固定・近い順に n 件）
if ($('poiToggle').checked) {
  const baseRadius = Number($('poiRadius').value) || 50000;
  const limit = Math.max(1, Number($('poiLimit').value) || 5);

  for (let idx = 0; idx < rests.length; idx++) {
    const r = rests[idx];
    try {
      const pois = await fetchPoisAround(r.lat, r.lon, baseRadius, limit);
      logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 半径${baseRadius}m → ${pois.length}件（近い順）`);

      // ▼ 追加：この休憩トリガーのPOIを保存
      if (restGroups[idx]) {
        restGroups[idx].pois = pois.map(p => ({ ...p, triggerIndex: idx }));
      }
        
      // 既存：マップに描画
      pois.forEach(po => {
        L.marker([po.lat, po.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple.png',
            iconSize: [24, 24],
            iconAnchor: [12, 24]
          })
        }).bindTooltip(`${po.name}${typeof po.distFromTriggerM === 'number' ? ` (${formatDist(po.distFromTriggerM)})` : ''}`).addTo(markerLayer);
      });
    } catch (e) {
      logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 取得失敗`);
    }
  }

  // ▼ 追加：パネルへ反映
  ensureProjections();
  updateRestPoiPanel();
  
}

    }

// デフォルト表示は幹線優先（なければ最速）
const prefer = routeData.arterial ? 'arterial' : 'fastest';
showSingleRoute(prefer, true);
setActiveButton(prefer === 'arterial' ? $('btnShowArterial') : $('btnShowFastest'));


    // 区間統計を表示
    await showRouteLegSummary();

    // グラフボタン有効化
    $('btnDownloadTime').disabled = false;
    $('btnDownloadDist').disabled = false;

  }catch(e){
    console.error(e);
    alert('ルート取得失敗: '+e.message);
  }
}

/* ===== 休憩トリガー関連 ===== */
function logRest(msg){ $('restDebug').textContent += msg + "\n"; }
function energyStepKJ(dist,dz,mass,flat=18){
  return flat*(dist/1000)+Math.max(dz,0)*mass*9.80665/1000;
}
async function totalEnergyKJ(feature,mass,flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments||[];
  let tot=0;
  for(const s of segs){
    for(const st of s.steps||[]){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz = coords[i1].length>=3 ? (coords[i1][2]-coords[i0][2]) : 0;
      tot += energyStepKJ(d,dz,mass,flat);
    }
  }
  return tot;
}
async function makeRestPoints(feature,mass,flat){
  const coords=feature.geometry.coordinates;
  const segs=(feature.properties.segments||[]);
  const hasEle = coords[0].length>=3;
  const cumDist=[0];
  for(let i=1;i<coords.length;i++){
    cumDist[i]=cumDist[i-1]+L.latLng(coords[i][1],coords[i][0]).distanceTo([coords[i-1][1],coords[i-1][0]]);
  }

  const basis=$('restBasis').value;
  const thr=basis==='time' ? Number($('restMinutes').value)*60 : Number($('restKJ').value);
  let raw=[];

  // 積算トリガ
  if($('optAccum').checked){
    let acc=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0, t=st.duration||0;
        const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
        const dE = energyStepKJ(d,dz,mass,flat);
        acc += (basis==='time') ? t : dE;
        if(acc >= thr){
          raw.push({lat:coords[i1][1],lon:coords[i1][0],routeD:cumDist[i1]});
          logRest(`[ACCUM] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);
          acc=0;
        }
      }
    }
  }

  // 統計トリガ（安全化パッチ）
  if ($('optStatTrigger').checked) {
    const meanRaw = Number($('statMean').value);
    const varRaw  = Number($('statVar').value);

    const mean  = Number.isFinite(meanRaw) ? meanRaw : 0;
    const sigma = (Number.isFinite(varRaw) && varRaw >= 0) ? Math.sqrt(varRaw) : 0;

    // Box-Muller：0 の log 回避
    const normal = () => {
      let u = Math.random(); if (u <= 1e-12) u = 1e-12;
      let v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    };

    // 休憩間隔の下限（km）。必要なら 0.3～1.0 で好み調整
    const MIN_KM = 0.5;

    let target = Math.max(MIN_KM, mean + sigma * normal());
    let accKm  = 0;

    for (const s of segs) {
      for (const st of s.steps || []) {
        const [i0, i1] = st.way_points || [0, 0];
        const d = st.distance || 0;        // m
        accKm += d / 1000;

        if (accKm >= target) {
          raw.push({ lat: coords[i1][1], lon: coords[i1][0], routeD: cumDist[i1] });
          logRest(`[STAT] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);

          // 次ターゲットも下限を確保
          target = Math.max(MIN_KM, mean + sigma * normal());
          accKm = 0;
        }
      }
    }
  }


   // 割合トリガ（安全化パッチ）
  if ($('optPercentTrigger').checked) {
    // 入力値の正規化（1%～90%に丸め：好みで調整可）
    let stepPct = Number($('percentStep').value) / 100;
    if (!Number.isFinite(stepPct)) stepPct = 0.25;
    stepPct = Math.min(0.9, Math.max(0.01, stepPct));

    const metric = $('percentMetric').value;

    const totalDist   = feature.properties.summary.distance;     // m
    const totalTime   = feature.properties.summary.duration;     // s
    const totalEnergy = await totalEnergyKJ(feature, mass, flat); // kJ

    const total = (metric === 'distance') ? totalDist
                : (metric === 'time')     ? totalTime
                :                           totalEnergy;

    if (!(Number.isFinite(total) && total > 0)) {
      logRest('[PERCENT] 総量が0または非数のためスキップ');
    } else {
      // 閾値は「累積ターゲット」を順に足していく方式
      let nextThreshold = stepPct * total;
      let progressed    = 0;
      const hasEle = coords[0].length >= 3;

      for (const s of segs) {
        for (const st of s.steps || []) {
          const [i0, i1] = st.way_points || [0, 0];
          const d  = st.distance || 0;  // m
          const t  = st.duration || 0;  // s
          const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
          const dE = energyStepKJ(d, dz, mass, flat);

          if (metric === 'distance') progressed += d;
          else if (metric === 'time') progressed += t;
          else progressed += dE;

          // 1ステップで複数回閾値を跨ぐ可能性があるので while で対応
          while (progressed >= nextThreshold) {
            raw.push({ lat: coords[i1][1], lon: coords[i1][0], routeD: cumDist[i1] });
            logRest(`[PERCENT] ${(cumDist[i1]/1000).toFixed(2)} km → HIT`);
            nextThreshold += stepPct * total;
          }
        }
      }
    }
  }

  

  return raw;
}

/* ===== 区間統計（各ルート） ===== */
async function calcLegStats(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments || [];
  const hasEle = coords[0].length >= 3;

  const legDist = [], legTime = [], legEnergy = [];
  for (const s of segs) {
    for (const step of (s.steps || [])) {
      const [i0, i1] = step.way_points || [0, 0];
      const d  = step.distance || 0;  // m
      const t  = step.duration || 0;  // s
      const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
      legDist.push(d / 1000);
      legTime.push(t / 60);
      legEnergy.push(energyStepKJ(d, dz, mass, flat));
    }
  }
  return {dist:legDist, time:legTime, energy:legEnergy};
}
function summaryStats(arr){
  if(!arr.length) return {mean:0,var:0,std:0};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length;
  return {mean:m, var:v, std:Math.sqrt(v)};
}
async function showRouteLegSummary(){
  const mass = 75, flat = 18;
  const outDiv = document.getElementById('legSummaryAll');
  outDiv.innerHTML = '';
  for (const key of ['shortest','fastest','slope','arterial']){
    const feat = routeData[key];
    if(!feat) continue;
    const s = await calcLegStats(feat, mass, flat);
    const ds = summaryStats(s.dist);
    const ts = summaryStats(s.time);
    const es = summaryStats(s.energy);
    const label = key==='shortest' ? '最短'
            : key==='fastest'  ? '最速'
            : key==='slope'    ? '勾配'
            :                    '幹線';
    const html = `
      <details style="margin-bottom:8px">
        <summary><b>${label}</b> 区間統計（平均 / 分散 / 標準偏差）</summary>
        距離: ${ds.mean.toFixed(2)} km / ${ds.var.toFixed(2)} km² / σ=${ds.std.toFixed(2)} km<br>
        時間: ${ts.mean.toFixed(2)} 分 / ${ts.var.toFixed(2)} 分² / σ=${ts.std.toFixed(2)} 分<br>
        エネルギー: ${es.mean.toFixed(1)} kJ / ${es.var.toFixed(1)} kJ² / σ=${es.std.toFixed(1)} kJ
      </details>`;
    outDiv.innerHTML += html;
  }
}

/* ===== グラフ出力 ===== */
function tempShowChartsContainer(show){
  const c = document.getElementById('charts');
  if(show){
    c.style.display='block';
    c.style.position='absolute';
    c.style.left='-99999px';
    c.style.visibility='hidden';
  }else{
    c.removeAttribute('style');
    c.style.display='none';
  }
}
function prepareCanvasSize(canvas,w,h){
  canvas.width=w||1600;
  canvas.height=h||900;
}
async function downloadLineChart(obj){
  tempShowChartsContainer(true);
  const ec = document.getElementById('energyChart');
  prepareCanvasSize(ec,1600,900);

  const chart = new Chart(ec,{
    type:'line',
    data:{labels:obj.labels,
          datasets:[{label:obj.ylabel,data:obj.values,borderWidth:2,pointRadius:0}]},
    options:{
      animation:false,
      plugins:{legend:{display:false}},
      scales:{ x:{title:{display:true,text:obj.xlabel}},
               y:{title:{display:true,text:obj.ylabel}} }
    }
  });

  await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));

  ec.toBlob(blob=>{
    if(blob){
      const u = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = u; a.download = obj.filename; a.click();
      setTimeout(()=>{ URL.revokeObjectURL(u); chart.destroy(); tempShowChartsContainer(false); },300);
    }else{
      chart.destroy(); tempShowChartsContainer(false);
    }
  });
}
function buildEnergySeries(feature,mass,flat,byTime=true){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length >= 3;
  const segs   = feature.properties.segments || [];
  let cumT=0, cumD=0, cumE=0;
  const labels=[], values=[];
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d  = st.distance || 0;
      const t  = st.duration || 0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      cumE += energyStepKJ(d,dz,mass,flat);
      cumD += d;
      cumT += t;
      labels.push(byTime? (cumT/60).toFixed(2) : (cumD/1000).toFixed(2));
      values.push(+cumE.toFixed(1));
    }
  }
  return {
    labels,
    values,
    xlabel: byTime?'時間 (分)':'距離 (km)',
    ylabel:'累積エネルギー (kJ)',
    filename: byTime?'energy_over_time.png':'energy_over_distance.png'
  };
}

/* ===== Overpass（保守的実装） ===== */
async function overpassQuery(query) {
  const endpoints = [
    'https://overpass-api.de/api/interpreter',
    'https://overpass.kumi.systems/api/interpreter'
  ];
  let lastStatus = 0, lastText = '';

  for (const ep of endpoints) {
    try {
      const r = await fetch(ep, {
        method: 'POST',
        headers: {
          'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8',
          'Accept': 'application/json,text/plain,*/*'
        },
        body: new URLSearchParams({ data: query }).toString()
      });
      lastStatus = r.status;
      if (r.ok) return r.json();
      lastText = await r.text();
      if (r.status === 400) {
        console.warn('[Overpass] 400 detected.\n---QUERY START---\n' + query + '\n---QUERY END---\n' +
                     '---RESPONSE START---\n' + lastText + '\n---RESPONSE END---');
      }
    } catch (e) {
      lastText = e.message || String(e);
    }
  }
  throw new Error(`[Overpass] all attempts failed. Last status=${lastStatus}. Snippet=${(lastText||'').slice(0,1200)}`);
}
async function overpassRetry(query) {
  let delay = 800;
  for (let i=0;i<5;i++) {
    try {
      return await overpassQuery(query);
    } catch (e) {
      if (String(e).includes('status=400')) throw e; // 構文系は打ち切り
      await new Promise(res=>setTimeout(res, delay));
      delay = Math.min(6000, Math.round(delay*1.8));
    }
  }
  return await overpassQuery(query);
}

/* ===== POI取得（改良版）：カテゴリ自動拡張＋半径段階拡大＋距離ソート ===== */
async function fetchPoisAround(latRaw, lonRaw, baseRadius, limit) {
  // --- 入力/前処理 ---
  const round6 = v => Math.round(Number(v) * 1e6) / 1e6;
  const lat = round6(latRaw), lon = round6(lonRaw);
  const centerLL = L.latLng(lat, lon);

  const limitN = Math.max(1, Number(limit) || 5);

  // ユーザの3チェックを読む（コンビニ/スーパー/ドラッグ）
  const useConvenience = document.getElementById('chkConvenience')?.checked ?? true;
  const useSuper       = document.getElementById('chkSuper')?.checked ?? true;
  const useDrug        = document.getElementById('chkDrug')?.checked ?? true;

  // まずはユーザ指定カテゴリのみで試す。0件なら休憩に適したカテゴリを自動で追加して再試行
  const PRIMARY_TAGS = [];
  if (useConvenience) PRIMARY_TAGS.push(['shop', 'convenience']);
  if (useSuper)       PRIMARY_TAGS.push(['shop', 'supermarket']);
  if (useDrug) {
    PRIMARY_TAGS.push(['shop','chemist'], ['shop','pharmacy'], ['amenity','pharmacy']);
  }

  // 追加カテゴリ（候補ゼロ時に順次追加）
  const EXTRA_TAGS = [
    ['amenity','cafe'],
    ['amenity','restaurant'],
    ['amenity','fast_food'],
    ['amenity','drinking_water'],
    ['amenity','toilets'],
    ['amenity','shelter'],
    ['amenity','bench'],
    ['amenity','bicycle_repair_station'],
    ['tourism','picnic_site'],
    ['highway','rest_area'],
    // 自販機（飲料）: vending_machine=drinks or amenity=vending_machine + vending=drinks
    ['amenity','vending_machine'],
  ];

  // 段階的に広げる半径（m）。baseRadiusを優先して組み込む
  const radiusSteps = (() => {
    const base = Math.max(100, Number(baseRadius) || 5000); // 初期は小さめから
    const steps = [1000, 2000, 3000, 5000, 8000, 12000, 20000, 30000, 50000, 80000, 100000];
    // base を先頭へ（重複排除）
    const s = [base, ...steps].filter((v, i, a) => a.indexOf(v) === i).sort((a,b)=>a-b);
    return s;
  })();

  // Overpassクエリを作る（node/way両方、out center）
  const buildQuery = (tags, radius) => {
    if (!tags.length) return null;
    // 同一キーの複数値（例: shop=chemist / shop=pharmacy）も繋げて検索
    const clauses = [];
    // tags は [ [k,v], [k,v], ... ]
    // ここで key ごとに v をまとめた正規表現にする
    const grouped = {};
    for (const [k, v] of tags) {
      grouped[k] = grouped[k] || new Set();
      grouped[k].add(v);
    }
    Object.entries(grouped).forEach(([k, set]) => {
      const values = Array.from(set);
      // vending_machine は補助属性 vending=drinks にも対応
      if (k === 'amenity' && values.includes('vending_machine')) {
        clauses.push(`node(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`node(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
      }
      const re = '(' + values.map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')';
      clauses.push(`node(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
      clauses.push(`way(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
    });

    return `[out:json][timeout:25];
(
  ${clauses.join(';\n  ')};
);
out center;`;
  };

  // 実行→elements→結果整形
  const runOnce = async (tags, radius) => {
    let elements = [];
    const q = buildQuery(tags, radius);
    if (!q) return [];

    try {
      const data = await overpassRetry(q);
      elements = data.elements || [];
    } catch (err) {
      // 400は構文系 → ログして空扱い。他エラーは上位へ投げてもOKだが、ここでは空で継続。
      if (String(err).includes('status=400')) console.warn('[Overpass] 400 with query, continue fallback.');
      else console.warn('[Overpass] error', err);
      elements = [];
    }

    // elements を {name, lat, lon, distFromTriggerM, distKm, dist} に整形（dist は互換用）
    const results = [];
    elements.forEach(e => {
      const ll = e.type === 'node'
        ? [e.lat, e.lon]
        : (e.center ? [e.center.lat, e.center.lon] : null);
      if (!ll) return;
      const name = (e.tags && (e.tags['name:ja'] || e.tags.name || e.tags.brand)) || 'POI';
      const dist = centerLL.distanceTo([ll[0], ll[1]]); // m
      results.push({
        name,
        lat: ll[0],
        lon: ll[1],
        dist,                     // 互換のため残す
        distFromTriggerM: dist,   // 明示名
        distKm: dist / 1000       // 便利フィールド
        });
    });

    // 重複排除（同名＆近接点が多い場合もあるので座標キーで粗く）
    const seen = new Set();
    const uniq = [];
    for (const p of results) {
      const key = `${p.name}|${p.lat.toFixed(5)},${p.lon.toFixed(5)}`;
      if (seen.has(key)) continue;
      seen.add(key);
      uniq.push(p);
    }

    // 距離でソート
    uniq.sort((a,b)=>a.dist-b.dist);
    return uniq;
  };

  // 1) まず「ユーザ指定カテゴリのみ」で半径ステップを回す
  let picked = [];
  for (const r of radiusSteps) {
    const res = await runOnce(PRIMARY_TAGS, r);
    if (res.length >= limitN) {
      picked = res.slice(0, limitN);
      break;
    }
    // 足りない分は仮に確保（次ステップで埋まれば上書きされる）
    if (res.length && !picked.length) picked = res.slice(0, limitN);
  }

  // 2) それでも不足するなら、カテゴリを自動拡張して再試行
  if (picked.length < limitN) {
    const MERGED = PRIMARY_TAGS.slice();
    EXTRA_TAGS.forEach(t => MERGED.push(t));

    for (const r of radiusSteps) {
      const res = await runOnce(MERGED, r);
      if (res.length >= limitN) {
        picked = res.slice(0, limitN);
        break;
      }
      if (res.length && res.length > picked.length) {
        picked = res.slice(0, limitN);
      }
    }
  }

  return picked;
}


/* ===== 小ユーティリティ ===== */
function sanitizeCoord(n, fallback) {
  const v = Number(n);
  if (!isFinite(v)) return Number(fallback);
  return Math.round(v * 1e6) / 1e6;
}

/* ====== 休憩リスト表示更新 ====== */
function updateRestListPanel(){
  const ul = $('restListPanel');
  ul.innerHTML='';
  if (!restList.length){
    ul.innerHTML='<li>休憩地点はありません</li>';
    return;
  }
  restList.forEach((r,i)=>{
    const li=document.createElement('li');
    li.style.padding='4px 0';
    li.innerHTML=`${i+1}. ${r.distance} km地点
      <small>(${r.lat.toFixed(5)}, ${r.lon.toFixed(5)})</small>`;
    ul.appendChild(li);
  });
}

function updateRestPoiPanel(){
  const ol = document.getElementById('restPoiPanel');
  if (!ol) return;
  ol.innerHTML = '';

  if (!restGroups.length){
    const li = document.createElement('li');
    li.textContent = '休憩トリガーはありません';
    ol.appendChild(li);
    return;
  }

  restGroups.forEach((g, i) => {
    const li = document.createElement('li');
    li.style.margin = '6px 0';

    // 見出し：休憩トリガー#N（km地点 / 緯度経度）
    const km = (g.rest?.routeD ?? 0) / 1000;
    const head = document.createElement('div');
    head.innerHTML = `<b>休憩トリガー＃${i+1}</b>　<span style="color:#666">${km.toFixed(2)} km地点</span>
      <small>(${(g.rest?.lat ?? 0).toFixed(5)}, ${(g.rest?.lon ?? 0).toFixed(5)})</small>`;
    li.appendChild(head);

    // 候補POIのUL
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.margin = '4px 0 0';
    ul.style.padding = '0';

    if (!g.pois?.length){
      const x = document.createElement('li');
      x.textContent = '・（候補なし）';
      ul.appendChild(x);
    } else {
      g.pois.forEach((p, j) => {
        const it = document.createElement('li');
        it.style.padding = '2px 0';
        const dTrigger = (typeof p.distFromTriggerM === 'number') ? ` / トリガー距離 ${formatDist(p.distFromTriggerM)}` : '';
        const dPerp = (p._proj && typeof p._proj.perpM === 'number') ? ` / ルート⊥ <b>${formatDist(p._proj.perpM)}</b>` : '';
        const w = Number.isFinite(Number(p._w)) ? Number(p._w) : 1;
        it.innerHTML = `
          ・${p.name}　${p.lat.toFixed(5)}　${p.lon.toFixed(5)}${dTrigger}${dPerp}
          <label style="margin-left:6px">重み
            <input type="number" step="0.1" min="0" value="${w}"
                   data-bind="poi-w" data-trigger-index="${i}" data-poi-index="${j}"
                   style="width:70px">
          </label>`;
        ul.appendChild(it);
      });
    }

    li.appendChild(ul);
    ol.appendChild(li);
  });
}

// ▼▼ ここから：候補POIの「重み」入力を拾うイベント委譲（1回だけ定義） ▼▼
(function bindPoiWeightInput(){
  const panel = document.getElementById('restPoiPanel');
  if (!panel) return; // 念のため
  panel.addEventListener('input', (ev) => {
    const t = ev.target;
    if (!(t instanceof HTMLInputElement)) return;
    if (t.dataset.bind !== 'poi-w') return;        // 重み入力の合図
    const gi = Number(t.dataset.triggerIndex);     // どの休憩トリガーか
    const pj = Number(t.dataset.poiIndex);         // その中の何番目のPOIか
    const v  = Number(t.value);
    if (!Number.isFinite(gi) || !Number.isFinite(pj)) return;
    if (!restGroups?.[gi]?.pois?.[pj]) return;

    // 0未満は不可。未入力/NaNは1にフォールバック
    restGroups[gi].pois[pj]._w = Math.max(0, Number.isFinite(v) ? v : 1);
  });
})();
// ▲▲ ここまで：イベント委譲 ▼▼


// 組み合わせ表示専用：使用地点だけピンを出す
function setComboMarkers(start, picksArray, goal){
  // 既存ピンをすべて消す
  if (markerLayer) map.removeLayer(markerLayer);
  markerLayer = L.layerGroup().addTo(map);

  // スタート
  if (start) {
    L.marker([start.lat, start.lon], {icon:ICONS.start})
      .bindTooltip(start.name || 'スタート').addTo(markerLayer);
  }

  // 採用POI（順路）
  (picksArray || []).forEach((p, i) => {
    if (!p) return;
    L.marker([p.lat, p.lon], {
      icon: new L.Icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
        iconSize:[32,32], iconAnchor:[16,32]
      })
    }).bindTooltip(`${p.name || '休憩'} #${i+1}`).addTo(markerLayer);
  });

  // ゴール
  if (goal) {
    L.marker([goal.lat, goal.lon], {icon:ICONS.goal})
      .bindTooltip(goal.name || 'ゴール').addTo(markerLayer);
  }
}


function showTop3Combos(resultList){
  const box = document.getElementById('comboTop3');
  box.innerHTML = '';
  if (!resultList.length){
    box.textContent = '候補がありません（休憩トリガーやPOIが不足）';
    return;
  }

  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const fmt = (n)=>Number(n).toFixed(5);

  resultList.slice(0,3).forEach((r, idx) => {
    const rank = idx+1;

    const wrap = document.createElement('div');
    wrap.style.border='1px solid #ddd';
    wrap.style.borderRadius='8px';
    wrap.style.padding='8px';
    wrap.style.marginBottom='8px';

    const header = document.createElement('div');
    header.innerHTML = `
      <div style="font-weight:700;margin-bottom:4px">
        #${rank}　スコア（σ合計）: ${(sd(r.stats.dist)+sd(r.stats.time)+sd(r.stats.energy)).toFixed(3)}
        ${typeof r.rawScore === 'number' ? `<span style="color:#777">（総当たり: 補正後=${r.score.toFixed(3)} / 素=${r.rawScore.toFixed(3)}）</span>` : ''}
      </div>
      <div style="margin-top:4px">
        距離σ=${sd(r.stats.dist).toFixed(2)} km　
        時間σ=${sd(r.stats.time).toFixed(2)} 分　
        エネルギーσ=${sd(r.stats.energy).toFixed(2)} kJ
      </div>
    `;
    wrap.appendChild(header);

    const list = document.createElement('div');
    list.style.marginTop = '8px';
    list.innerHTML = `<div style="font-weight:600;margin-bottom:4px">採用した休憩地点（トリガーごと）</div>`;
    const ol = document.createElement('ol');
    ol.style.margin = '4px 0 0 1.1rem';
    ol.style.fontSize = '0.92rem';

    (restGroups || []).forEach((g, i) => {
      const li = document.createElement('li');
      const km = ((g?.rest?.routeD || 0) / 1000).toFixed(2);
      const head = document.createElement('div');
      head.innerHTML = `<b>休憩トリガー＃${i+1}</b>　<span style="color:#666">${km} km地点</span>
        <small>(${fmt(g?.rest?.lat||0)}, ${fmt(g?.rest?.lon||0)})</small>`;
      li.appendChild(head);

      const chosen = (r.picksByTrigger && r.picksByTrigger[i]) ? r.picksByTrigger[i] : null;
      const ul = document.createElement('ul');
      ul.style.listStyle='none'; ul.style.margin='4px 0 0'; ul.style.padding='0';

      const row = document.createElement('li');
      row.style.padding='2px 0';

      if (chosen){
        row.style.cursor='pointer';
        const dtxt = (typeof chosen.distFromTriggerM === 'number')
          ? ` / ${formatDist(chosen.distFromTriggerM)}`
            : '';
        row.textContent = `・${chosen.name}　${fmt(chosen.lat)}　${fmt(chosen.lon)}${dtxt}`;
        row.onclick = () => {
          map.flyTo([chosen.lat, chosen.lon], 17);
          L.popup().setLatLng([chosen.lat, chosen.lon]).setContent(chosen.name).openOn(map);
        };
      } else {
  // 候補が一件も無いのか、単にその組み合わせで未採用なのかを判定
  const hasAny = Array.isArray(g?.pois) && g.pois.length > 0;
  row.textContent = hasAny ? '・（未採用）' : '・（候補なし）';
  row.style.color = '#777';
}

      ul.appendChild(row);
      li.appendChild(ul);
      ol.appendChild(li);
    });

    list.appendChild(ol);
    wrap.appendChild(list);

    const btnWrap = document.createElement('div');
    btnWrap.style.marginTop='8px';
    const btn = document.createElement('button');
    btn.textContent = 'このルートを表示';
    btn.onclick = async () => {
      btn.disabled = true;
      btn.textContent = 'ルート生成中...';
      try {
        let feature = r.feature;
        if (!feature) {
          const start = pts.find(p=>p.type==='start') || pts[0];
          const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
          if (!start || !goal) { alert('スタート/ゴールが見つかりません。'); return; }
          const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
            ? r.picksByTrigger.filter(Boolean)
            : (r.picks || []);
          const wps = [start, ...picksArray, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name || 'POI'}));
          const profile = $('profileSelect').value;
          const out = await routeLegStatsForWaypoints(wps, profile);
          feature = out.feature;
        }
        if (!feature) { alert('ルートを生成できませんでした。'); return; }

        clearRouteLayers();
        const color = '#00aa88';
        const layer = L.geoJSON(feature, { style:{ color, weight: 7 } }).addTo(map);
        routeLayers['combo#'+rank] = layer;

        const start = pts.find(p=>p.type==='start') || pts[0];
        const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
        const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
          ? r.picksByTrigger.filter(Boolean)
          : (r.picks || []);
        setComboMarkers(start, picksArray, goal);

        if (layer.getBounds && layer.getBounds().isValid && layer.getBounds().isValid()) {
          map.fitBounds(layer.getBounds().pad(0.1));
        } else {
          const fallback = (r.picks && r.picks[0]) || pts[0];
          if (fallback) map.flyTo([fallback.lat, fallback.lon], 14);
        }
        setActiveButton(null);
      } catch (e){
  console.error(e);
  const hints = [
    !ORS_KEY ? 'ORS_KEY が未設定' : null,
    !(pts && pts.length>=2) ? 'Start/Goal が不正' : null,
    !routeData.fastest ? '最速ルート未生成（先に「休憩場所検索」を実行）' : null
  ].filter(Boolean).join(' / ');
  alert('ルート描画でエラー: ' + (e.message || e) + (hints ? '\nヒント: ' + hints : ''));
} finally {
        btn.disabled = false;
        btn.textContent = 'このルートを表示';
      }
    };
    btnWrap.appendChild(btn);
    wrap.appendChild(btnWrap);

    box.appendChild(wrap);
  });
}

/* ===== スコアリング（POI評価） ===== */
// ローカルストレージから復元（無ければデフォルト）
let SCORE_WEIGHTS = (()=>{
  try{
    const raw = localStorage.getItem('route_score_weights');
    if(!raw) return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
    const obj = JSON.parse(raw);
    // 不足キーは補完
    return {
      wAlign: Number.isFinite(obj?.wAlign) ? obj.wAlign : 1.0,
      wPerp:  Number.isFinite(obj?.wPerp)  ? obj.wPerp  : 1.0,
      wTrig:  Number.isFinite(obj?.wTrig)  ? obj.wTrig  : 0.5,
    };
  }catch(e){
    return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
  }
})();

function targetCumDForIndex(i, R, totalD){
  if (!Number.isFinite(totalD) || totalD<=0) return 0;
  return totalD * (i + 1) / (R + 1);
}

function nodeCost(p, targetCumD){
  if (!p) return 1e9;
  const perpM   = Number(p?._proj?.perpM) ?? 0;
  const trigM   = Number(p?.distFromTriggerM) ?? 0;
  const alignM  = Math.abs((Number(p?._proj?.cumD) ?? targetCumD) - targetCumD);
  const base =
    (SCORE_WEIGHTS.wAlign * (alignM/1000)) +
    (SCORE_WEIGHTS.wPerp  * (perpM/1000))  +
    (SCORE_WEIGHTS.wTrig  * (trigM/1000));
  const w = Number(p?._w) || 1; // 1=標準、>1=優先
  return base / Math.max(0.1, w); // 下限で暴走防止
}


/* ===== 組み合わせルート探索＆評価ユーティリティ ===== */

// 休憩トリガーごとに1地点ずつ選ぶ全組み合わせを列挙（上限あり）
function enumerateCombinations(poiGroups, perGroupLimit = 3, hardCap = 60){
  const groups = poiGroups.map(arr => (arr || []).slice(0, perGroupLimit));
  const combos = [];
  function dfs(i, acc){
    if (combos.length >= hardCap) return;
    if (i === groups.length){ combos.push(acc.slice()); return; }
    const g = groups[i];
    if (!g.length){ acc.push(null); dfs(i+1, acc); acc.pop(); return; }
    for (const p of g){ if (combos.length >= hardCap) break; acc.push(p); dfs(i+1, acc); acc.pop(); }
  }
  dfs(0, []);
  return combos;
}

// スコア（小さいほど良い）：距離/時間/エネルギーの標準偏差の合計
function comboScore(legStats){
  const sd = (a)=>{ if(!a.length) return 0; const m=a.reduce((x,y)=>x+y,0)/a.length; 
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length); };
  return sd(legStats.dist)+sd(legStats.time)+sd(legStats.energy);
}

// 組み合わせルートのレグ統計を取得（ORS呼び出し）
async function routeLegStatsForWaypoints(wps, profile){
  const body = { coordinates: wps.map(p=>[p.lon,p.lat]), elevation:true, extra_info:['steepness'], preference:'fastest' };
  const feature = (await dir(body, profile)).features[0];
  const mass=75, flat=18;
  const stats = await calcLegStats(feature, mass, flat);
  return { feature, stats };
}

// ルートの累積距離[m]/時間[s]/エネルギー[kJ]を構築
function buildCums(feature, mass=75, flat=18){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length>=3;
  const segs   = feature.properties.segments||[];
  const cum = { D:[0], T:[0], E:[0] };
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, t=st.duration||0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cum.D.push(cum.D.at(-1)+d);
      cum.T.push(cum.T.at(-1)+t);
      cum.E.push(cum.E.at(-1)+dE);
    }
  }
  return {cum, coords};
}

// POIをルート折れ線へ射影し、その地点の累積値を内挿で取得
function projectToRoute(lat,lon, coords, cum){
  let best={i0:0,i1:1,frac:0,dist:Infinity, stepIdx:1};
  let stepIdx=1;
  for(let i=1;i<coords.length;i++, stepIdx++){
    const A=L.latLng(coords[i-1][1],coords[i-1][0]);
    const B=L.latLng(coords[i][1],  coords[i][0]);
    const P=L.latLng(lat,lon);
    const AB=[B.lat-A.lat, B.lng-A.lng];
    const AP=[P.lat-A.lat, P.lng-A.lng];
    const ab2=AB[0]*AB[0]+AB[1]*AB[1]||1e-12;
    let t=(AP[0]*AB[0]+AP[1]*AB[1])/ab2; t=Math.max(0,Math.min(1,t));
    const Q=L.latLng(A.lat+AB[0]*t, A.lng+AB[1]*t);
    const d=P.distanceTo(Q);
    if(d<best.dist){ best={i0:i-1,i1:i,frac:t,dist:d, stepIdx:i}; }
  }
  const i = best.stepIdx;
  const lerp=(arr)=>{ const v0=arr[i-1], v1=arr[i]??v0; return v0 + (v1-v0)*best.frac; };
  return { cumD:lerp(cum.D), cumT:lerp(cum.T), cumE:lerp(cum.E), perpM: best.dist };
}

// picksByTrigger（各トリガーの選択）を累積から評価（ゼロAPI）
function evalByCums(restGroups, picksByTrigger, cumTotals){
  // 1) トータルのサニタイズ
  const totalD = Number(cumTotals?.D) || 0;   // m
  const totalT = Number(cumTotals?.T) || 0;   // s
  const totalE = Number(cumTotals?.E) || 0;   // kJ

  // 2) 区切り（cuts）作成：start(0) → 各pickの累積距離 → goal(totalD)
  const cuts = [0];
  (picksByTrigger || []).forEach(p => {
    const v = Number(p?._proj?.cumD);
    if (Number.isFinite(v) && v > 0 && v < totalD) cuts.push(v);
  });
  if (totalD > 0) cuts.push(totalD);

  // 3) 区間距離配列（km）
  const dist = [];
  if (cuts.length >= 2){
    cuts.sort((a,b)=>a-b);
    for (let i=1;i<cuts.length;i++){
      const d = (Number(cuts[i]) - Number(cuts[i-1])) / 1000; // km
      if (Number.isFinite(d) && d >= 0) dist.push(d);
    }
  }

  // 4) 区間時間/エネルギーを距離比で近似配分（分母0なら均等割り）
  const time = [], energy = [];
  if (dist.length){
    if (totalD > 0 && Number.isFinite(totalD)){
      for (const d of dist){
        const ratio = ((d*1000) / totalD); // 0..1
        time.push((totalT/60) * (Number.isFinite(ratio)? ratio : 0)); // 分
        energy.push(totalE * (Number.isFinite(ratio)? ratio : 0));    // kJ
      }
    } else {
      // 総距離が0/未定義でも NaN にしない：均等割りにする
      const eqT = (totalT/60) / dist.length; // 分
      const eqE = (totalE) / dist.length;    // kJ
      for (let i=0;i<dist.length;i++){ time.push(eqT||0); energy.push(eqE||0); }
    }
  }

  // 5) NaN/∞ を弾く安全化
  const finite = a => a.filter(x => Number.isFinite(x));
  const distF = finite(dist), timeF = finite(time), energyF = finite(energy);

  // 6) σ計算（空配列でも落ちない）
  const sd = (a) => {
    if (!a.length) return 0;
    const m = a.reduce((s,v)=>s+v,0) / a.length;
    const v = a.reduce((s,v)=>s+(v-m)*(v-m),0) / a.length;
    return Math.sqrt(v);
  };

  const score = sd(distF) + sd(timeF) + sd(energyF);
  return { stats: { dist: distF, time: timeF, energy: energyF }, score: Number.isFinite(score)? score : 0 };
}
/* ===== 共通ユーティリティ：候補検査＆未採用の強制補修 ===== */

/* ===== 共通ユーティリティ：候補検査＆未採用の強制補修 ===== */

// i番目トリガーに有効候補(_proj.cumDが有限)があるか？
function hasValidCand(restGroups, i){
  const g = restGroups[i];
  if (!g) return false;
  const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
  return valid.length > 0;
}

// 未採用(null)を残さないための補修：
// 候補があるトリガーでは、等間隔ターゲットに最も近い候補で穴埋めする
function repairNullPicks(restGroups, cumTotals, picks){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;
  if (!R || !Number.isFinite(totalD) || totalD <= 0) return picks;

  const out = picks.slice();
  for (let i = 0; i < R; i++){
    if (out[i]) continue;                        // 既に採用済み
    if (!hasValidCand(restGroups, i)) continue;  // 物理的に候補なしならスキップ

    const g = restGroups[i];
    const target = totalD * (i + 1) / (R + 1);
    const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    if (!valid.length) continue;

    valid.sort((a,b)=>Math.abs(a._proj.cumD - target) - Math.abs(b._proj.cumD - target));
    out[i] = valid[0];
  }
  return out;
}


/* ===== ビームサーチ（ゼロAPI）：候補ありは必採用＋未採用補修 ===== */
function beamSearch(restGroups, cumTotals, width = 3, minRest = 1, nullPenalty = 1e6, forbidNullWhenCand = true) {
  // beams 要素: { picks: [...(p or null)], score, pickedCount }
  let beams = [{ picks: [], score: 0, pickedCount: 0 }];

  for (let i = 0; i < restGroups.length; i++){
    const g = restGroups[i];
let pois = (g?.pois || []).slice();

// ▼ _proj が無い/不完全な POI には、休憩トリガーの routeD を使って暫定射影を付与
if (pois.length && g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}

// ここから先は従来と同じロジック
const valid = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
const totalD = Number(cumTotals?.D) || 0;
const target = targetCumDForIndex(i, restGroups.length, totalD);
valid.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));


const cand = valid.length
  ? (forbidNullWhenCand ? valid : [...valid, null])
  : [null];


    const next = [];
    for (const b of beams){
      for (const p of cand){
        const picks = b.picks.concat([p]);

        // ゼロAPI近似評価
        const ev = evalByCums(restGroups, picks, cumTotals);
        let s = ev.score;

        // ★ 候補があるのに null を選んだ場合は強ペナルティ
        if (p === null && valid.length){
          s += nullPenalty;
        }

        next.push({
          picks,
          score: Number.isFinite(s) ? s : 0,
          pickedCount: b.pickedCount + (p ? 1 : 0)
        });
      }
    }

    // スコア上位 width 件のみ保持
    next.sort((a,b)=>a.score - b.score);
    beams = next.slice(0, width);
  }

  // ★ 最低採用数の制約（候補があるトリガー分を採用）
  let final = beams.filter(b => b.pickedCount >= minRest);
  if (!final.length) final = beams;

  // ★ 未採用(null)の“補修”をかけてから最終スコア再計算
  final = final.map(b => {
    const fixedPicks = repairNullPicks(restGroups, cumTotals, b.picks);
    const ev = evalByCums(restGroups, fixedPicks, cumTotals);
    return {
      picksByTrigger: fixedPicks,  // ← 修正後の picks を返す（以後の表示は必ず採用表示になる）
      score: ev.score,
      stats: ev.stats
    };
  }).sort((a,b)=>a.score - b.score);

  return final.slice(0, 3);
}




/* ===== 等間隔貪欲法（修正版）: 候補がある場合は必ず採用 ===== */
function greedyTopKCandidates(restGroups, cumTotals, K = 3) {
  const R = restGroups.length;
  const groups = [];

  for (let t = 0; t < R; t++) {
    const g = restGroups[t];
    const target = cumTotals.D * (t + 1) / (R + 1); // m（距離基準）
    let pois = (g && Array.isArray(g.pois)) ? g.pois : [];

    if (!pois.length) {
      groups.push([null]); // 物理的に候補ゼロ
      continue;
    }
    // ▼ _proj が無い POI には、休憩トリガー距離を暫定で入れて候補落ちを防ぐ
if (g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}


    // --- 射影値 _proj が無い場合に補完 ---
    const needProj = pois.some(p => p && (!p._proj || !Number.isFinite(p._proj.cumD)));
    if (needProj && window.__routeCums) {
      const { cum, coords } = window.__routeCums;
      pois.forEach(p => {
        if (p && (!p._proj || !Number.isFinite(p._proj.cumD))) {
          p._proj = projectToRoute(p.lat, p.lon, coords, cum);
        }
      });
    }

    // --- 射影値があるものを優先 ---
    const withProj = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    let ranked;

    const base = withProj.length ? withProj : pois;
 ranked = base
   .map(p => ({ p, c: nodeCost(p, target) }))
   .sort((a, b) => a.c - b.c)
   .slice(0, K)
   .map(x => x.p);

    // 候補があれば必ず採用。空なら [null]
    groups.push(ranked.length ? ranked : [null]);
  }

  return groups;
}

function ensureProjections() {
  const base = routeData.arterial || routeData.fastest;
  // ルート情報や休憩グループが存在しない場合は何もしない
  if (!base || !Array.isArray(restGroups) || !restGroups.length) return;

  // ルート上の累積データを構築
  const { cum, coords } = buildCums(base);

  window.__routeCums = { cum, coords };
  window.__cumTotals = {
    D: cum.D.at(-1),
    T: cum.T.at(-1),
    E: cum.E.at(-1)
  };

  // 各休憩グループの POI に射影データを付ける
  for (const g of restGroups) {
    const arr = g?.pois || [];
    for (const p of arr) {
      if (!p) continue;

      // 既に _proj があり cumD が有限値ならスキップ
      if (p._proj && Number.isFinite(p._proj.cumD)) continue;

      // _proj を計算して付与
      p._proj = projectToRoute(p.lat, p.lon, coords, cum);
    }
  }

  console.log("[ensureProjections] 射影を再計算しました");
}

function dbgShowCumsAndProjections(){
  const el = $('dbgCums'); if (!el) return;
  const t = window.__cumTotals;
  const counts = (restGroups||[]).map((g,i)=>{
    const valid = (g?.pois||[]).filter(p=>p && p._proj && Number.isFinite(p._proj.cumD)).length;
    return `#${i+1}: POI=${(g?.pois||[]).length}, projOK=${valid}`;
  }).join('\n');
  el.textContent =
`cumTotals:
  D=${t?.D?.toFixed?.(1)} m
  T=${t?.T?.toFixed?.(1)} s
  E=${t?.E?.toFixed?.(1)} kJ
per-trigger candidates:
${counts || '(none)'}`;
  console.log("[ensureProjections] 射影を再計算しました");
  (restGroups||[]).forEach((g,i)=>{
      const ok = (g?.pois||[]).filter(p=>p && p._proj && Number.isFinite(p._proj.cumD)).length;
      console.log(`[projOK] trigger#${i+1}: all=${(g?.pois||[]).length}, projOK=${ok}`);
    });
}

  

function injectAlgoDebugButtons(cumTotals){
  // 既に挿入済みならスキップ
  if (document.getElementById('algoDebugBar')) return;
  const host = document.getElementById('comboTop3');
  const bar = document.createElement('div');
  bar.id = 'algoDebugBar';
  bar.style.margin = '6px 0 10px';
  bar.innerHTML = `
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button id="dbgRunGreedy">デバッグ: 等間隔貪欲</button>
      <button id="dbgRunBeam">デバッグ: ビームサーチ</button>
      <button id="dbgClear">クリア</button>
    </div>
    <pre id="dbgAlgoLog" style="font-family:ui-monospace,monospace;background:#f8f8f8;border:1px solid #eee;padding:6px;white-space:pre-wrap"></pre>
  `;
  host.prepend(bar);

  const logEl = document.getElementById('dbgAlgoLog');
  const log = (s)=>{ logEl.textContent += s + '\n'; };

  document.getElementById('dbgRunGreedy').onclick = ()=>{
    const K = 3;
    const candGroups = greedyTopKCandidates(restGroups, cumTotals, K);
    const combos = enumerateCombinations(candGroups, K, 60);
    const scored = combos.map(cmb=>{
      const ev = evalByCums(restGroups, cmb, cumTotals);
      return {cmb, score:ev.score, stats:ev.stats};
    }).sort((a,b)=>a.score-b.score).slice(0,3);
    log('[GREEDY top3]');
    scored.forEach((r,i)=>{
      log(`#${i+1}: score=${r.score.toFixed(4)}  segN=${r.stats.dist.length}`);
    });
    showTop3Combos(scored.map(s=>({
  score:s.score, stats:s.stats, picksByTrigger:s.cmb, picks:s.cmb.filter(Boolean)
})));
  };

  document.getElementById('dbgRunBeam').onclick = ()=>{
    const triggersWithCand = (restGroups||[]).reduce((n,g)=>{
      const valid=(g?.pois||[]).filter(p=>p && p._proj && Number.isFinite(p._proj.cumD));
      return n + (valid.length?1:0);
    },0);
    const top = beamSearch(restGroups, cumTotals, 3, triggersWithCand, 1e6, true);
    log('[BEAM top3]');
    top.forEach((r,i)=>{
      log(`#${i+1}: score=${r.score.toFixed(4)}  segN=${r.stats.dist.length}`);
    });
    top.forEach(t=>t.picks = t.picksByTrigger.filter(Boolean));
    showTop3Combos(top);
  };

  document.getElementById('dbgClear').onclick = ()=>{
    logEl.textContent='';
    document.getElementById('comboTop3').innerHTML='';
  };
}

// 幹線度（大きいほど“幹線っぽい”）
function arterialScore(feature){
  const sum = feature?.properties?.summary || {};
  const dist = Number(sum.distance)||0;      // m
  const time = Number(sum.duration)||1;      // s（0回避）
  const meanSpeed = dist / time;             // m/s

  // "曲がりの少なさ" を step 数の少なさで近似
  const segs = feature?.properties?.segments || [];
  let stepsCount = 0;
  for(const s of segs) stepsCount += (s.steps||[]).length;

  const turnsPerKm = dist>0 ? (stepsCount/(dist/1000)) : stepsCount;

  const wSpeed = 1.0, wTurns = 0.6;          // 調整OK
  return (wSpeed*meanSpeed) - (wTurns*turnsPerKm);
}

/* ===== DP（層グラフ最短路） ===== */
// restGroups: [{rest, pois:[p...]}, ...], cumTotals: {D,T,E}
function dpSearch(restGroups, cumTotals){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;

  // 各層の候補（_proj が無いものは routeD で暫定補完）
  const layers = restGroups.map((g, i) => {
    let pois = (g?.pois || []).slice();
    if (g?.rest && Number.isFinite(g.rest.routeD)) {
      pois.forEach(p => {
        if (!p._proj || !Number.isFinite(p._proj.cumD)) {
          p._proj = { cumD: Number(g.rest.routeD), perpM: Number(p.distFromTriggerM)||0 };
        }
      });
    }
    // 等間隔ターゲットに対する単点コスト（並べ替えにも使う）
    const target = targetCumDForIndex(i, R, totalD);
    pois.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));
    return pois;
  });

  // DPテーブル
  // dp[i][j] = 第i層で j番目POIを選んだ時の最小コスト
  // prev[i][j] = 一つ前の層のインデックス
  const dp = [], prev = [];
  for (let i=0;i<R;i++) { dp[i] = []; prev[i] = []; }

  // 初期化：スタート→第0層の各POIのコスト（単点コストのみ）
  const t0 = targetCumDForIndex(0, R, totalD);
  layers[0].forEach((p, j) => {
    dp[0][j] = nodeCost(p, t0);
    prev[0][j] = -1;
  });

  // 遷移：第i-1層 → 第i層
  for (let i=1;i<R;i++){
    const ti = targetCumDForIndex(i, R, totalD);
    for (let j=0;j<layers[i].length;j++){
      let best = { cost: Infinity, k: -1 };
      const pj = layers[i][j];

      for (let k=0;k<layers[i-1].length;k++){
        const costPrev = dp[i-1][k];
        if (!Number.isFinite(costPrev)) continue;

        // エッジコスト（区間の「等間隔ズレ」補正を少し加点：累積距離の前後差が狭すぎ/広すぎを抑制）
        const pi = layers[i-1][k];
        const segD = Math.abs((pj?._proj?.cumD||0) - (pi?._proj?.cumD||0)); // m
        const ideal = totalD / (R + 1); // 理想区間長
        const intervalPenalty = Math.abs(segD - ideal) / 1000; // km差分

        const edge = intervalPenalty * 0.5; // 調整係数
        const node = nodeCost(pj, ti);

        const cand = costPrev + edge + node;
        if (cand < best.cost){ best = { cost: cand, k }; }
      }
      dp[i][j] = best.cost;
      prev[i][j] = best.k;
    }
  }

  // 復元（第R-1層の最小コスト終端から辿る）
  let endJ = -1, bestVal = Infinity;
  for (let j=0;j<layers[R-1].length;j++){
    if (dp[R-1][j] < bestVal){ bestVal = dp[R-1][j]; endJ = j; }
  }
  if (endJ < 0) {
    // どの層にも候補が無い場合の保険：空で返す
    return { picksByTrigger: Array(R).fill(null), stats:{dist:[],time:[],energy:[]}, score: 1e9 };
  }

  const picks = Array(R).fill(null);
  let i = R-1, j = endJ;
  while (i >= 0 && j >= 0){
    picks[i] = layers[i][j];
    j = prev[i][j];
    i--;
  }

  // 既存の近似評価で統計を作成（可視化のため）
  const ev = evalByCums(restGroups, picks, cumTotals);
  return { picksByTrigger: picks, stats: ev.stats, score: ev.score };
}


  
</script>
</body>
</html>



