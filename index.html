<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>自転車ルート比較＋休憩（統合版 完全）</title>

<!-- ライブラリ -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map { height: 520px; width: 100%; }
html,body { height: 100%; margin: 0; padding: 0; }
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move;display:flex;justify-content:space-between;align-items:center;gap:8px}
#pointList li small{color:#666}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px;cursor:pointer}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
#routeButtons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
#routeButtons button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#f4f4f4;cursor:pointer}
#routeButtons button.active{background:#dfefff;border-color:#7aa7ff}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.92rem}
</style>
</head>
<body>

<!-- 操作パネル -->
<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="searchBtn">検索</button>
  <button id="drawBtn">休憩場所検索</button>
  <button id="solveCombBtn">ルート検索</button>

</div>

<!-- ▼▼ 地名検索候補リスト ▼▼ -->
<ul id="searchSuggestions"
    style="list-style:none;margin:4px 0;padding:0 8px;background:#fff;
           border:1px solid #ccc;max-height:150px;overflow:auto;">
</ul>

<!-- POI 検索設定 -->
<div class="section">
  <details open>
  <summary>休憩地点まわりのPOI</summary>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <label><input type="checkbox" id="poiToggle" checked> POI表示</label>
    <label>初期半径 <input id="poiRadius" type="number" value="500" min="50" step="50"> m</label>
    <label>件数上限（近い順） <input id="poiLimit" type="number" value="5" min="1" step="1"> 件</label>
    <label><input type="checkbox" id="chkConvenience" checked> コンビニ</label>
    <label><input type="checkbox" id="chkSuper" checked> スーパー</label>
    <label><input type="checkbox" id="chkDrug"  checked> ドラッグストア</label>
  </div>
</details>
</div>

<!-- 休憩設定パネル -->
<div class="section">
  <details open>
    <summary>休憩設定</summary>
    <div style="display:flex;flex-wrap:wrap;gap:10px">
      <label>基準
        <select id="restBasis">
          <option value="time">時間</option>
          <option value="energy" selected>kJ</option>
        </select>
      </label>
      <label>時間間隔 <input id="restMinutes" type="number" value="60" min="15" step="5"> 分</label>
      <label>kJしきい値 <input id="restKJ" type="number" value="500" min="100" step="50"> kJ</label>
    </div>

    <div style="margin-top:6px">
      <label><input type="checkbox" id="optAccum"> 積算トリガ</label><br>
      <label><input type="checkbox" id="optStatTrigger"> 統計トリガ</label>
      平均 <input id="statMean" type="number" value="20" step="1">km
      分散 <input id="statVar" type="number" value="9" step="0.5">km²<br>
      <label><input type="checkbox" id="optPercentTrigger" checked> 割合トリガ</label>
%ごと <input id="percentStep" type="number" value="25" step="1"> %
<select id="percentMetric">
  <option value="distance">距離</option>
  <option value="energy" selected>エネルギー</option>
  <option value="time">時間</option>
</select>
    </div>
    
    <!-- ゴール／既存地点 近接スキップ設定 -->
<div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:6px">
  <label><input type="checkbox" id="skipNearGoalToggle" checked> ゴール手前は休憩を作らない</label>
  <label>スキップ距離（ゴール手前）
    <input id="skipNearGoalKm" type="number" value="1.0" min="0" step="0.1"> km
  </label>
  <label><input type="checkbox" id="skipNearNodeToggle" checked> 既存地点の近接は休憩を作らない</label>
  <label>近接判定
    <input id="skipNearNodeM" type="number" value="150" min="0" step="10"> m
  </label>
</div>

  </details>
</div>

<!-- 休憩ログ表示 -->
<div class="section">
  <details open>
    <summary>休憩トリガ・ヒット状況</summary>
    <div id="restDebug" style="white-space:pre-wrap;font-size:0.9em"></div>
  </details>
</div>

<!-- ▼▼ 休憩地点リスト表示 ▼▼ -->
<div class="section">
  <details open>
    <summary>休憩地点リスト</summary>
    <ul id="restListPanel"
        style="list-style:none;margin:0;padding:0;font-size:0.9rem"></ul>
  </details>
</div>

<!-- 休憩トリガー別の候補POI -->
<div class="section">
  <details open>
    <summary>休憩トリガー別の候補POI</summary>
    <ol id="restPoiPanel" style="margin:0;padding-left:1.1rem;font-size:0.9rem"></ol>
  </details>
</div>

<!-- 地点リストと地図 -->
<ul id="pointList"></ul>
<div id="map"></div>

<!-- ルート検索アルゴリズム -->
<!-- 直線距離（全組み合わせ） -->
<div class="section">
  <h3>直線距離（全組み合わせ）</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px">
    <button id="btnCalcLinear">直線距離を計算（1トリガー1件 × 全組合せ）</button>
    <button id="btnDownloadLinearCsv" disabled>CSVダウンロード</button>
  </div>
  <div id="linearSummary" style="font-size:0.9rem;color:#555"></div>
  <div id="linearList" style="font-family:ui-monospace,monospace;white-space:pre;max-height:260px;overflow:auto;border:1px solid #eee;padding:6px"></div>
</div>

<div class="section">
  <label>探索アルゴリズム
    <select id="algoSelect">
      <option value="greedy" selected>等間隔貪欲（高速・ゼロAPI）</option>
      <option value="beam3">ビームサーチ（幅3・ゼロAPI）</option>
      <option value="bruteforce">総当たり（API多め・高精度）</option>
      <option value="dp">DP（最短路・ゼロAPI）</option>
    </select>
  </label>
  <small style="color:#666;margin-left:8px">※総当たりはAPI制限に注意</small>
</div>

<!-- アルゴリズム比較デバッグ -->
<div class="section">
  <details open>
    <summary>アルゴリズム比較デバッグ（総当たり vs ビームサーチ）</summary>
    <div style="margin:6px 0;">
      <button id="btnAlgoCompare" type="button">
        総当たり と ビームサーチ を比較（同じPOIセット）
      </button>
      <button id="dbgAlgoCsv" type="button" style="margin-left:8px;">
        Excel用CSVダウンロード
      </button>
      <small style="color:#666;display:block;margin-top:4px">
        ※先に「休憩場所検索」で 休憩トリガー＋POI を作ってから実行してください。
      </small>
    </div>
    <pre id="algoComparePanel"
         style="font-family:ui-monospace,monospace;font-size:12px;
                white-space:pre-wrap;border:1px solid #eee;
                padding:6px;max-height:260px;overflow:auto;">
未実行
    </pre>
  </details>
</div>

<label><input type="checkbox" id="dbg_beam" checked> ビーム</label>
<label><input type="checkbox" id="dbg_bf" checked> 総当たり</label>
<label><input type="checkbox" id="dbg_vit" checked> Viterbi</label>
<label><input type="checkbox" id="dbg_A" checked> 対策A</label>
<label><input type="checkbox" id="dbg_B" checked> 対策B</label>
<label><input type="checkbox" id="dbg_C" checked> 対策C</label>
<label><input type="checkbox" id="dbg_D" checked> 対策D</label>
<label><input type="checkbox" id="dbg_E" checked> 対策E</label>
<label><input type="checkbox" id="dbg_F" checked> 対策F</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  A/B beamWidth
  <input id="abBeamWidth" type="number" min="1" step="1" value="40" style="width:72px">
</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  A/B topK
  <input id="abTopK" type="number" min="1" step="1" value="150" style="width:72px">
</label>

<label style="display:inline-flex;align-items:center;gap:6px">
  自動調整
  <input id="abAutoParams" type="checkbox" checked>
</label>

<!-- サマリー -->
<div id="summary">
  <div id="routeInfo">未計算</div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- アルゴリズム比較デバッグ用のバーのどこかに追加 -->


<script>
/* ====== 設定 ====== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; 
// const ORS_KEY  = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjE0YTgxN2M5OWZmNjQ4MmNiMTZkYTk3YWFkMDI2MDAxIiwiaCI6Im11cm11cjY0In0=';
const ORS_ROOT = 'https://api.openrouteservice.org';

// ============================
// ✅ CFG が無い環境でも動くためのミニ定義
// （既に CFG があるなら上書きしない）
// ============================
window.CFG = window.CFG || {};

CFG.viterbi = CFG.viterbi || {};
CFG.linear  = CFG.linear  || {};
CFG.ui      = CFG.ui      || {};

// 対策A/B/C/D/E/F 周りで参照されている可能性が高いものだけ最低限用意
if (!Number.isFinite(CFG.viterbi.capPerTriggerDefault)) CFG.viterbi.capPerTriggerDefault = 5;
if (!Number.isFinite(CFG.viterbi.beamZeroApiWidth))     CFG.viterbi.beamZeroApiWidth     = 12;

if (!Number.isFinite(CFG.linear.candPerTrigger))        CFG.linear.candPerTrigger        = 5;

// showTop は linear の表示件数で使ってたので最低限
if (!Number.isFinite(CFG.ui.showTop))                   CFG.ui.showTop                   = 3;

/* ====== ヘルパ ====== */
let map, pts=[], markerLayer, routeLayers={}, lastDirTs=0;
let routeData = { shortest:null, fastest:null, slope:null, arterial:null };
let OVERPASS_CALL_TOTAL = 0;  // Overpass API の累計呼び出し回数

  window.__algoCompareRows = [];
  window.__bruteforceAllResults = [];   // ★ 総当たりの全結果を保存する配列

// 既存のグローバル変数の近くに追加
let restBeamLayer;   // トリガー ↔ POI の道のりビーム用レイヤー

/* ===== 共通ユーティリティ ===== */

async function measureApiUsed(fn){
  const orsBefore = API_USED.orsTotal;
  const ovpBefore = API_USED.overpassTotal;
  const t0 = performance.now();
  const result = await fn();
  const t1 = performance.now();
  return {
    result,
    ms: t1 - t0,
    ors: API_USED.orsTotal - orsBefore,
    ov:  API_USED.overpassTotal - ovpBefore,
  };
}

// restGroups の要素が
// 形①: {rest, pois:[...]} でも 形②: [...] でも同じように POI配列を取り出す
function getPoisGroup(g){
  if (Array.isArray(g)) return g.filter(Boolean);
  if (g && Array.isArray(g.pois)) return g.pois.filter(Boolean);
  return [];
}

// restGroups(形①/②どちらでもOK) → [ [poi...], [poi...], ... ] に統一して返す
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const name = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();
  if (name) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // ← POI{トリガーID}_{ID}
  return poi;
}

function makeCandGroupsFromRestGroups(restGroups, cap=5, sorter=null){
  return (restGroups || []).map((g, i)=>{
    const arr = getPoisGroup(g);
    if(!arr.length) throw new Error(`トリガー#${i+1} に候補POIがありません`);

    const out = arr.slice();
    if (typeof sorter === 'function') out.sort(sorter);

    const sliced = out.slice(0, Math.min(cap, out.length));

    // ★ここで確実に名前を付ける（0始まり & 安定ID）
    sliced.forEach((p, b) => {
      // すでに ensureProjections で _triggerId/_poiIdInTrigger が付いてるならそれが優先される
      ensurePoiName(p, i, b);
    });

    return sliced;
  });
}

// HTML要素取得
function $(id){ return document.getElementById(id); }

// CSV用エスケープ
function csvEscape(s){
  return String(s).replace(/"/g, '""');
}

// CSV文字列を作って Blob を返す（UTF-8 BOM & CRLF）
function buildCsvBlob(header, rows){
  const lines = [];
  if (header && header.length) lines.push(header.join(','));
  if (rows && rows.length){
    for (const cols of rows){
      lines.push(cols.join(','));
    }
  }
  const bom = new Uint8Array([0xEF,0xBB,0xBF]);
  const csv = lines.join('\r\n');
  return new Blob([bom, csv], { type: 'text/csv;charset=utf-8' });
}

// Blob をファイルとしてダウンロード
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 500);
}

// 配列の標準偏差
function stdDev(arr){
  if (!arr || !arr.length) return 0;
  const m = arr.reduce((a,b)=>a+b, 0) / arr.length;
  const v = arr.reduce((s,x)=> s + (x-m)*(x-m), 0) / arr.length;
  return Math.sqrt(v);
}

/* ===== スコア計算・評価関連 ===== */
// ここに comboScore 関連 / SCORE_METRIC / evalByCums など
// 「ルート評価・スコア算出」を行う関数たちをまとめて置く
  
// スコア（小さいほど良い）：距離/時間/エネルギーの標準偏差の合計
function comboScore(legStats){
  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const metric = getScoreMetric();
  if (metric === 'time')   return sd(legStats.time);
  if (metric === 'energy') return sd(legStats.energy);
  return sd(legStats.dist); // default: distance
}

// picksByTrigger（各トリガーの選択）を累積から評価（ゼロAPI）
function evalByCums(restGroups, picksByTrigger, cumTotals){
  const totalD = Number(cumTotals?.D) || 0;   // m
  const totalT = Number(cumTotals?.T) || 0;   // s
  const totalE = Number(cumTotals?.E) || 0;   // kJ

  // 休憩分割による「区切り」を累積距離で作る
  const cuts = [0];
  (picksByTrigger || []).forEach(p => {
    const v = Number(p?._proj?.cumD);
    if (Number.isFinite(v) && v > 0 && v < totalD) cuts.push(v);
  });
  if (totalD > 0) cuts.push(totalD);

  // 区間距離（km）
  const dist = [];
  if (cuts.length >= 2){
    cuts.sort((a,b)=>a-b);
    for (let i=1;i<cuts.length;i++){
      const d = (Number(cuts[i]) - Number(cuts[i-1])) / 1000; // km
      if (Number.isFinite(d) && d >= 0) dist.push(d);
    }
  }

  // 区間時間/エネルギーは距離比分配（総量が0なら均等割）
  const time = [], energy = [];
  if (dist.length){
    if (totalD > 0 && Number.isFinite(totalD)){
      for (const d of dist){
        const ratio = ((d*1000) / totalD); // 0..1
        time.push((totalT/60) * (Number.isFinite(ratio)? ratio : 0)); // 分
        energy.push(totalE * (Number.isFinite(ratio)? ratio : 0));    // kJ
      }
    } else {
      const eqT = (totalT/60) / dist.length;
      const eqE = (totalE) / dist.length;
      for (let i=0;i<dist.length;i++){ time.push(eqT||0); energy.push(eqE||0); }
    }
  }

  // 安全化
  const finite = a => a.filter(x => Number.isFinite(x));
  const distF = finite(dist), timeF = finite(time), energyF = finite(energy);

  // 標準偏差
  const sd = (a) => {
    if (!a.length) return 0;
    const m = a.reduce((s,v)=>s+v,0) / a.length;
    const v = a.reduce((s,v)=>s+(v-m)*(v-m),0) / a.length;
    return Math.sqrt(v);
  };

  // ★ 単一指標スコア（UIの選択に従う）
  const metric = getScoreMetric();
  const sigmas = { dist: sd(distF), time: sd(timeF), energy: sd(energyF) };
  const score =
      metric === 'time'   ? sigmas.time
    : metric === 'energy' ? sigmas.energy
    :                       sigmas.dist;   // default: distance

  return { stats: { dist: distF, time: timeF, energy: energyF }, score, sigma: sigmas };
}

 /* ===== スコア指標（distance|time|energy） ===== */
let SCORE_METRIC = (localStorage.getItem('route_score_metric') || 'distance');


/* ===== 休憩候補組み合わせ探索アルゴリズム群 ===== */
// 等間隔貪欲 / ビームサーチ / DP / 総当たり などをここに集約

/* ===== 等間隔貪欲法（修正版）: 候補がある場合は必ず採用 ===== */
function greedyTopKCandidates(restGroups, cumTotals, K = 3) {
  const R = restGroups.length;
  const groups = [];

  for (let t = 0; t < R; t++) {
    const g = restGroups[t];
    const target = cumTotals.D * (t + 1) / (R + 1); // m（距離基準）
    let pois = (g && Array.isArray(g.pois)) ? g.pois : [];

    if (!pois.length) {
      groups.push([null]); // 物理的に候補ゼロ
      continue;
    }
    // ▼ _proj が無い POI には、休憩トリガー距離を暫定で入れて候補落ちを防ぐ
if (g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}
    // --- 射影値 _proj が無い場合に補完 ---
    const needProj = pois.some(p => p && (!p._proj || !Number.isFinite(p._proj.cumD)));
    if (needProj && window.__routeCums) {
      const { cum, coords } = window.__routeCums;
      pois.forEach(p => {
        if (p && (!p._proj || !Number.isFinite(p._proj.cumD))) {
          p._proj = projectToRoute(p.lat, p.lon, coords, cum);
        }
      });
    }

    // --- 射影値があるものを優先 ---
    const withProj = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    let ranked;

    const base = withProj.length ? withProj : pois;
 ranked = base
   .map(p => ({ p, c: nodeCost(p, target) }))
   .sort((a, b) => a.c - b.c)
   .slice(0, K)
   .map(x => x.p);

    // 候補があれば必ず採用。空なら [null]
    groups.push(ranked.length ? ranked : [null]);
  }

  return groups;
}

/* ===== ビームサーチ（ゼロAPI）：候補ありは必採用＋未採用補修 ===== */
function beamSearch(restGroups, cumTotals, width = 3, minRest = 1, nullPenalty = 1e6, forbidNullWhenCand = true) {
  // beams 要素: { picks: [...(p or null)], score, pickedCount }
  let beams = [{ picks: [], score: 0, pickedCount: 0 }];

  for (let i = 0; i < restGroups.length; i++){
    const g = restGroups[i];
let pois = (g?.pois || []).slice();

// ▼ _proj が無い/不完全な POI には、休憩トリガーの routeD を使って暫定射影を付与
if (pois.length && g?.rest && Number.isFinite(g.rest.routeD)) {
  pois.forEach(p => {
    if (!p) return;
    if (!p._proj || !Number.isFinite(p._proj.cumD)) {
      p._proj = { cumD: Number(g.rest.routeD), cumT: NaN, cumE: NaN };
    }
  });
}

// ここから先は従来と同じロジック
const valid = pois.filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
const totalD = Number(cumTotals?.D) || 0;
const target = targetCumDForIndex(i, restGroups.length, totalD);
valid.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));

const cand = valid.length
  ? (forbidNullWhenCand ? valid : [...valid, null])
  : [null];


    const next = [];
    for (const b of beams){
      for (const p of cand){
        const picks = b.picks.concat([p]);

        // ゼロAPI近似評価
        const ev = evalByCums(restGroups, picks, cumTotals);
        let s = ev.score;

        // ★ 候補があるのに null を選んだ場合は強ペナルティ
        if (p === null && valid.length){
          s += nullPenalty;
        }

        next.push({
          picks,
          score: Number.isFinite(s) ? s : 0,
          pickedCount: b.pickedCount + (p ? 1 : 0)
        });
      }
    }

    // スコア上位 width 件のみ保持
    next.sort((a,b)=>a.score - b.score);
    beams = next.slice(0, width);
  }

  // ★ 最低採用数の制約（候補があるトリガー分を採用）
  let final = beams.filter(b => b.pickedCount >= minRest);
  if (!final.length) final = beams;

  // ★ 未採用(null)の“補修”をかけてから最終スコア再計算
  final = final.map(b => {
    const fixedPicks = repairNullPicks(restGroups, cumTotals, b.picks);
    const ev = evalByCums(restGroups, fixedPicks, cumTotals);
    return {
      picksByTrigger: fixedPicks,  // ← 修正後の picks を返す（以後の表示は必ず採用表示になる）
      score: ev.score,
      stats: ev.stats
    };
  }).sort((a,b)=>a.score - b.score);

  return final.slice(0, 3);
}

/* ===== DP（層グラフ最短路） ===== */
// restGroups: [{rest, pois:[p...]}, ...], cumTotals: {D,T,E}
function dpSearch(restGroups, cumTotals){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;

  // 各層の候補（_proj が無いものは routeD で暫定補完）
  const layers = restGroups.map((g, i) => {
    let pois = (g?.pois || []).slice();
    if (g?.rest && Number.isFinite(g.rest.routeD)) {
      pois.forEach(p => {
        if (!p._proj || !Number.isFinite(p._proj.cumD)) {
          p._proj = { cumD: Number(g.rest.routeD), perpM: Number(p.distFromTriggerM)||0 };
        }
      });
    }
    // 等間隔ターゲットに対する単点コスト（並べ替えにも使う）
    const target = targetCumDForIndex(i, R, totalD);
    pois.sort((a,b)=> nodeCost(a, target) - nodeCost(b, target));
    return pois;
  });

  // DPテーブル
  // dp[i][j] = 第i層で j番目POIを選んだ時の最小コスト
  // prev[i][j] = 一つ前の層のインデックス
  const dp = [], prev = [];
  for (let i=0;i<R;i++) { dp[i] = []; prev[i] = []; }

  // 初期化：スタート→第0層の各POIのコスト（単点コストのみ）
  const t0 = targetCumDForIndex(0, R, totalD);
  layers[0].forEach((p, j) => {
    dp[0][j] = nodeCost(p, t0);
    prev[0][j] = -1;
  });

  // 遷移：第i-1層 → 第i層
  for (let i=1;i<R;i++){
    const ti = targetCumDForIndex(i, R, totalD);
    for (let j=0;j<layers[i].length;j++){
      let best = { cost: Infinity, k: -1 };
      const pj = layers[i][j];

      for (let k=0;k<layers[i-1].length;k++){
        const costPrev = dp[i-1][k];
        if (!Number.isFinite(costPrev)) continue;

        // エッジコスト（区間の「等間隔ズレ」補正を少し加点：累積距離の前後差が狭すぎ/広すぎを抑制）
        const pi = layers[i-1][k];
        const segD = Math.abs((pj?._proj?.cumD||0) - (pi?._proj?.cumD||0)); // m
        const ideal = totalD / (R + 1); // 理想区間長
        const intervalPenalty = Math.abs(segD - ideal) / 1000; // km差分

        const edge = intervalPenalty * 0.5; // 調整係数
        const node = nodeCost(pj, ti);

        const cand = costPrev + edge + node;
        if (cand < best.cost){ best = { cost: cand, k }; }
      }
      dp[i][j] = best.cost;
      prev[i][j] = best.k;
    }
  }

  // 復元（第R-1層の最小コスト終端から辿る）
  let endJ = -1, bestVal = Infinity;
  for (let j=0;j<layers[R-1].length;j++){
    if (dp[R-1][j] < bestVal){ bestVal = dp[R-1][j]; endJ = j; }
  }
  if (endJ < 0) {
    // どの層にも候補が無い場合の保険：空で返す
    return { picksByTrigger: Array(R).fill(null), stats:{dist:[],time:[],energy:[]}, score: 1e9 };
  }

  const picks = Array(R).fill(null);
  let i = R-1, j = endJ;
  while (i >= 0 && j >= 0){
    picks[i] = layers[i][j];
    j = prev[i][j];
    i--;
  }

  // 既存の近似評価で統計を作成（可視化のため）
  const ev = evalByCums(restGroups, picks, cumTotals);
  return { picksByTrigger: picks, stats: ev.stats, score: ev.score };
}


  
/* ===== 超シンプル・プロファイラ ===== */
// --- PROFILER を無効化 ---
const PERF = { on:false, rows:[], max:0 };

function perfNow(){ return 0; }
function tStart(name){ return null; }
function tEnd(tok, info){}
function renderPerf(){}
function exportPerfCSV(){}
window.addEventListener('DOMContentLoaded', ()=>{
  const on=$('perfToggle'), reset=$('perfResetBtn'), exp=$('perfExportBtn');
  on && (on.onchange=()=>{ PERF.on = on.checked; });
  reset && (reset.onclick=()=>{ PERF.rows.length=0; renderPerf(); });
  exp && (exp.onclick=exportPerfCSV);
  renderPerf();
});

/* ===== API 利用カウンタ ===== */
const API_USED = {
  orsTotal: 0,             // ページ全体での ORS 呼び出し回数
  orsAtSolveStart: 0,
  lastSolveOrs: 0,         // 直近の「ルート探索」1回で使った ORS 回数

  overpassTotal: 0,        // ページ全体での Overpass 呼び出し回数
  overpassAtSolveStart: 0,
  lastSolveOverpass: 0     // 直近の「ルート探索」1回で使った Overpass 回数
};

// アルゴリズムコード → 表示用ラベル
function algoLabel(code){
  switch(code){
    case 'greedy':     return '等間隔貪欲（ゼロAPI）';
    case 'beam3':      return 'ビームサーチ（幅3・ゼロAPI）';
    case 'bruteforce': return '総当たり（API多め・高精度）';
    case 'dp':         return 'DP（最短路・ゼロAPI）';
    default:           return code;
  }
}

// 直近の探索結果を UI に反映
function updateAlgoPerfSummary(algoCode){
  const box = $('algoPerfSummary');
  if (!box) return;

  const targetName = `探索: ${algoCode}`;
  const rows = [...PERF.rows].reverse();
  const row = rows.find(r => r.name === targetName);
  const msText = row ? `${row.ms.toFixed(1)} ms` : '不明';

  const ors  = API_USED.lastSolveOrs;
  const ovp  = API_USED.lastSolveOverpass;

  box.innerHTML =
    `アルゴリズム: <b>${algoLabel(algoCode)}</b><br>` +
    `処理時間: <b>${msText}</b><br>` +
    `この探索で使用した ORS Directions API: <b>${ors} 回</b><br>` +
    `この探索で使用した Overpass API: <b>${ovp} 回</b><br>` +
    `<small style="color:#777">
      ※実際の API 残りクォータは OpenRouteService / Overpass の
      アカウント設定に依存します。このツールでは「このページを開いてから
      何回呼んだか」の概算のみを表示しています。
    </small>`;
}



// ▼▼ 休憩リスト用変数 ▼▼
let restList = []; // 休憩地点を保存
let restGroups = []; 

const ICON = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
const ICONS = {start:ICON('green'),via:ICON('blue'),goal:ICON('red')};

const OVERPASS_MIN_INTERVAL = 1800; // 1.8s（必要なら 2000～2500 まで上げてOK）
let __overpassLastTs = 0;
const __overpassCache = new Map();  // key=query文字列, value=JSON

function formatDist(m){return (m/1000).toFixed(2)+' km';}
function formatDur(s){const m=Math.round(s/60);return m<60? m+' 分' : (Math.floor(m/60)+' 時間 '+(m%60)+' 分');}

/* ====== 初期化 ====== */
window.addEventListener('DOMContentLoaded',()=>{
    const btnCmp = $('btnAlgoCompare');
  if (btnCmp) {
    btnCmp.onclick = runAlgoCompareDebug;
  }
  // ▼ Excel用CSVダウンロードボタンの紐付け
  const csvBtn = $('dbgAlgoCsv');
  if (csvBtn) {
    csvBtn.onclick = downloadAlgoCompareCsv;
  }
    // ▼ 総当たり 全組み合わせ CSV ボタンの紐付け
  const bfCsvBtn = $('btnDownloadBruteforceCsv');
  if (bfCsvBtn) {
    bfCsvBtn.onclick = downloadBruteforceCsv;
  }

  /* ===== 評価ウェイト UI 初期化 ===== */
  function reflectWeightsToInputs(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    if(!WA || !WP || !WT) return;
    WA.value = String(SCORE_WEIGHTS.wAlign);
    WP.value = String(SCORE_WEIGHTS.wPerp);
    WT.value = String(SCORE_WEIGHTS.wTrig);
  }

  // ▼ スコア指標セレクタの初期化
const sm = document.getElementById('scoreMetricSelect');
if (sm) {
  sm.value = SCORE_METRIC;             // 保存済みの選択を反映
  sm.addEventListener('change', ()=>{  // 変更時に保存
    setScoreMetric(sm.value);
    // ※必要なら直近結果の再表示を呼ぶ（例：最後のトップ3を作り直す等）
  });
}


  function saveWeights(){
    localStorage.setItem('route_score_weights', JSON.stringify(SCORE_WEIGHTS));
  }

  function bindWeightsUI(){
    const WA = document.getElementById('wAlign');
    const WP = document.getElementById('wPerp');
    const WT = document.getElementById('wTrig');
    const RB = document.getElementById('btnWeightsReset');

    if(WA){
      WA.addEventListener('input', ()=>{
        const v = Number(WA.value);
        SCORE_WEIGHTS.wAlign = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WP){
      WP.addEventListener('input', ()=>{
        const v = Number(WP.value);
        SCORE_WEIGHTS.wPerp = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(WT){
      WT.addEventListener('input', ()=>{
        const v = Number(WT.value);
        SCORE_WEIGHTS.wTrig = Number.isFinite(v) && v>=0 ? v : 0;
        saveWeights();
      });
    }
    if(RB){
      RB.addEventListener('click', ()=>{
        SCORE_WEIGHTS = { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
        saveWeights();
        reflectWeightsToInputs();
      });
    }
  }

  // ページ読み込み時に反映＆バインド
  reflectWeightsToInputs();
  bindWeightsUI();

  
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {attribution:'©OpenStreetMap'}).addTo(map);
  restBeamLayer = L.layerGroup().addTo(map);

  // 検索ボタン：検索後に入力欄クリア
  $('searchBtn').onclick = () => {
    const val = $('placeInput').value.trim();
    if (!val) return;
    nomSearch(val);
    $('placeInput').value = ''; // 入力欄リセット
  };
  $('drawBtn').onclick=drawRoutes;

  $('solveCombBtn').onclick = async () => {
     const algoCode = $('algoSelect').value;                // どのアルゴリズムか
  const tkSolveAll = tStart(`探索: ${algoCode}`);        // 全体計測開始

  // ★このタイミングの API 累計値を記録（差分を見るため）
  const prevOrs = API_USED.orsTotal;
  const prevOv  = API_USED.overpassTotal;
  try {
    // 0) 前提チェック
    if (!routeData.fastest){
      alert('先に「休憩場所検索」を実行してください。');
      return;
    }
    if (!Array.isArray(restGroups) || !restGroups.length){
      alert('休憩トリガーがありません。');
      return;
    }
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    if (poiGroups.every(a => !a.length)){
      alert('各休憩トリガーにPOIがありません。POI設定（カテゴリ/半径/件数）を見直してください。');
      return;
    }
    ensureProjections();
    injectAlgoDebugButtons(window.__cumTotals);

    // 1) 入力＆共有データ取得
    const algo = $('algoSelect').value; // 'greedy' | 'beam3' | 'bruteforce'
    const start = pts.find(p=>p.type==='start') || pts[0];
    const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
    if (!start || !goal){
      alert('スタート/ゴールが見つかりません。');
      return;
    }
    const cumTotals = window.__cumTotals; // drawRoutes() 実行後に buildCums() で設定済みの累積総量

   // 2) アルゴリズム分岐（★ 計測フック追加版）
if (algo === 'greedy'){
  const tkG = tStart('探索: 等間隔貪欲');  // ← 計測開始
  try {
    // 等間隔ターゲットに近い「上位K候補」を各トリガーから集める
    const K = 3; // ここを2～5で調整可
    const candGroups = greedyTopKCandidates(restGroups, cumTotals, K);

    // 直積（上限をかけて暴走防止）
    const combos = enumerateCombinations(candGroups, /*perGroupLimit=*/K, /*hardCap=*/60);
    if (!combos.length){
      alert('組み合わせ候補が作れませんでした（候補不足）。');
      return;
    }

    // 全候補を「累積差分の近似評価」で採点（ゼロAPI）
    const scored = combos.map(cmb => {
      const picksByTrigger = cmb; // null含む（未採用も許容）
      const ev = evalByCums(restGroups, picksByTrigger, cumTotals); // dist/time/energy のσ合計でスコア
      return {
        score: ev.score,
        stats: ev.stats,
        picksByTrigger,
        picks: picksByTrigger.filter(Boolean)
      };
    });

    // スコア昇順で上位3件を表示
    scored.sort((a,b)=>a.score-b.score);
    showTop3Combos(scored.slice(0,3));
  } finally {
    // info には「トリガー数」「候補の総数」「試したコンボ数」を入れると見やすい
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkG, `R=${R}, cand=${totalCand}`);
  }
  return;
}

if (algo === 'beam3'){
  const tkB = tStart('探索: ビームサーチ');  // ← 計測開始
  try {
    // 「候補があるトリガー数」は必ず採用する
    const triggersWithCand = (restGroups || []).reduce((n, g) => {
      const valid = (g?.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
      return n + (valid.length ? 1 : 0);
    }, 0);

    const width = 3; // ビーム幅
    const top = beamSearch(restGroups, cumTotals, /*width*/width, /*minRest*/triggersWithCand, /*nullPenalty*/1e6, /*forbidNullWhenCand*/true);
    top.forEach(t => t.picks = t.picksByTrigger.filter(Boolean));
    showTop3Combos(top);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkB, `R=${R}, cand=${totalCand}, width=3`);
  }
  return;
}

if (algo === 'bruteforce'){
  const tkBF = tStart('探索: 総当たり');  // ← 計測開始（全体）
  try {
    // --- 総当たり（API多め・高精度）---
    //const perGroupLimit = Math.max(1, Math.min(3, Number($('poiLimit').value)||3)); // 各トリガー最大件数
    const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
    const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);
    const combos = enumerateCombinations(poiGroups, perGroupLimit, 60);             // 総当たり上限60通り
    if (!combos.length){
      alert('組み合わせ候補が作れませんでした。');
      return;
    }

    const profile = 'cycling-road'; // ORSプロファイル（cycling-road 等）
    const results = [];

    // 逐次でAPI負荷を抑えつつ評価
    let okCount = 0, failCount = 0;
    for (const cmb of combos){
      const picks = cmb.filter(Boolean); // null除外
      const wps = [start, ...picks, goal].map(p=>({
        lat: p.lat, lon: p.lon, name: p.name || 'POI'
      }));

      // （任意）1コンボ毎の計測が欲しいなら、ここで開始
      const tkOne = tStart('総当たり: 1コンボ');

      try {
        const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);
        const rawScore = comboScore(stats); // 距離/時間/エネの標準偏差の合計
        const weights  = picks.map(p => Number(p?._w) || 1);
        const meanW    = weights.length ? (weights.reduce((a,b)=>a+b,0)/weights.length) : 1;
        const score    = rawScore / Math.max(0.1, meanW); // 重みが高い組合せを優遇
        results.push({ score, rawScore, feature, picks, picksByTrigger: cmb, stats });
        okCount++;
      } catch(e){
        console.warn('combo route fail', e);
        failCount++;
        // 失敗した組合せはスキップ
      } finally {
        // 1コンボの経過時間を残したい場合（ログが多いと感じたら外してOK）
        //tEnd(tone, `ok=${okCount}, fail=${failCount}`);
      }
    }

    // スコア昇順に上位3件
    results.sort((a,b)=>a.score-b.score);
    showTop3Combos(results.slice(0,3));
    // ★ 追加：総当たりの全組み合わせを保存＆一覧表示
    window.__bruteforceAllResults = results;
    renderBruteforceAllResults(results);
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkBF, `R=${R}, cand=${totalCand}, cap=60`);
  }
  return;
}

if (algo === 'dp'){
  const tkDP = tStart('探索: DP');  // ← 計測開始
  try {
    const best = dpSearch(restGroups, cumTotals);
    best.picks = best.picksByTrigger.filter(Boolean);
    showTop3Combos([best]);  // DPは最適解1本を出す
  } finally {
    const R = restGroups?.length || 0;
    const totalCand = (restGroups||[]).reduce((s,g)=>s+(g?.pois?.length||0),0);
    tEnd(tkDP, `R=${R}, cand=${totalCand}`);
  }
  return;
}


    // 未知の値（保険）
    alert('未知のアルゴリズム指定です。');
    } catch (err){
    console.error(err);
    alert('ルート探索でエラー: ' + (err.message || err));
  } finally {
    // ★今回の探索で使った API 回数（差分）を記録
    API_USED.lastSolveOrs      = API_USED.orsTotal      - prevOrs;
    API_USED.lastSolveOverpass = API_USED.overpassTotal - prevOv;

    // 計測終了（PERF に記録）
    tEnd(tkSolveAll);

    // UI に反映
    updateAlgoPerfSummary(algoCode);
  }
};


  new Sortable($('pointList'),{
    animation:150,
    onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li.dataset.idx]);fixType();drawList();}
  });
});

/* ====== 地点管理 ====== */
function addPoint(p){
  p.type=pts.length?'':'start';
  pts.forEach(d=>{if(d.type==='goal')d.type='via';});
  pts.push(p);
  if(pts.length>1) pts[pts.length-1].type='goal';
  drawList();
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li.dataset.idx=i;
    const name = p.name + (p.isRest? '（休憩）':'');
    li.innerHTML = `<span>${name}${p.isRest? ' <small>(' + p.lat.toFixed(5)+','+p.lon.toFixed(5)+')</small>':''}</span><button class="del">×</button>`;
    li.querySelector('.del').onclick=()=>{pts.splice(i,1); fixType(); drawList();};
    ul.appendChild(li);
  });
}

/* ====== 検索処理（候補表示対応版） ====== */
async function nomSearch(q){
  const url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  const arr=await (await fetch(url)).json();
  const sug=$('searchSuggestions');
  sug.innerHTML='';
  if(!arr.length){alert('見つかりません');return;}
  // 候補をリスト表示
  arr.forEach(o=>{
    const li=document.createElement('li');
    li.textContent=o.display_name;
    li.style.cursor='pointer';
    li.style.padding='4px';
    li.onmouseenter=()=>li.style.background='#eee';
    li.onmouseleave=()=>li.style.background='';
    li.onclick=()=>{
      addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
      sug.innerHTML=''; // クリック後クリア
      $('placeInput').value='';
    };
    sug.appendChild(li);
  });
}


/* ====== ORS ====== */
async function post(url,body){
  const r=await fetch(url,{
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':ORS_KEY},
    body:JSON.stringify(body)
  });
  if(!r.ok) throw new Error(r.status);
  return r.json();
}
async function dir(body,profile){
  const wait=1100-(Date.now()-lastDirTs); 
  if(wait>0) await new Promise(r=>setTimeout(r,wait));

  // ★ ORS 呼び出し回数カウント
  API_USED.orsTotal++;

  const d=await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`,body);
  lastDirTs=Date.now();
  return d;
}


/* ====== ルート表示関連 ====== */
function clearRouteLayers(){
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); });
  routeLayers={};
}
function setActiveButton(btn){
  document.querySelectorAll('#routeButtons button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
}
function showSingleRoute(type, noFit){
  clearRouteLayers();
  const colorMap = { shortest:'#ff0000', fastest:'#0066ff', slope:'#ff9900', arterial:'#00b26b' };
  const f = routeData[type];
  if(!f){ alert('まだ計算していません'); return; }
  routeLayers[type] = L.geoJSON(f, { style:{ color: colorMap[type], weight: 6 } }).addTo(map);
  if(!noFit) map.fitBounds(routeLayers[type].getBounds().pad(0.1));
}
function toggleSingleRoute(type, btn){
  showSingleRoute(type);
  setActiveButton(btn);
}

/* ====== ルート計算・休憩・POI ====== */
async function drawRoutes(){
  if(pts.length<2){alert('2地点以上登録してください');return;}

  clearRouteLayers();
  if(markerLayer) map.removeLayer(markerLayer);

  markerLayer=L.layerGroup().addTo(map);
  
  pts.forEach(p=>markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ICONS[p.type||'via']}).bindTooltip(p.name)));

  const coords=pts.map(p=>[p.lon,p.lat]);
  const profile = 'cycling-road';
  const base={coordinates:coords,elevation:true,extra_info:['steepness']};

  try{
    const tkORS = tStart('ORS: 最短/最速');
const shortest = await dir({...base, preference:'shortest'}, profile);
const fastest  = await dir({...base, preference:'fastest'},  profile);
tEnd(tkORS, `pts=${pts.length}`);


    let slope = shortest.features[0];
    let arterial = fastest.features[0];
    if(coords.length===2){
      const tkAlt = tStart('ORS: 代替経路');
const alt = await dir({...base, preference:'shortest',
  alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}, profile);
tEnd(tkAlt, `alts=${(alt.features||[]).length}`);

      const feats = alt.features || [];
      if(feats.length){
        function steepSum(f){
          const vals=((f.properties||{}).extras||{}).steepness?.values||[];
          let s=0; for(const v of vals){ s+=Math.abs(v[2]||0); }
          return s;
        }
        slope = feats.reduce((a,b)=> steepSum(a)<steepSum(b)?a:b);
        // 幹線優先（代替経路＋fastest の中からスコア最大）
        arterial = feats.concat(fastest.features || [])
        .reduce((best,cand)=> arterialScore(cand) > arterialScore(best) ? cand : best, arterial);
      }
    }

    routeData.shortest = shortest.features[0];
    routeData.fastest  = fastest.features[0];
    routeData.slope    = slope;
    routeData.arterial = arterial;

    const s1 = routeData.shortest.properties.summary;
    const s2 = routeData.fastest.properties.summary;
    const s3 = routeData.slope.properties.summary;
    $('routeInfo').innerHTML =
      `<b>最短</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>最速</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>勾配</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}<br>`+
      (routeData.arterial ? `<b>幹線</b> ${formatDist(routeData.arterial.properties.summary.distance)} / ${formatDur(routeData.arterial.properties.summary.duration)}` : '');
    $('distanceScore').textContent = '距離差（最速-最短）: '+(s2.distance - s1.distance).toFixed(0)+' m';

    /* ===== 休憩地点挿入 ===== */
    const mass = 75; // 体重+バイク質量(例)
    const flat = 18; // 平坦係数
    const baseFeature = routeData.arterial || routeData.fastest;
    const tkRest = tStart('休憩トリガ生成');
const rests = await makeRestPoints(baseFeature, mass, flat);
tEnd(tkRest, `hits=${rests.length}`);


    restGroups = (rests || []).map(r => ({ rest: r, pois: [] }));

    restList = []; // 前回のリストをリセット

    if (rests.length) {
      // リストに挿入（ゴール直前）
     rests.forEach(r => {
       pts.splice(pts.length-1, 0,
                  { name:'休憩', lat:r.lat, lon:r.lon, type:'via', isRest:true });
        // ▼ r が有効なスコープ内で push
        restList.push({distance:(r.routeD/1000).toFixed(2), lat:r.lat, lon:r.lon});
      });
      drawList();
      updateRestListPanel(); // 休憩地点リスト表示更新

      // 休憩マーカー
      for (const r of rests) {
        L.marker([r.lat, r.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/yellow-dot.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32]
          })
        }).bindTooltip('休憩').addTo(markerLayer);
      }

      // POI検索（半径固定・近い順に n 件）
if ($('poiToggle').checked) {
  const baseRadius = Number($('poiRadius').value) || 500;
  const limit = Math.max(1, Number($('poiLimit').value) || 5);
  // ★ ここで今回の休憩場所検索開始時点のカウントを記録
  const overpassBefore = OVERPASS_CALL_TOTAL;

  for (let idx = 0; idx < rests.length; idx++) {
    const r = rests[idx];
    try {
      const tkPOI = tStart(`POI#${idx+1}`);
const pois = await fetchPoisAround(r.lat, r.lon, baseRadius, limit);
tEnd(tkPOI, `found=${pois.length}`);

      logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 半径${baseRadius}m → ${pois.length}件（近い順）`);

      // ▼ 追加：この休憩トリガーのPOIを保存
      if (restGroups[idx]) {
        restGroups[idx].pois = pois.map(p => ({ ...p, triggerIndex: idx }));
      }
        
      // 既存：マップに描画
      pois.forEach(po => {
        L.marker([po.lat, po.lon], {
          icon: new L.Icon({
            iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple.png',
            iconSize: [24, 24],
            iconAnchor: [12, 24]
          })
        }).bindTooltip(`${po.name}${typeof po.distFromTriggerM === 'number' ? ` (${formatDist(po.distFromTriggerM)})` : ''}`).addTo(markerLayer);
      });
    } catch (e) {
      logRest(`[POI] ${(r.routeD / 1000).toFixed(2)} km: 取得失敗`);
    }
  }

  //パネルへ反映
  ensureProjections();
  updateRestPoiPanel();
  // ★ ここで今回使った回数と累計を「最後の行」として出す
  const usedThisTime = OVERPASS_CALL_TOTAL - overpassBefore;
  logRest(`--- Overpass API 呼び出し: 今回 ${usedThisTime} 回 / 累計 ${OVERPASS_CALL_TOTAL} 回 ---`);
}

    }

// デフォルト表示は幹線優先（なければ最速）
const prefer = routeData.arterial ? 'arterial' : 'fastest';
showSingleRoute(prefer, true);
setActiveButton(prefer === 'arterial' ? $('btnShowArterial') : $('btnShowFastest'));

  }catch(e){
    console.error(e);
    alert('ルート取得失敗: '+e.message);
  }
}

/* ===== 休憩トリガー関連 ===== */
function logRest(msg){ $('restDebug').textContent += msg + "\n"; }
function energyStepKJ(dist,dz,mass,flat=18){
  return flat*(dist/1000)+Math.max(dz,0)*mass*9.80665/1000;
}
async function totalEnergyKJ(feature,mass,flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments||[];
  let tot=0;
  for(const s of segs){
    for(const st of s.steps||[]){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz = coords[i1].length>=3 ? (coords[i1][2]-coords[i0][2]) : 0;
      tot += energyStepKJ(d,dz,mass,flat);
    }
  }
  return tot;
}
async function makeRestPoints(feature,mass,flat){
  const coords=feature.geometry.coordinates;
  const segs=(feature.properties.segments||[]);
    // 旅全体の合計（距離は既存の totalDist 代わりに summary.distance を利用）
  const totalD = feature?.properties?.summary?.distance || 0;        // m
  const totalT = feature?.properties?.summary?.duration || 0;        // s
  const totalE = await totalEnergyKJ(feature, mass, flat);           // kJ

    // ▼▼ 追加：全トリガ共通の「スキップ判定 & push」ヘルパ ▼▼
  function getSkipUI() {
    const skipGoalOn  = document.getElementById('skipNearGoalToggle')?.checked ?? false;
    const skipNodeOn  = document.getElementById('skipNearNodeToggle')?.checked ?? false;
    const skipGoalKmV = Number(document.getElementById('skipNearGoalKm')?.value);
    const skipNodeMV  = Number(document.getElementById('skipNearNodeM')?.value);
    return {
      skipGoalOn,
      skipNodeOn,
      skipGoalKm: (Number.isFinite(skipGoalKmV) && skipGoalKmV >= 0) ? skipGoalKmV : 0,
      skipNodeM : (Number.isFinite(skipNodeMV)  && skipNodeMV  >= 0) ? skipNodeMV  : 0
    };
  }

  function nearExistingNode(lat, lon, skipNodeM) {
    if (!Array.isArray(pts) || !pts.length || !skipNodeM) return false;
    const P = L.latLng(lat, lon);
    return pts.some(p => {
      if (!p || p.isRest) return false; // 自動挿入の休憩点は除外
      const Q = L.latLng(p.lat, p.lon);
      return P.distanceTo(Q) <= skipNodeM;
    });
  }

  /**
   * 共通push関数：
   *  - hereCumM：候補の累積距離[m]
   *  - lat, lon：候補の緯度経度
   *  - label   ：ログ用 "[ACCUM] / [STAT] / [PERCENT]" など
   *  - progTsec, progEkJ：その時点までの累積（不明なら省略→距離比で近似）
   */
  function pushIfNotSkipped(raw, hereCumM, lat, lon, label, progTsec, progEkJ) {
    const { skipGoalOn, skipNodeOn, skipGoalKm, skipNodeM } = getSkipUI();

    // 残量計算（累積が未指定なら距離比で近似）
    const remainD = Math.max(0, (totalD || 0) - (hereCumM || 0)); // m
    let usedT = progTsec, usedE = progEkJ;
    if (!Number.isFinite(usedT) || !Number.isFinite(usedE)) {
      const ratio = (Number.isFinite(totalD) && totalD > 0) ? (hereCumM / totalD) : 0;
      usedT = (totalT || 0) * ratio;
      usedE = (totalE || 0) * ratio;
    }
    const remainT = Math.max(0, (totalT || 0) - (usedT || 0)); // s
    const remainE = Math.max(0, (totalE || 0) - (usedE || 0)); // kJ

    // 1) ゴール手前スキップ
    if (skipGoalOn && Number.isFinite(remainD) && remainD <= skipGoalKm * 1000) {
      logRest(`${label} ${(hereCumM/1000).toFixed(2)} km → HIT（スキップ: ゴールまで ${(remainD/1000).toFixed(2)} km / ${formatDur(remainT)} / ${remainE.toFixed(0)} kJ）`);
      return;
    }
    // 2) 既存地点近接スキップ
    if (skipNodeOn && nearExistingNode(lat, lon, skipNodeM)) {
      logRest(`${label} ${(hereCumM/1000).toFixed(2)} km → HIT（スキップ: 既存地点に ${skipNodeM}m 以内）`);
      return;
    }
    // 採用
    raw.push({ lat, lon, routeD: hereCumM });
    logRest(`${label} ${(hereCumM/1000).toFixed(2)} km → HIT`);
  }


  // 現在位置までの累積（秒 / kJ）— 各stepで足していく
  let cumTsec = 0;   // s
  let cumEkJ  = 0;   // kJ
  
  const hasEle = coords[0].length>=3;
  const cumDist=[0];
  for(let i=1;i<coords.length;i++){
    cumDist[i]=cumDist[i-1]+L.latLng(coords[i][1],coords[i][0]).distanceTo([coords[i-1][1],coords[i-1][0]]);
  }

  const basis=$('restBasis').value;
  const thr=basis==='time' ? Number($('restMinutes').value)*60 : Number($('restKJ').value);
  let raw=[];

  // 積算トリガ
  if($('optAccum').checked){
    let acc=0;
    for(const s of segs){
      for(const st of s.steps||[]){
        const [i0,i1]=st.way_points||[0,0];
        const d=st.distance||0, t=st.duration||0;
        const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
        const dE = energyStepKJ(d,dz,mass,flat);
        // ★ 累積（秒 / kJ）を更新
        cumTsec += t;
        cumEkJ  += dE;
        acc += (basis==='time') ? t : dE;
       if (acc >= thr) {
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];
  const hereCum = cumDist[i1]; // m

  // 積算は cumTsec / cumEkJ を渡せる（精密ログ）
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[ACCUM]', /*progTsec*/cumTsec, /*progEkJ*/cumEkJ);
  acc = 0; // 次ターゲットへ
}


      }
    }
  }

  // 統計トリガ（安全化パッチ）
  if ($('optStatTrigger').checked) {
    const meanRaw = Number($('statMean').value);
    const varRaw  = Number($('statVar').value);

    const mean  = Number.isFinite(meanRaw) ? meanRaw : 0;
    const sigma = (Number.isFinite(varRaw) && varRaw >= 0) ? Math.sqrt(varRaw) : 0;

    // Box-Muller：0 の log 回避
    const normal = () => {
      let u = Math.random(); if (u <= 1e-12) u = 1e-12;
      let v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    };

    // 休憩間隔の下限（km）。必要なら 0.3～1.0 で好み調整
    const MIN_KM = 0.5;

    let target = Math.max(MIN_KM, mean + sigma * normal());
    let accKm  = 0;

    for (const s of segs) {
      for (const st of s.steps || []) {
        const [i0, i1] = st.way_points || [0, 0];
        const d = st.distance || 0;        // m
        accKm += d / 1000;

        if (accKm >= target) {
  const hereCum = cumDist[i1];          // m
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];

  // 統計は実測の時間/エネ累積を持っていない→距離比で近似
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[STAT]');
  target = Math.max(MIN_KM, mean + sigma * normal());
  accKm = 0;
}

      }
    }
  }


   // 割合トリガ（安全化パッチ）
  if ($('optPercentTrigger').checked) {
    // 入力値の正規化（1%～90%に丸め：好みで調整可）
    let stepPct = Number($('percentStep').value) / 100;
    if (!Number.isFinite(stepPct)) stepPct = 0.25;
    stepPct = Math.min(0.9, Math.max(0.01, stepPct));

    const metric = $('percentMetric').value;

    const totalDist   = feature.properties.summary.distance;     // m
    const totalTime   = feature.properties.summary.duration;     // s
    const totalEnergy = await totalEnergyKJ(feature, mass, flat); // kJ

    const total = (metric === 'distance') ? totalDist
                : (metric === 'time')     ? totalTime
                :                           totalEnergy;

    if (!(Number.isFinite(total) && total > 0)) {
      logRest('[PERCENT] 総量が0または非数のためスキップ');
    } else {
      // 閾値は「累積ターゲット」を順に足していく方式
      let nextThreshold = stepPct * total;
      let progressed    = 0;
      const hasEle = coords[0].length >= 3;

      for (const s of segs) {
        for (const st of s.steps || []) {
          const [i0, i1] = st.way_points || [0, 0];
          const d  = st.distance || 0;  // m
          const t  = st.duration || 0;  // s
          const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
          const dE = energyStepKJ(d, dz, mass, flat);

          if (metric === 'distance') progressed += d;
          else if (metric === 'time') progressed += t;
          else progressed += dE;

          // 1ステップで複数回閾値を跨ぐ可能性があるので while で対応
          while (progressed >= nextThreshold) {
  const hereCum = cumDist[i1];      // m
  const candLat = coords[i1][1];
  const candLon = coords[i1][0];

  // 時間/エネを実測で持ってないケース→距離比で近似
  pushIfNotSkipped(raw, hereCum, candLat, candLon, '[PERCENT]');
  nextThreshold += stepPct * total;
}
        }
      }
    }
  }

  

  return raw;
}

/* ===== 区間統計（各ルート） ===== */
async function calcLegStats(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const segs   = feature.properties.segments || [];
  const hasEle = coords[0].length >= 3;

  const legDist = [], legTime = [], legEnergy = [];
  for (const s of segs) {
    for (const step of (s.steps || [])) {
      const [i0, i1] = step.way_points || [0, 0];
      const d  = step.distance || 0;  // m
      const t  = step.duration || 0;  // s
      const dz = hasEle ? ((coords[i1][2] || 0) - (coords[i0][2] || 0)) : 0;
      legDist.push(d / 1000);
      legTime.push(t / 60);
      legEnergy.push(energyStepKJ(d, dz, mass, flat));
    }
  }
  return {dist:legDist, time:legTime, energy:legEnergy};
}

function summaryStats(arr){
  if(!arr.length) return {mean:0,var:0,std:0};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length;
  return {mean:m, var:v, std:Math.sqrt(v)};
}

/* ===== Overpass（保守的実装） ===== */
async function overpassQuery(query) {
  const endpoints = [
    'https://overpass-api.de/api/interpreter',
    //'https://overpass.kumi.systems/api/interpreter'
  ];
  let lastStatus = 0, lastText = '';

  for (const ep of endpoints) {
    try {
      // ★ ここで呼び出し回数をカウント
      API_USED.overpassTotal++;
      OVERPASS_CALL_TOTAL++;

      const r = await fetch(ep, {
        method: 'POST',
        headers: {
          'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8',
          'Accept': 'application/json,text/plain,*/*'
        },
        body: new URLSearchParams({ data: query }).toString()
      });
      lastStatus = r.status;
      if (r.ok) return r.json();
      lastText = await r.text();
      if (r.status === 400) {
        console.warn('[Overpass] 400 detected.\n---QUERY START---\n' + query + '\n---QUERY END---\n' +
                     '---RESPONSE START---\n' + lastText + '\n---RESPONSE END---');
      }
    } catch (e) {
      lastText = e.message || String(e);
    }
  }
  throw new Error(`[Overpass] all attempts failed. Last status=${lastStatus}. Snippet=${(lastText||'').slice(0,1200)}`);
}
async function overpassRetry(query) {
  let delay = 800;
  for (let i=0;i<5;i++) {
    try {
      return await overpassQuery(query);
    } catch (e) {
      if (String(e).includes('status=400')) throw e; // 構文系は打ち切り
      await new Promise(res=>setTimeout(res, delay));
      delay = Math.min(6000, Math.round(delay*1.8));
    }
  }
  return await overpassQuery(query);
}

/* ===== POI取得（改良版）：カテゴリ自動拡張＋半径段階拡大＋距離ソート ===== */
async function fetchPoisAround(latRaw, lonRaw, baseRadius, limit) {
  // --- 入力/前処理 ---
  const round6 = v => Math.round(Number(v) * 1e6) / 1e6;
  const lat = round6(latRaw), lon = round6(lonRaw);
  const centerLL = L.latLng(lat, lon);

  const limitN = Math.max(1, Number(limit) || 5);

  // ユーザの3チェックを読む（コンビニ/スーパー/ドラッグ）
  const useConvenience = document.getElementById('chkConvenience')?.checked ?? true;
  const useSuper       = document.getElementById('chkSuper')?.checked ?? true;
  const useDrug        = document.getElementById('chkDrug')?.checked ?? true;

  // まずはユーザ指定カテゴリのみで試す。0件なら休憩に適したカテゴリを自動で追加して再試行
  const PRIMARY_TAGS = [];
  if (useConvenience) PRIMARY_TAGS.push(['shop', 'convenience']);
  if (useSuper)       PRIMARY_TAGS.push(['shop', 'supermarket']);
  if (useDrug) {
    PRIMARY_TAGS.push(['shop','chemist'], ['shop','pharmacy'], ['amenity','pharmacy']);
  }

  // 追加カテゴリ（候補ゼロ時に順次追加）
  const EXTRA_TAGS = [
    ['amenity','cafe'],
    ['amenity','restaurant'],
    ['amenity','fast_food'],
    ['amenity','drinking_water'],
    ['amenity','toilets'],
    ['amenity','shelter'],
    ['amenity','bench'],
    ['amenity','bicycle_repair_station'],
    ['tourism','picnic_site'],
    ['highway','rest_area'],
    // 自販機（飲料）: vending_machine=drinks or amenity=vending_machine + vending=drinks
    ['amenity','vending_machine'],
  ];

  // 段階的に広げる半径（m）。baseRadiusを優先して組み込む
  const radiusSteps = (() => {
    const base = Math.max(100, Number(baseRadius) || 5000); // 初期は小さめから
    const steps = [1000, 2000, 3000, 5000, 8000, 12000, 20000, 30000, 50000, 80000, 100000];
    // base を先頭へ（重複排除）
    const s = [base, ...steps].filter((v, i, a) => a.indexOf(v) === i).sort((a,b)=>a-b);
    return s;
  })();

  // Overpassクエリを作る（node/way両方、out center）
  const buildQuery = (tags, radius) => {
    if (!tags.length) return null;
    // 同一キーの複数値（例: shop=chemist / shop=pharmacy）も繋げて検索
    const clauses = [];
    // tags は [ [k,v], [k,v], ... ]
    // ここで key ごとに v をまとめた正規表現にする
    const grouped = {};
    for (const [k, v] of tags) {
      grouped[k] = grouped[k] || new Set();
      grouped[k].add(v);
    }
    Object.entries(grouped).forEach(([k, set]) => {
      const values = Array.from(set);
      // vending_machine は補助属性 vending=drinks にも対応
      if (k === 'amenity' && values.includes('vending_machine')) {
        clauses.push(`node(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["amenity"="vending_machine"]`);
        clauses.push(`node(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
        clauses.push(`way(around:${radius},${lat},${lon})["vending"~"(drinks|beverages)"]`);
      }
      const re = '(' + values.map(v => v.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|') + ')';
      clauses.push(`node(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
      clauses.push(`way(around:${radius},${lat},${lon})["${k}"~"${re}"]`);
    });

    return `[out:json][timeout:25];
(
  ${clauses.join(';\n  ')};
);
out center;`;
  };

  // 実行→elements→結果整形
  const runOnce = async (tags, radius) => {
    let elements = [];
    const q = buildQuery(tags, radius);
    if (!q) return [];

    try {
      const data = await overpassRetry(q);
      elements = data.elements || [];
    } catch (err) {
      // 400は構文系 → ログして空扱い。他エラーは上位へ投げてもOKだが、ここでは空で継続。
      if (String(err).includes('status=400')) console.warn('[Overpass] 400 with query, continue fallback.');
      else console.warn('[Overpass] error', err);
      elements = [];
    }

    // elements を {name, lat, lon, distFromTriggerM, distKm, dist} に整形（dist は互換用）
    const results = [];
    elements.forEach(e => {
      const ll = e.type === 'node'
        ? [e.lat, e.lon]
        : (e.center ? [e.center.lat, e.center.lon] : null);
      if (!ll) return;
      const name = (e.tags && (e.tags['name:ja'] || e.tags.name || e.tags.brand)) || 'POI';
      const dist = centerLL.distanceTo([ll[0], ll[1]]); // m
      results.push({
        name,
        lat: ll[0],
        lon: ll[1],
        dist,                     // 互換のため残す
        distFromTriggerM: dist,   // 明示名
        distKm: dist / 1000       // 便利フィールド
        });
    });

    // 重複排除（同名＆近接点が多い場合もあるので座標キーで粗く）
    const seen = new Set();
    const uniq = [];
    for (const p of results) {
      const key = `${p.name}|${p.lat.toFixed(5)},${p.lon.toFixed(5)}`;
      if (seen.has(key)) continue;
      seen.add(key);
      uniq.push(p);
    }

    // 距離でソート
    uniq.sort((a,b)=>a.dist-b.dist);
    return uniq;
  };

  // 1) まず「ユーザ指定カテゴリのみ」で半径ステップを回す
  let picked = [];
  for (const r of radiusSteps) {
    const res = await runOnce(PRIMARY_TAGS, r);
    if (res.length >= limitN) {
      picked = res.slice(0, limitN);
      break;
    }
    // 足りない分は仮に確保（次ステップで埋まれば上書きされる）
    if (res.length && !picked.length) picked = res.slice(0, limitN);
  }

  // 2) それでも不足するなら、カテゴリを自動拡張して再試行
  if (picked.length < limitN) {
    const MERGED = PRIMARY_TAGS.slice();
    EXTRA_TAGS.forEach(t => MERGED.push(t));

    for (const r of radiusSteps) {
      const res = await runOnce(MERGED, r);
      if (res.length >= limitN) {
        picked = res.slice(0, limitN);
        break;
      }
      if (res.length && res.length > picked.length) {
        picked = res.slice(0, limitN);
      }
    }
  }

  return picked;
}


/* ===== 小ユーティリティ ===== */
function sanitizeCoord(n, fallback) {
  const v = Number(n);
  if (!isFinite(v)) return Number(fallback);
  return Math.round(v * 1e6) / 1e6;
}

/* ====== 休憩リスト表示更新 ====== */
function updateRestListPanel(){
  const ul = $('restListPanel');
  ul.innerHTML='';
  if (!restList.length){
    ul.innerHTML='<li>休憩地点はありません</li>';
    return;
  }
  restList.forEach((r,i)=>{
    const li=document.createElement('li');
    li.style.padding='4px 0';
    li.innerHTML=`${i+1}. ${r.distance} km地点
      <small>(${r.lat.toFixed(5)}, ${r.lon.toFixed(5)})</small>`;
    ul.appendChild(li);
  });
}

function updateRestPoiPanel(){
  const ol = document.getElementById('restPoiPanel');
  if (!ol) return;
  ol.innerHTML = '';

  // ★ここを追加：UIに出す直前に、全POIへ命名を強制
  restGroups.forEach((g, ti) => {
    (g?.pois || []).forEach((p, pi) => ensurePoiName(p, ti, pi));
  });

  if (!restGroups.length){
    const li = document.createElement('li');
    li.textContent = '休憩トリガーはありません';
    ol.appendChild(li);
    return;
  }

  restGroups.forEach((g, i) => {
    const li = document.createElement('li');
    li.style.margin = '6px 0';

    // 見出し：休憩トリガー#N（km地点 / 緯度経度）
    const km = (g.rest?.routeD ?? 0) / 1000;
    const head = document.createElement('div');
    head.innerHTML = `<b>休憩トリガー＃${i+1}</b>　<span style="color:#666">${km.toFixed(2)} km地点</span>
      <small>(${(g.rest?.lat ?? 0).toFixed(5)}, ${(g.rest?.lon ?? 0).toFixed(5)})</small>`;
    li.appendChild(head);

    // 候補POIのUL
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.margin = '4px 0 0';
    ul.style.padding = '0';

    if (!g.pois?.length){
      const x = document.createElement('li');
      x.textContent = '・（候補なし）';
      ul.appendChild(x);
    } else {
      g.pois.forEach((p) => {
  const it = document.createElement('li');
  it.style.padding = '2px 0';
  const dTrigger = (typeof p.distFromTriggerM === 'number')
    ? ` / トリガー距離 ${formatDist(p.distFromTriggerM)}`
    : '';
  const dPerp = (p._proj && typeof p._proj.perpM === 'number')
    ? ` / ルート⊥ <b>${formatDist(p._proj.perpM)}</b>`
    : '';
  it.innerHTML = `・${p.name}　${p.lat.toFixed(5)}　${p.lon.toFixed(5)}${dTrigger}${dPerp}`;
  ul.appendChild(it);
});
    }

    li.appendChild(ul);
    ol.appendChild(li);
  });
  drawRestBeams();
}
  
// 休憩トリガー ↔ POI を線で結んで可視化する
function drawRestBeams(){
  if (!restBeamLayer) return;

  // いったん前回の線を全部消す
  restBeamLayer.clearLayers();

  if (!Array.isArray(restGroups) || !restGroups.length) return;

  restGroups.forEach(g => {
    const r = g && g.rest;
    if (!r || !Array.isArray(g.pois)) return;

    g.pois.forEach(p => {
      if (!p) return;
      // トリガー → POI を細い破線で引く
      const line = L.polyline(
        [[r.lat, r.lon], [p.lat, p.lon]],
        { weight: 2, dashArray: '4,4', color: '#999' }
      );
      restBeamLayer.addLayer(line);
    });
  });
}

// 組み合わせ表示専用：使用地点だけピンを出す
function setComboMarkers(start, picksArray, goal){
  // 既存ピンをすべて消す
  if (markerLayer) map.removeLayer(markerLayer);
  markerLayer = L.layerGroup().addTo(map);

  // スタート
  if (start) {
    L.marker([start.lat, start.lon], {icon:ICONS.start})
      .bindTooltip(start.name || 'スタート').addTo(markerLayer);
  }

  // 採用POI（順路）
  (picksArray || []).forEach((p, i) => {
    if (!p) return;
    L.marker([p.lat, p.lon], {
      icon: new L.Icon({
        iconUrl: 'https://maps.gstatic.com/mapfiles/ms2/micons/purple-dot.png',
        iconSize:[32,32], iconAnchor:[16,32]
      })
    }).bindTooltip(`${p.name || '休憩'} #${i+1}`).addTo(markerLayer);
  });

  // ゴール
  if (goal) {
    L.marker([goal.lat, goal.lon], {icon:ICONS.goal})
      .bindTooltip(goal.name || 'ゴール').addTo(markerLayer);
  }
}


function showTop3Combos(resultList){
  const box = document.getElementById('comboTop3');
  box.innerHTML = '';
  // 直近の「探索: *」を拾って見出しに表示
const last = [...PERF.rows].reverse().find(r=>String(r.name).startsWith('探索:'));
if(last){
  const note = document.createElement('div');
  note.style.cssText='color:#555;margin-bottom:6px';
  note.innerHTML = `探索時間: <b>${last.ms.toFixed(1)} ms</b> <small>(${last.name})</small>`;
  box.appendChild(note);
}

  if (!resultList.length){
    box.textContent = '候補がありません（休憩トリガーやPOIが不足）';
    return;
  }

  const sd = (a)=>{ if(!a.length) return 0;
    const m=a.reduce((x,y)=>x+y,0)/a.length;
    return Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  };
  const fmt = (n)=>Number(n).toFixed(5);

  resultList.slice(0,3).forEach((r, idx) => {
    const rank = idx+1;

    const wrap = document.createElement('div');
    wrap.style.border='1px solid #ddd';
    wrap.style.borderRadius='8px';
    wrap.style.padding='8px';
    wrap.style.marginBottom='8px';

    const header = document.createElement('div');
    const metric = getScoreMetric();
const sig = {
  dist: sd(r.stats.dist),
  time: sd(r.stats.time),
  energy: sd(r.stats.energy)
};
const metricLabel = (metric === 'time') ? '時間σ'
                  : (metric === 'energy') ? 'エネルギーσ'
                  : '距離σ';
const metricValue = (metric === 'time') ? sig.time
                   : (metric === 'energy') ? sig.energy
                   : sig.dist;

header.innerHTML = `
  <div style="font-weight:700;margin-bottom:4px">
    #${rank}　スコア（${metricLabel}）: ${metricValue.toFixed(3)}
    ${Number.isFinite(r.score)
      ? `<span style="color:#777">（MSE=${Number(r.score).toFixed(3)}）</span>`
      : ''
    }
  </div>
  <div style="margin-top:4px">
    距離σ=${sig.dist.toFixed(2)} km　
    時間σ=${sig.time.toFixed(2)} 分　
    エネルギーσ=${sig.energy.toFixed(2)} kJ
  </div>
`;

    wrap.appendChild(header);

    const list = document.createElement('div');
    list.style.marginTop = '8px';
    list.innerHTML = `<div style="font-weight:600;margin-bottom:4px">採用した休憩地点（トリガーごと）</div>`;
    const ol = document.createElement('ol');
    ol.style.margin = '4px 0 0 1.1rem';
    ol.style.fontSize = '0.92rem';

    (restGroups || []).forEach((g, i) => {
      const li = document.createElement('li');
      const km = ((g?.rest?.routeD || 0) / 1000).toFixed(2);
      const head = document.createElement('div');
      head.innerHTML = `<b>休憩トリガー＃${i+1}</b>　<span style="color:#666">${km} km地点</span>
        <small>(${fmt(g?.rest?.lat||0)}, ${fmt(g?.rest?.lon||0)})</small>`;
      li.appendChild(head);

      const chosen = (r.picksByTrigger && r.picksByTrigger[i]) ? r.picksByTrigger[i] : null;
      const ul = document.createElement('ul');
      ul.style.listStyle='none'; ul.style.margin='4px 0 0'; ul.style.padding='0';

      const row = document.createElement('li');
      row.style.padding='2px 0';

      if (chosen){
        row.style.cursor='pointer';
        const dtxt = (typeof chosen.distFromTriggerM === 'number')
          ? ` / ${formatDist(chosen.distFromTriggerM)}`
            : '';
        row.textContent = `・${chosen.name}　${fmt(chosen.lat)}　${fmt(chosen.lon)}${dtxt}`;
        row.onclick = () => {
          map.flyTo([chosen.lat, chosen.lon], 17);
          L.popup().setLatLng([chosen.lat, chosen.lon]).setContent(chosen.name).openOn(map);
        };
      } else {
  // 候補が一件も無いのか、単にその組み合わせで未採用なのかを判定
  const hasAny = Array.isArray(g?.pois) && g.pois.length > 0;

  // ★デバッグログ追加
  console.log('[showTop3Combos] trigger', i+1,
              'pois=', g?.pois?.length || 0,
              'chosen=', chosen,
              'label=', hasAny ? '未採用' : '候補なし');

  row.textContent = hasAny ? '・（未採用）' : '・（候補なし）';
  row.style.color = '#777';
}

      ul.appendChild(row);
      li.appendChild(ul);
      ol.appendChild(li);
    });

    list.appendChild(ol);
    wrap.appendChild(list);

    const btnWrap = document.createElement('div');
    btnWrap.style.marginTop='8px';
    const btn = document.createElement('button');
    btn.textContent = 'このルートを表示';
    btn.onclick = async () => {
      btn.disabled = true;
      btn.textContent = 'ルート生成中...';
      try {
        let feature = r.feature;
        if (!feature) {
          const start = pts.find(p=>p.type==='start') || pts[0];
          const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
          if (!start || !goal) { alert('スタート/ゴールが見つかりません。'); return; }
          const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
            ? r.picksByTrigger.filter(Boolean)
            : (r.picks || []);
          const wps = [start, ...picksArray, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name || 'POI'}));
          const profile = 'cycling-road';
          const out = await routeLegStatsForWaypoints(wps, profile);
          feature = out.feature;
        }
        if (!feature) { alert('ルートを生成できませんでした。'); return; }

        clearRouteLayers();
        const color = '#00aa88';
        const layer = L.geoJSON(feature, { style:{ color, weight: 7 } }).addTo(map);
        routeLayers['combo#'+rank] = layer;

        const start = pts.find(p=>p.type==='start') || pts[0];
        const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
        const picksArray = (r.picksByTrigger && Array.isArray(r.picksByTrigger))
          ? r.picksByTrigger.filter(Boolean)
          : (r.picks || []);
        setComboMarkers(start, picksArray, goal);

        // （showTop3Combos 内の一部）
const bounds = layer.getBounds?.();
if (bounds && bounds.isValid && bounds.isValid()) {
  map.fitBounds(bounds.pad(0.1));
} else {
  const fallback = (r.picks && r.picks[0]) || pts[0];
  if (fallback) map.flyTo([fallback.lat, fallback.lon], 14);
}

        setActiveButton(null);
      } catch (e){
  console.error(e);
  const hints = [
    !ORS_KEY ? 'ORS_KEY が未設定' : null,
    !(pts && pts.length>=2) ? 'Start/Goal が不正' : null,
    !routeData.fastest ? '最速ルート未生成（先に「休憩場所検索」を実行）' : null
  ].filter(Boolean).join(' / ');
  alert('ルート描画でエラー: ' + (e.message || e) + (hints ? '\nヒント: ' + hints : ''));
} finally {
        btn.disabled = false;
        btn.textContent = 'このルートを表示';
      }
    };
    btnWrap.appendChild(btn);
    wrap.appendChild(btnWrap);

    box.appendChild(wrap);
  });
}

// 1レグのMSE（距離・時間・エネルギー）
// function legMseCost(d, t, e, ideald, idealt, ideale){
//   const dd = d - ideald;
//   const tt = t - idealt;
//   const ee = e - ideale;
//   return dd*dd + tt*tt + ee*ee;
// }
  function legMseCost(d, t, e, ideald, idealt, ideale){
  const ee = e - ideale;
  return ee*ee;
}


// stats({dist[], time[], energy[]}) からルート全体のMSEスコアを計算
function routeMseScoreFromStats(stats, idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg){
  const dArr = stats?.dist   || [];
  const tArr = stats?.time   || [];
  const eArr = stats?.energy || [];

  const n = Math.min(dArr.length, tArr.length, eArr.length);
  if (!n) return NaN; // ← ここがポイント：直線距離など「time/energyなし」は MSE 計算不可

  let sum = 0;
  for (let i = 0; i < n; i++){
    sum += legMseCost(
      dArr[i],
      tArr[i],
      eArr[i],
      idealDistPerLeg,
      idealTimePerLeg,
      idealEnergyPerLeg
    );
  }
  return sum; // 小さいほど「理想ペースに近い」
}


/* ===== スコアリング（POI評価） ===== */
// ローカルストレージから復元（無ければデフォルト）
let SCORE_WEIGHTS = (()=>{
  try{
    const raw = localStorage.getItem('route_score_weights');
    if(!raw) return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
    const obj = JSON.parse(raw);
    // 不足キーは補完
    return {
      wAlign: Number.isFinite(obj?.wAlign) ? obj.wAlign : 1.0,
      wPerp:  Number.isFinite(obj?.wPerp)  ? obj.wPerp  : 1.0,
      wTrig:  Number.isFinite(obj?.wTrig)  ? obj.wTrig  : 0.5,
    };
  }catch(e){
    return { wAlign:1.0, wPerp:1.0, wTrig:0.5 };
  }
})();

function getScoreMetric(){
  const sel = document.getElementById('scoreMetricSelect');
  return sel ? sel.value : SCORE_METRIC;
}
function setScoreMetric(v){
  SCORE_METRIC = v;
  localStorage.setItem('route_score_metric', v);
}


function targetCumDForIndex(i, R, totalD){
  if (!Number.isFinite(totalD) || totalD<=0) return 0;
  return totalD * (i + 1) / (R + 1);
}

function nodeCost(p, targetCumD){
  if (!p) return 1e9;
  const perpM   = Number(p?._proj?.perpM) ?? 0;
  const trigM   = Number(p?.distFromTriggerM) ?? 0;
  const alignM  = Math.abs((Number(p?._proj?.cumD) ?? targetCumD) - targetCumD);
return (SCORE_WEIGHTS.wAlign * (alignM/1000)) +
       (SCORE_WEIGHTS.wPerp  * (perpM/1000))  +
       (SCORE_WEIGHTS.wTrig  * (trigM/1000));
}


/* ===== 組み合わせルート探索＆評価ユーティリティ ===== */

/* ===== 直線距離: 全組み合わせ（各トリガーで1件） ===== */

// スタート/ゴール取得（保険つき）
function getStartGoalPoints(){
  const start = pts.find(p=>p.type==='start') || pts[0];
  const goal  = pts.find(p=>p.type==='goal')  || pts[pts.length-1];
  if(!start || !goal) throw new Error('スタート/ゴールが見つかりません');
  return {start, goal};
}

// POI群（各トリガー）から「最大5件だけ」取り出す（射影が無くてもOK）
function topPoisPerTriggerForLinear(maxPer=5){
  if(!Array.isArray(restGroups) || !restGroups.length) throw new Error('休憩トリガーがありません');
  // とりあえず「トリガーからの距離 + ルート直交距離」の小さい順で切り出し（無ければある情報だけ）
  return restGroups.map((g,i)=>{
    const arr = (g?.pois || []).slice();
    // 「候補なし」のトリガーがあると組み合わせが成立しないので、ここで弾く
    if(!arr.length) throw new Error(`トリガー#${i+1} に候補POIがありません`);
    const score = p=>{
      const a = Number(p?.distFromTriggerM) || 0;
      const b = Number(p?._proj?.perpM) || 0;
      return a + b;
    };
    arr.sort((x,y)=> score(x)-score(y));
    return arr.slice(0, Math.max(1, Math.min(maxPer, arr.length)));
  });
}



// 2点間の地上距離（m）
function llDist(a,b){
  return L.latLng(a.lat, a.lon).distanceTo([b.lat, b.lon]);
}

// ある組み合わせ（picks: 各トリガーで1件）に対し、
// start -> picks[0] -> picks[1] -> ... -> goal の直線合計距離（m）を返す
function comboLinearDistanceMeters(start, picks, goal){
  let sum = 0;
  let prev = start;
  for(const p of picks){
    sum += llDist(prev, p);
    prev = p;
  }
  sum += llDist(prev, goal);
  return sum;
}

// 全組み合わせを列挙（各トリガー1件必ず選ぶ）
function enumerateAllOnePerTrigger(groups, hardCap=200000){
  // groups は [ [p,p,p...], [p,p...], ... ]
  const out = [];
  const idx = new Array(groups.length).fill(0);
  const lens = groups.map(g=>g.length);
  let total = lens.reduce((a,b)=>a*b,1);
  if(total>hardCap) total = hardCap; // 爆発防止

  for(let n=0; n<total; n++){
    // 現在の選択を push
    out.push(groups.map((g,i)=> g[idx[i]]));
    // 次の組み合わせへ
    for(let i=groups.length-1;i>=0;i--){
      idx[i]++;
      if(idx[i] < lens[i]) break;
      idx[i]=0;
      if(i===0) return out; // 全探索完了
    }
  }
  return out;
}

// 直線距離アルゴリズム用に、全組合せを「行オブジェクト」に変換して返すヘルパー
function buildLinearAlgoRows(start, goal, groups, hardCap = 200000) {
  const combos = enumerateAllOnePerTrigger(groups, hardCap);

  const rows = combos.map(picks => {
    const meters = comboLinearDistanceMeters(start, picks, goal);
    const km = meters / 1000;

    const idxes = picks.map((p, gi) => {
      const idx = groups[gi].indexOf(p);
      return idx >= 0 ? idx : null;
    });

    return {
      score: km,
      rawScore: meters,
      stats: {
        dist: [km],
        time: [],
        energy: []
      },
      picks,
      picksByTrigger: picks,
      km,
      idxes
    };
  });

  rows.sort((a, b) => (a.score ?? Infinity) - (b.score ?? Infinity));
  return rows;
}

async function calcLegCostWithApi(from, to, profile){
  if (!from || !to) throw new Error('calcLegCostWithApi: from/to が不正です');

  const wps = [
    { lat: from.lat ?? from.latitude ?? from.y, lon: from.lon ?? from.lng ?? from.longitude ?? from.x },
    { lat: to.lat   ?? to.latitude   ?? to.y, lon: to.lon   ?? to.lng ?? to.longitude   ?? to.x }
  ];

  const out = await routeLegStatsForWaypoints(wps, profile);
  const summary = out?.feature?.properties?.summary || {};

  const distKm  = (Number(summary.distance) || 0) / 1000;
  const timeMin = (Number(summary.duration) || 0) / 60;

  // ★ 2点でも energy 配列が複数要素/0要素になる可能性があるので sum を基本にする
  let energyKj = sumNums(out?.stats?.energy);

  // ★ dp を壊さない：NaNやInfinityは0に倒す（または距離から近似でもOK）
  if (!Number.isFinite(energyKj)) energyKj = 0;

  return { total: distKm, distKm, timeMin, energyKj };
}

// Viterbi（API利用版）
// start, goal: {lat, lon} 形式
// restGroups: [ [POI, POI, ...], [POI, ...], ... ] 各トリガーごとの候補POI
// profile: 'cycling-road' など
async function runViterbiOnce_API(start, goal, restGroups, profile) {

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!Number.isInteger(T) || T <= 0) {
    console.warn('[Viterbi] restGroups が空 / 不正です:', restGroups);
    return [];
  }

  const ideals = getIdealPerLegs();
  const idealDistPerLeg   = ideals.idealDistPerLeg;
  const idealTimePerLeg   = ideals.idealTimePerLeg;
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => !Number.isInteger(k) || k <= 0)) {
    console.warn('[Viterbi] 候補0件のトリガーがあります:', Klist);
    return [];
  }

  const dp   = [];
  const prev = [];
  for (let t = 0; t < T; t++) {
    dp[t]   = new Array(Klist[t]).fill(Infinity);
    prev[t] = new Array(Klist[t]).fill(-1);
  }

    // start → 最初のトリガー
  for (let k = 0; k < Klist[0]; k++) {
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);

    const mse = legMseCost(
      leg.distKm,
      leg.timeMin,
      leg.energyKj,
      idealDistPerLeg,
      idealTimePerLeg,
      idealEnergyPerLeg
    );
    dp[0][k] = mse;
  }

    // t-1 → t
  for (let t = 1; t < T; t++) {
    const curGroup  = restGroups[t];
    const prevGroup = restGroups[t - 1];

    for (let j = 0; j < Klist[t]; j++) {
      const toPoi = curGroup[j];

      let bestCost = Infinity;
      let bestIdx  = -1;

      for (let i = 0; i < Klist[t - 1]; i++) {
        const fromPoi = prevGroup[i];
        if (!Number.isFinite(dp[t - 1][i])) continue;

        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);

        const mse = legMseCost(
          leg.distKm,
          leg.timeMin,
          leg.energyKj,
          idealDistPerLeg,
          idealTimePerLeg,
          idealEnergyPerLeg
        );

        const cand = dp[t - 1][i] + mse;

        if (cand < bestCost) {
          bestCost = cand;
          bestIdx  = i;
        }
      }

      dp[t][j]   = bestCost;
      prev[t][j] = bestIdx;
    }
  }

    // 最後のトリガー → goal
  const lastT = T - 1;
  let bestFinalCost = Infinity;
  let bestFinalIdx  = -1;

  for (let k = 0; k < Klist[lastT]; k++) {
    if (!Number.isFinite(dp[lastT][k])) continue;

    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApi(poi, goal, profile);

    const mse = legMseCost(
      leg.distKm,
      leg.timeMin,
      leg.energyKj,
      idealDistPerLeg,
      idealTimePerLeg,
      idealEnergyPerLeg
    );

    const cand = dp[lastT][k] + mse;

    if (cand < bestFinalCost) {
      bestFinalCost = cand;
      bestFinalIdx  = k;
    }
  }

   if (bestFinalIdx < 0 || !Number.isFinite(bestFinalCost)) {
    console.warn('[Viterbi] ゴールまで到達するルートが見つかりませんでした');
    return [];
  }

  // 経路復元
  const picks = new Array(T);
  let curIdx  = bestFinalIdx;

  for (let t = lastT; t >= 0; t--) {
    picks[t] = restGroups[t][curIdx];
    curIdx   = prev[t][curIdx];

    if (t > 0 && curIdx < 0) {
      console.warn('[Viterbi] prev の辻褄が合いません t=', t);
      break;
    }
  }

  // ★ ルート全体の stats を1回だけ計算（σ表示やCSV用）
let feature = null;
let stats   = { dist:[], time:[], energy:[] };
let finalScore = bestFinalCost; // ← フォールバック（stats取れない時）

try {
  const wps = [start, ...picks, goal].map(p => ({
    lat: p.lat,
    lon: p.lon,
    name: p.name || 'POI'
  }));

  const out = await routeLegStatsForWaypoints(wps, profile);
  feature = out?.feature || null;
  if (out?.stats) stats = out.stats;

  // // ★ここが本命：総当たりと同じ「総量MSE」を最終スコアにする
  // const exactMse = routeMseScoreFromStats(
  //   stats,
  //   idealDistPerLeg,
  //   idealTimePerLeg,
  //   idealEnergyPerLeg
  // );
  // if (Number.isFinite(exactMse)) finalScore = exactMse;
const exact = finalScoreFromStats(stats, { idealEnergyPerLeg });
if (Number.isFinite(exact)) finalScore = exact;

} catch (e) {
  console.warn('[Viterbi] 統計計算用ルート生成に失敗', e);
}

return [{
  score:    finalScore,     // ★総当たりと同じ土俵のスコア
  rawScore: bestFinalCost,  // ★DPで積んだ近似（比較・デバッグ用に残す）
  feature,
  stats,
  picks,
  picksByTrigger: picks
}];
}

// 表示とCSV出力
function renderLinearResults(rows){
  const cont = document.getElementById('linearList');
  const sum  = document.getElementById('linearSummary');
  if(!cont || !sum) return;

  // --- 上位3件のみ表示 ---
  const SHOW = CFG.ui.showTop;
  const shown = rows.slice(0, SHOW);

  // CSV全件は保持（UIは3件）
  window.__linear_rows_for_csv = rows;
  const csvBtn = document.getElementById('btnDownloadLinearCsv');
  if(csvBtn) csvBtn.disabled = rows.length===0;

  cont.innerHTML = ''; // カード表示に変更
  shown.forEach((r, i) => {
    const rank = i + 1;
    const names = r.picks.map(p=> p?.name || 'POI').join(' → ');

    const wrap = document.createElement('div');
    wrap.style.border = '1px solid #ddd';
    wrap.style.borderRadius = '8px';
    wrap.style.padding = '8px';
    wrap.style.marginBottom = '8px';
    wrap.style.fontFamily = 'system-ui,ui-sans-serif';

    const head = document.createElement('div');
    head.style.fontWeight = '700';
    head.style.marginBottom = '4px';
    head.textContent = `#${rank}  合計直線距離: ${r.km.toFixed(2)} km`;
    wrap.appendChild(head);

    const meta = document.createElement('div');
    meta.style.color = '#555';
    meta.style.fontSize = '0.92rem';
    meta.textContent = `idx=${JSON.stringify(r.idxes)} | ${names}`;
    wrap.appendChild(meta);

    const btnRow = document.createElement('div');
    btnRow.style.marginTop = '6px';

    const btn = document.createElement('button');
    btn.textContent = 'この組み合わせでルート表示';
    btn.onclick = async () => {
      btn.disabled = true;
      const oldTxt = btn.textContent;
      btn.textContent = '生成中…';
      try {
        await showLinearComboRoute(r);   // ← 下の新関数で描画
      } catch (e) {
        const hints = [
          !ORS_KEY ? 'ORS_KEY 未設定' : null,
          !(pts && pts.length>=2) ? 'Start/Goal 未設定' : null
        ].filter(Boolean).join(' / ');
        alert('ルート描画に失敗: ' + (e.message || e) + (hints ? '\nヒント: ' + hints : ''));
        console.error(e);
      } finally {
        btn.disabled = false;
        btn.textContent = oldTxt;
      }
    };
    btnRow.appendChild(btn);
    wrap.appendChild(btnRow);

    cont.appendChild(wrap);
  });

  const msg = `総組合せ数: ${rows.length.toLocaleString()} 件（上位 ${Math.min(SHOW, rows.length)} 件を表示／CSVは全件出力可能）`;
  sum.textContent = msg;
}

function downloadLinearCsv(){
  const rows = window.__linear_rows_for_csv || [];
  if (!rows.length) return;

  const header = ['rank','total_km','indices_per_trigger','poi_names'];

  const bodyRows = rows.map((r, i)=>{
    const names = r.picks.map(p=> (p?.name ?? 'POI')).join(' -> ');
    return [
      String(i+1),
      r.km.toFixed(3),
      `"${csvEscape(JSON.stringify(r.idxes))}"`,
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'linear_combinations.csv');
}

// ボタン動作：計算 → 並べ替え → 表示
function bindLinearButtonsOnce(){
  const calcBtn = document.getElementById('btnCalcLinear');
  const csvBtn  = document.getElementById('btnDownloadLinearCsv');
  if(!calcBtn) return;
  if(calcBtn.__bound) return; // 二重バインド防止
  calcBtn.__bound = true;

  calcBtn.onclick = ()=>{
    try{
      const {start, goal} = getStartGoalPoints();
      const groups = makeCandGroupsFromRestGroups(restGroups, CFG.linear.candPerTrigger, defaultLinearSorter);
      // 総組合せチェック（多すぎる場合は注意だけ出す）
      const total = groups.reduce((a,b)=>a*b.length,1);
      const hardCap = CFG.linear.hardCap;

if(total > hardCap){
  if(!confirm(`組合せが ${total.toLocaleString()} 件あります。上限${hardCap.toLocaleString()}件まで計算します。続行しますか？`)) return;
}
const combos = enumerateAllOnePerTrigger(groups, hardCap);

      // 距離計算
      const rows = combos.map(idxPicks=>{
        const meters = comboLinearDistanceMeters(start, idxPicks, goal);
        return {
          meters,
          km: meters/1000,
          picks: idxPicks,
          idxes: idxPicks.map((p, i)=> groups[i].indexOf(p)) // どのインデックスを選んだか
        };
      });

      // 合計距離が短い順にソート
      rows.sort((a,b)=>a.meters - b.meters);

      renderLinearResults(rows);
    }catch(e){
      alert('直線距離計算エラー: ' + (e.message || e));
      console.error(e);
    }
  };

  if(csvBtn){
    csvBtn.onclick = ()=> downloadLinearCsv();
  }
}

// 初期化時にバインド
//window.addEventListener('DOMContentLoaded', bindLinearButtonsOnce);


// 休憩トリガーごとに1地点ずつ選ぶ全組み合わせを列挙（上限あり）
function enumerateCombinations(poiGroups, perGroupLimit = 3){
  const groups = poiGroups.map(arr => (arr || []).slice(0, perGroupLimit));
  const combos = [];

  function dfs(i, acc){
    if (i === groups.length){
      combos.push(acc.slice());
      return;
    }
    const g = groups[i];
    if (!g.length){
      acc.push(null);
      dfs(i+1, acc);
      acc.pop();
      return;
    }
    for (const p of g){
      acc.push(p);
      dfs(i+1, acc);
      acc.pop();
    }
  }

  dfs(0, []);
  return combos;
}

// 組み合わせルートのレグ統計を取得（ORS呼び出し）
async function routeLegStatsForWaypoints(wps, profile){
  const body = { coordinates: wps.map(p=>[p.lon,p.lat]), elevation:true, extra_info:['steepness'], preference:'fastest' };
  const feature = (await dir(body, profile)).features[0];
  const mass=75, flat=18;
  const stats = await calcLegStats(feature, mass, flat);
  return { feature, stats };
}

// ルートの累積距離[m]/時間[s]/エネルギー[kJ]を構築
function buildCums(feature, mass=75, flat=18){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length>=3;
  const segs   = feature.properties.segments||[];
  const cum = { D:[0], T:[0], E:[0] };
  for(const s of segs){
    for(const st of (s.steps||[])){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, t=st.duration||0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cum.D.push(cum.D.at(-1)+d);
      cum.T.push(cum.T.at(-1)+t);
      cum.E.push(cum.E.at(-1)+dE);
    }
  }
  return {cum, coords};
}

// POIをルート折れ線へ射影し、その地点の累積値を内挿で取得
function projectToRoute(lat,lon, coords, cum){
  let best={i0:0,i1:1,frac:0,dist:Infinity, stepIdx:1};
  let stepIdx=1;
  for(let i=1;i<coords.length;i++, stepIdx++){
    const A=L.latLng(coords[i-1][1],coords[i-1][0]);
    const B=L.latLng(coords[i][1],  coords[i][0]);
    const P=L.latLng(lat,lon);
    const AB=[B.lat-A.lat, B.lng-A.lng];
    const AP=[P.lat-A.lat, P.lng-A.lng];
    const ab2=AB[0]*AB[0]+AB[1]*AB[1]||1e-12;
    let t=(AP[0]*AB[0]+AP[1]*AB[1])/ab2; t=Math.max(0,Math.min(1,t));
    const Q=L.latLng(A.lat+AB[0]*t, A.lng+AB[1]*t);
    const d=P.distanceTo(Q);
    if(d<best.dist){ best={i0:i-1,i1:i,frac:t,dist:d, stepIdx:i}; }
  }
  const i = best.stepIdx;
  const lerp=(arr)=>{ const v0=arr[i-1], v1=arr[i]??v0; return v0 + (v1-v0)*best.frac; };
  return { cumD:lerp(cum.D), cumT:lerp(cum.T), cumE:lerp(cum.E), perpM: best.dist };
}

/* ===== 共通ユーティリティ：候補検査＆未採用の強制補修 ===== */

// i番目トリガーに有効候補(_proj.cumDが有限)があるか？
function hasValidCand(restGroups, i){
  const g = restGroups[i];
  if (!g) return false;
  const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
  return valid.length > 0;
}

// 未採用(null)を残さないための補修：
// 候補があるトリガーでは、等間隔ターゲットに最も近い候補で穴埋めする
function repairNullPicks(restGroups, cumTotals, picks){
  const R = restGroups.length;
  const totalD = Number(cumTotals?.D) || 0;
  if (!R || !Number.isFinite(totalD) || totalD <= 0) return picks;

  const out = picks.slice();
  for (let i = 0; i < R; i++){
    if (out[i]) continue;                        // 既に採用済み
    if (!hasValidCand(restGroups, i)) continue;  // 物理的に候補なしならスキップ

    const g = restGroups[i];
    const target = totalD * (i + 1) / (R + 1);
    const valid = (g.pois || []).filter(p => p && p._proj && Number.isFinite(p._proj.cumD));
    if (!valid.length) continue;

    valid.sort((a,b)=>Math.abs(a._proj.cumD - target) - Math.abs(b._proj.cumD - target));
    out[i] = valid[0];
  }
  return out;
}

// ビームサーチを1回実行して結果配列を返す（UIにはまだ表示しない）
function runBeamSearchOnce(restGroups, cumTotals) {
  const triggersWithCand = (restGroups || []).reduce((n, g) => {
    const valid = (g?.pois || []).filter(
      p => p && p._proj && Number.isFinite(p._proj.cumD)
    );
    return n + (valid.length ? 1 : 0);
  }, 0);

  const top = beamSearch(
    restGroups,
    cumTotals,
    /*width*/ 3,
    /*minRest*/ triggersWithCand,
    /*nullPenalty*/ 1e6,
    /*forbidNullWhenCand*/ true
  );

  // 表示用に picks/picksByTrigger を整形して返す
  return top.map(t => ({
    score: t.score,
    stats: t.stats,
    picksByTrigger: t.picksByTrigger,
    picks: t.picksByTrigger.filter(Boolean)
  }));
}

async function viterbiRouteCost(p1, p2, profile){
  const coords = [[p1.lon,p1.lat], [p2.lon,p2.lat]];
  const res = await orsDirections(coords, profile);

  const dist = res.features[0].properties.summary.distance;
  const time = res.features[0].properties.summary.duration;
  const elev = res.features[0].properties.ascent;  // 標高差

  const energy = energyFromRoute(res); // kJ計算

  return { dist, time, energy };
}

// ▼▼ 総当たりを1回分だけ実行して全結果を返す関数 ▼▼
async function runBruteforceOnce(start, goal, restGroups, profile){
  // 休憩トリガーごとの POI を取得（poiLimit まで）
  const perGroupLimit = Math.max(1, Number($('poiLimit').value) || 5);
  const poiGroups = restGroups.map(g => Array.isArray(g.pois) ? g.pois : []);

  // POI を perGroupLimit で頭から切り出して、総当たり用のグループに変換
  const combos = enumerateCombinations(poiGroups, perGroupLimit);
  if (!combos.length){
    throw new Error('組み合わせ候補が作れませんでした。');
  }

   const ideals = getIdealPerLegs();
  const idealDistPerLeg   = ideals.idealDistPerLeg;
  const idealTimePerLeg   = ideals.idealTimePerLeg;
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;
  const T = Array.isArray(restGroups) ? restGroups.length : 0;

  const results = [];
  let okCount = 0;
  let failCount = 0;

  for (const cmb of combos){
    // cmb は 「トリガーごとの選択（null 含む）」配列
    const picks = cmb.filter(Boolean); // null は除外して実際の経由地だけにする

    // ORS に渡すウェイポイント列（start → picks... → goal）
    const wps = [start, ...picks, goal].map(p => ({
      lat: p.lat,
      lon: p.lon,
      name: p.name || 'POI'
    }));

    try {
      const {feature, stats} = await routeLegStatsForWaypoints(wps, profile);

      // // ★ 追加：Viterbi と同じ MSE スコアで評価
      // const mseScore = routeMseScoreFromStats(
      //   stats,
      //   idealDistPerLeg,
      //   idealTimePerLeg,
      //   idealEnergyPerLeg
      // );

      // // ※ ここでは _w による補正はせず、そのままMSEのみで比較する
      // const score    = mseScore;
      // const rawScore = mseScore;

      const eScore = routeEnergyMseFromStats(stats, idealEnergyPerLeg);
const score    = eScore;
const rawScore = eScore;


      results.push({
        score,           // MSEスコア（小さいほど「理想ペースに近い」）
        rawScore,        // 今は score と同じ（CSVなどで使いやすいよう一応残す）
        feature,         // ORS の GeoJSON Feature
        picks,           // 実際に経由した POI の配列
        picksByTrigger: cmb, // トリガーごとの採用状況（null を含み得る）
        stats            // {dist:[], time:[], energy:[]} 区間ごとの値
      });
      okCount++;
    } catch (e){
      console.warn('runBruteforceOnce: combo route fail', e);
      failCount++;
    }
  }

  // スコア昇順に並べ替え
  results.sort((a,b)=>a.score - b.score);

  console.log(
    '[runBruteforceOnce] ok=', okCount,
    ' fail=', failCount,
    ' results=', results.length
  );

  return results;
}

// ======================================================
// アルゴリズム比較デバッグ本体
//   - ビームサーチ（ゼロAPI）
//   - 総当たり（API多め）
//   - 直線距離（全組合せ・ゼロAPI）
//   - Viterbi（API利用・DP）
//   - 対策A: Viterbi TopK → 総量MSEで再ランキング（API）
//   - 対策B: Viterbi（L1加法・API）
// ======================================================
// ======================================================
// アルゴリズム比較デバッグ本体（ON/OFF切替対応）
// ======================================================
async function runAlgoCompareDebug(){
  const panel = $('algoComparePanel');
  panel.textContent = '';

  const tAll0 = performance.now();
  window.__algoCompareRows = [];

  try {
    if (!routeData || !routeData.fastest) {
      panel.textContent = '先に「休憩場所検索」でルート＋POIを生成してください。';
      return;
    }
    if (!restGroups || !restGroups.length) {
      panel.textContent = '休憩トリガーがありません。';
      return;
    }

    ensureProjections();
    const cumTotals = window.__cumTotals;

    const ui = readUI();
    const profile = ui.profile;

    // ★ここ追加：poiLimitを「一度だけ」確定（以後これだけを使う）
    const capPerTrigger = Math.max(
      1,
      Number.isFinite(Number(ui.poiLimit)) ? Math.floor(Number(ui.poiLimit)) : (CFG.viterbi.capPerTriggerDefault ?? 5)
    );

    const start = pts.find(p => p.type === 'start') || pts[0];
    const goal  = pts.find(p => p.type === 'goal')  || pts[pts.length - 1];

    panel.textContent += '====== アルゴリズム比較デバッグ ======\n\n';

    // bf_rank 用
    let bfList = [];
    let bfRankMap = null;

    // ----------------------------------------------------------
    // 1）総当たり（API多め・高精度） => bfRankMap を作る
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_bf')) {
      panel.textContent += '\n--- 総当たり（API多め・高精度） ---\n';
      {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        bfList = await runBruteforceOnce(start, goal, restGroups, profile);
        const t1 = performance.now();

        const ms = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORS呼び出し: ${ors} 回\n`;
        panel.textContent += `Overpass呼び出し: ${ov} 回\n`;
        panel.textContent += `組合せ数: ${bfList.length} 件\n\n`;

        bfRankMap = buildBfRankMap(bfList);
        attachBfRank(bfList, bfRankMap);

        showAlgoListInPanel(panel, bfList, 'bruteforce');
        pushAlgoResultsForCsv('bruteforce','総当たり',bfList,ms,ors,ov);
      }
    } else {
      panel.textContent += '\n--- 総当たり：OFF（bf_rank未計算） ---\n';
    }

    // ----------------------------------------------------------
    // 2）ビームサーチ（ゼロAPI）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_beam')) {
      panel.textContent += '\n--- ビームサーチ（幅3・ゼロAPI） ---\n';
      {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        const beamList = runBeamSearchOnce(restGroups, cumTotals);
        const t1 = performance.now();

        const ms = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        attachBfRank(beamList, bfRankMap);

        panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORS呼び出し: ${ors} 回\n`;
        panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

        showAlgoListInPanel(panel, beamList, 'beam3');
        pushAlgoResultsForCsv('beam3','ビームサーチ（幅3）',beamList.slice(0,3),ms,ors,ov);
      }
    }

    // ----------------------------------------------------------
    // 3）直線距離（全組合せ・ゼロAPI）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_linear')) {
      panel.textContent += '\n--- 直線距離（全組み合わせ・ゼロAPI） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        const groups = topPoisPerTriggerForLinear(CFG.linear.candPerTrigger);

        if (!groups || !groups.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          const linearRows = buildLinearAlgoRows(start, goal, groups);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          window.__linearResults = linearRows;

          attachBfRank(linearRows, bfRankMap);

          panel.textContent += `組合せ数: ${linearRows.length} 件\n`;
          panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORS呼び出し: ${ors} 回\n`;
          panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

          const SHOW = CFG.ui.showTop;
          showAlgoListInPanel(panel, linearRows.slice(0, SHOW), 'linear');
          pushAlgoResultsForCsv('linear','直線距離（全組合せ）',linearRows,ms,ors,ov);
        }
      } catch (e) {
        console.error('[linear] error', e);
        panel.textContent += '\n[直線距離計算エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 4）Viterbi（API利用・DP：MSEのみ）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_vit')) {
      panel.textContent += '\n--- Viterbi（API利用・DP：MSEのみ） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        // ★統一：capPerTrigger を冒頭の値で固定
        const vitGroups = makeCandGroupsFromRestGroups(restGroups, capPerTrigger);

        if (!vitGroups || !vitGroups.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          const t0 = performance.now();
          const vitList = await runViterbiOnce_API(start, goal, vitGroups, profile);
          const t1 = performance.now();

          const ms  = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!vitList || !vitList.length) {
            panel.textContent += '(候補なし)\n';
          } else {
            attachBfRank(vitList, bfRankMap);

            panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORS呼び出し: ${ors} 回\n`;
            panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

            showAlgoListInPanel(panel, vitList, 'viterbi');
            pushAlgoResultsForCsv('viterbi','Viterbi（API・DP：MSEのみ）',vitList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi] error', e);
        panel.textContent += '\n[viterbi エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 5）対策A：TopK増 + beamWidth増（再ランキング）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_A')) {
      panel.textContent += '\n--- 対策A：Viterbi TopK→総量MSE再ランキング（API） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const groupsA = makeCandGroupsFromRestGroups(restGroups, capPerTrigger, defaultLinearSorter);
        if (!groupsA || !groupsA.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          const t0 = performance.now();
          const aOpt  = getAbViterbiOpt(ui);
          const aList = await runViterbiTopK_Rerank_All_API(start, goal, groupsA, profile, aOpt);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!aList || !aList.length) {
            panel.textContent += '(候補なし)\n';
          } else {
            attachBfRank(aList, bfRankMap);

            panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORS呼び出し: ${ors} 回\n`;
            panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

            showAlgoListInPanel(panel, aList.slice(0,3), 'viterbi_topk_rerank');
            pushAlgoResultsForCsv(
              'viterbi_topk_rerank',
              '対策A：Viterbi TopK→総量MSE再ランキング',
              aList, ms, ors, ov
            );
          }
        }
      } catch (e) {
        console.error('[viterbi_topk_rerank] error', e);
        panel.textContent += '\n[対策A エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 6）対策B：A + 重複排除（再ランキング）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_B')) {
      panel.textContent += '\n--- 対策B：Viterbi（L1加法・API） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const groupsB = makeCandGroupsFromRestGroups(restGroups, capPerTrigger, defaultLinearSorter);

        if (!groupsB || !groupsB.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          const t0 = performance.now();
          const bOpt  = getAbViterbiOpt(ui);
          const bList = await runViterbiTopK_Rerank_All_API_Dedupe(start, goal, groupsB, profile, bOpt);
          const t1 = performance.now();

          const ms = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!bList || !bList.length) {
            panel.textContent += '(候補なし)\n';
          } else {
            attachBfRank(bList, bfRankMap);

            panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORS呼び出し: ${ors} 回\n`;
            panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

            showAlgoListInPanel(panel, bList.slice(0,3), 'viterbi_l1');
            pushAlgoResultsForCsv('viterbi_l1','対策B：Viterbi（L1加法）',bList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi_l1] error', e);
        panel.textContent += '\n[対策B エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 7）対策C
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_C')) {
      panel.textContent += '\n--- 対策C：Viterbi（端除外 + 端トリガー条件経由） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        // ★修正：ここで poiLimit を読み直さない。冒頭の capPerTrigger を使う
        const groupsC = makeCandGroupsFromRestGroups(restGroups, capPerTrigger)
          .map(g => Array.isArray(g) ? g.filter(Boolean) : [])
          .filter(g => g.length > 0);

        if (!groupsC || !groupsC.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          const t0 = performance.now();

          const cList = await runViterbiOnce_API_C_BeamFull(start, goal, groupsC, profile, {
            beamWidth: CFG.viterbi.beamZeroApiWidth
          });

          const t1 = performance.now();
          const ms  = t1 - t0;
          const ors = API_USED.orsTotal - orsBefore;
          const ov  = API_USED.overpassTotal - ovpBefore;

          if (!cList || !cList.length) {
            panel.textContent += '(候補なし)\n';
          } else {
            attachBfRank(cList, bfRankMap);

            panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
            panel.textContent += `ORS呼び出し: ${ors} 回\n`;
            panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

            showAlgoListInPanel(panel, cList, 'viterbi_c');
            pushAlgoResultsForCsv('viterbi_c','対策C：端除外Viterbi + 端トリガー条件経由',cList,ms,ors,ov);
          }
        }
      } catch (e) {
        console.error('[viterbi_c] error', e);
        panel.textContent += '\n[対策C エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 8）対策D：段階的に固定解除してViterbi
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_D')) {
      panel.textContent += '\n--- 対策D：段階的に固定解除してViterbi ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        const t0 = performance.now();
        const prog = await runViterbi_D_Progressive(start, goal, restGroups, profile, {
          capPerTrigger, // ★OK：冒頭の値を渡す
          sorter: defaultLinearSorter
        });
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        const last = prog[prog.length - 1]?.best ? [prog[prog.length - 1].best] : [];

        panel.textContent += `段階数: ${prog.length}\n`;
        panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
        panel.textContent += `ORS呼び出し: ${ors} 回\n`;
        panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

        if (last.length){
          attachBfRank(last, bfRankMap);

          showAlgoListInPanel(panel, last, 'viterbi_D_prog');
          pushAlgoResultsForCsv('viterbi_D_prog','対策D：段階的固定解除Viterbi', last, ms, ors, ov);
        } else {
          panel.textContent += '(候補なし)\n';
        }

      } catch (e) {
        console.error('[viterbi_D_prog] error', e);
        panel.textContent += '\n[対策D エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 9）対策E：Viterbi（2点DP）+区間キャッシュ
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_E')) {
      panel.textContent += '\n--- 対策E：Viterbi（2点DP + 区間キャッシュ） ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        if (window.__legCache && typeof window.__legCache.clear === 'function'){
          window.__legCache.clear();
        } else if (typeof __legCache !== 'undefined' && __legCache?.clear){
          __legCache.clear();
        }

        // ★修正：ここで poiLimit を読み直さない。冒頭の capPerTrigger を使う
        const groupsE = makeCandGroupsFromRestGroups(restGroups, capPerTrigger);

        const t0 = performance.now();
        const eList = await runViterbiOnce_API_E_Cached(start, goal, groupsE, profile);
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!eList || !eList.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          attachBfRank(eList, bfRankMap);

          panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORS呼び出し: ${ors} 回\n`;
          panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

          showAlgoListInPanel(panel, eList, 'viterbi_E_cache');
          pushAlgoResultsForCsv('viterbi_E_cache','対策E：Viterbi（2点DP + キャッシュ）',eList,ms,ors,ov);
        }
      } catch (e) {
        console.error('[viterbi_E_cache] error', e);
        panel.textContent += '\n[対策E エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 10）対策F：TopK候補→一気に経由地付きORSで再評価（全件）
    // ----------------------------------------------------------
    if (isAlgoEnabled('dbg_F')) {
      panel.textContent += '\n--- 対策F：TopK候補→一気に経由地付きORSで再評価 ---\n';
      try {
        const orsBefore = API_USED.orsTotal;
        const ovpBefore = API_USED.overpassTotal;

        // ★修正：ここで poiLimit を読み直さない。冒頭の capPerTrigger を使う
        const groupsF = makeCandGroupsFromRestGroups(restGroups, capPerTrigger, defaultLinearSorter);

        const t0 = performance.now();
        const fOpt = getAbViterbiOpt(ui); // A/BのUI流用
        const fList = await runViterbi_F_TopN_ThenFullORS(start, goal, groupsF, profile, fOpt);
        const t1 = performance.now();

        const ms  = t1 - t0;
        const ors = API_USED.orsTotal - orsBefore;
        const ov  = API_USED.overpassTotal - ovpBefore;

        if (!fList || !fList.length) {
          panel.textContent += '(候補なし)\n';
        } else {
          attachBfRank(fList, bfRankMap);

          panel.textContent += `処理時間: ${ms.toFixed(1)} ms\n`;
          panel.textContent += `ORS呼び出し: ${ors} 回\n`;
          panel.textContent += `Overpass呼び出し: ${ov} 回\n\n`;

          showAlgoListInPanel(panel, fList.slice(0,3), 'viterbi_F_fullrerank');
          pushAlgoResultsForCsv('viterbi_F_fullrerank','対策F：TopK→一気にORS再評価',fList,ms,ors,ov);
        }
      } catch (e) {
        console.error('[viterbi_F_fullrerank] error', e);
        panel.textContent += '\n[対策F エラー] ' + (e.message || e) + '\n';
      }
    }

    // ----------------------------------------------------------
    // 全体時間
    // ----------------------------------------------------------
    const totalMs = performance.now() - tAll0;
    panel.textContent += `\n====== 全アルゴリズム処理時間: ${totalMs.toFixed(1)} ms ======\n`;

  } catch (err) {
    console.error('[runAlgoCompareDebug] エラー', err);
    panel.textContent += '\n[runAlgoCompareDebug エラー] ' + (err.message || err);
  }
}
  
function ensureProjections() {
  const base = routeData.arterial || routeData.fastest;
  // ルート情報や休憩グループが存在しない場合は何もしない
  if (!base || !Array.isArray(restGroups) || !restGroups.length) return;

  // ルート上の累積データを構築
  const { cum, coords } = buildCums(base);

  window.__routeCums = { cum, coords };
  window.__cumTotals = {
    D: cum.D.at(-1),
    T: cum.T.at(-1),
    E: cum.E.at(-1)
  };

  // 各休憩グループの POI に射影データを付ける
for (let ti = 0; ti < restGroups.length; ti++){
  const g = restGroups[ti];
  const arr = g?.pois || [];

  for (let pi = 0; pi < arr.length; pi++){
    const p = arr[pi];
    if (!p) continue;

    
    // ★追加：安定IDを埋め込む（毎回同じPOIに同じIDが付く）
    p._triggerId = ti;
    p._poiIdInTrigger = pi;
    // ★ここで「名前が無ければ自動命名」
    ensurePoiName(p, ti, pi);

    // 既に _proj があり cumD が有限値ならスキップ
    if (p._proj && Number.isFinite(p._proj.cumD)) continue;

    // _proj を計算して付与
    p._proj = projectToRoute(p.lat, p.lon, coords, cum);
  }
}
  console.log("[ensureProjections] 射影を再計算しました");
}

// 幹線度（大きいほど“幹線っぽい”）
// ここでは「距離が長くて平均速度が高い＝幹線っぽい」という単純な指標にしています。
function arterialScore(feature){
  if (!feature || !feature.properties || !feature.properties.summary) {
    return -Infinity;
  }

  const sum = feature.properties.summary;
  const distM = Number(sum.distance) || 0;   // m
  const timeS = Number(sum.duration) || 1;   // s（0除算を避けるため 1 で保険）

  const distKm   = distM / 1000;
  const timeH    = timeS / 3600;
  const avgSpeed = distKm / timeH;           // km/h 相当

  // ・平均速度が高いほどプラス
  // ・ある程度の距離があるほどプラス
  // → 幹線道路を長く走るルートほどスコアが大きくなるイメージ
  return avgSpeed * distKm;
}

// 上位3件カードの「この組み合わせでルート表示」から呼ばれる
async function showLinearComboRoute(row){
  if (!row || !Array.isArray(row.picks)) {
    throw new Error('不正な行データ');
  }

  const { start, goal } = getStartGoalPoints();
  const profile = document.getElementById('profileSelect')?.value || 'cycling-road';

  // 経由順は「トリガー順の picks をそのまま」
  const wps = [start, ...row.picks, goal].map(p => ({
    lat: p.lat,
    lon: p.lon,
    name: p.name || 'POI'
  }));

  // ORSでルート生成（既存ヘルパを再利用）
  const out = await routeLegStatsForWaypoints(wps, profile);
  const feature = out?.feature;
  if (!feature) {
    throw new Error('ORS ルート生成に失敗しました');
  }

  // 既存レイヤをクリアして描画
  clearRouteLayers();
  const layer = L.geoJSON(feature, {
    style: { color: '#0096ff', weight: 7 }
  }).addTo(map);
  routeLayers['linearTopRoute'] = layer;

  // 採用POI＆Start/Goalのマーカーを設定（既存関数）
  setComboMarkers(start, row.picks, goal);

  // 収まり調整（getBounds は一度だけ呼んでから isValid() をチェック）
  const bounds = layer.getBounds?.();
  if (bounds && bounds.isValid && bounds.isValid()) {
    map.fitBounds(bounds.pad(0.1));
  } else {
    const fallback = row.picks[0] || start;
    if (fallback) {
      map.flyTo([fallback.lat, fallback.lon], 14);
    }
  }

  // ルート種別ボタンの「active」を全部外しておく（任意）
  setActiveButton(null);
}

function pushAlgoResultsForCsv(algoCode, label, resultList, elapsedMs, orsCalls, overpassCalls){
  if (!Array.isArray(resultList) || !resultList.length) return;
  if (!Array.isArray(window.__algoCompareRows)) window.__algoCompareRows = [];

  const ideals = getIdealPerLegs();
  const sorted = sortResultsByUnifiedScore(resultList, ideals.idealEnergyPerLeg);

  sorted.forEach((r, idx)=>{
    const rank = idx + 1;

    const sigmaDist   = stdDev(r.stats && r.stats.dist ? r.stats.dist : []);
    const sigmaTime   = stdDev(r.stats && r.stats.time ? r.stats.time : []);
    const sigmaEnergy = stdDev(r.stats && r.stats.energy ? r.stats.energy : []);

    const scoreForCsv = unifiedScoreForCompare(r, ideals.idealEnergyPerLeg);

    let poiList = (r.picks || r.picksByTrigger || []).filter(Boolean);
    if (Array.isArray(poiList[0])) poiList = poiList.flat().filter(Boolean);

    const poiNames = poiList.map(p => p.name || 'POI').join(' -> ');
    const poiLatLngs = poiList
      .map(p => `${(p.lat ?? p.latitude)?.toFixed(6)},${(p.lon ?? p.lng ?? p.longitude)?.toFixed(6)}`)
      .filter(Boolean)
      .join(' | ');

    window.__algoCompareRows.push({
      algo: algoCode,
      label,
      rank,
      bfRank: (r.bfRank ?? ''),
      score: scoreForCsv,
      rawScore: r.rawScore,
      sigmaDist,
      sigmaTime,
      sigmaEnergy,
      timeMs: elapsedMs ?? null,
      orsCalls,
      overpassCalls,
      poiNames,
      poiLatLngs
    });
  });
}
  
function showAlgoListInPanel(panel, list, algoCode){
  if (!panel) return;
  if (!Array.isArray(list) || !list.length){
    panel.textContent += '(候補なし)\n';
    return;
  }
  
  const MAX_SHOW = 3;
  const ideals = getIdealPerLegs();
  const sorted = sortResultsByUnifiedScore(list, ideals.idealEnergyPerLeg);
  const top = sorted.slice(0, MAX_SHOW);

  top.forEach((r, idx)=>{
    const rank = idx + 1;

    const score    = r.score    ?? null;
    const rawScore = r.rawScore ?? null;

    const stats   = r.stats || {};
    const distArr = Array.isArray(stats.dist)   ? stats.dist   : [];
    const timeArr = Array.isArray(stats.time)   ? stats.time   : [];
    const eneArr  = Array.isArray(stats.energy) ? stats.energy : [];

    const sigDist = distArr.length ? stdDev(distArr) : null;
    const sigTime = timeArr.length ? stdDev(timeArr) : null;
    const sigEn   = eneArr.length  ? stdDev(eneArr)  : null;

    const picksArr = (r.picks || r.picksByTrigger || []);
    const poiNames = picksArr
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    panel.textContent += `#${rank}  score=${score}\n`;
    if (rawScore != null) panel.textContent += `  rawScore=${rawScore}\n`;

    // ★追加：総当たり順位
    if (r.bfRank != null) {
      panel.textContent += `  bf_rank=${r.bfRank}\n`;
    } else {
      panel.textContent += `  bf_rank=(圏外/不一致)\n`;
    }

    if (sigDist != null) panel.textContent += `  σ距離=${sigDist.toFixed(3)}\n`;
    if (sigTime != null) panel.textContent += `  σ時間=${sigTime.toFixed(3)}\n`;
    if (sigEn   != null) panel.textContent += `  σエネルギー=${sigEn.toFixed(3)}\n`;

    panel.textContent += `  POI: ${poiNames}\n\n`;
  });
}

function downloadAlgoCompareCsv(){
  const rows = window.__algoCompareRows || [];
  if (!rows.length){
    alert('先に「アルゴリズム比較デバッグ」を実行してください');
    return;
  }

  const header = [
    'algo',
    'label',
    'rank',
    'bf_rank',          // ★追加
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'time_ms',
    'ors_calls',
    'overpass_calls',
    'poi_names',
    'poi_latlngs'
  ];

  const bodyRows = rows.map(r => [
    r.algo ?? '',
    `"${csvEscape(r.label ?? '')}"`,
    r.rank ?? '',
    r.bfRank ?? '',     // ★追加
    r.score ?? '',
    r.rawScore ?? '',
    r.sigmaDist ?? '',
    r.sigmaTime ?? '',
    r.sigmaEnergy ?? '',
    r.timeMs ?? '',
    r.orsCalls ?? '',
    r.overpassCalls ?? '',
    `"${csvEscape(r.poiNames ?? '')}"`,
    `"${csvEscape(r.poiLatLngs ?? '')}"`
  ]);

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'algo_compare_debug.csv');
}

function renderBruteforceAllResults(results){
  const box = $('bruteforceAllList');
  const btn = $('btnDownloadBruteforceCsv');
  if (!box) return;

  if (!results || !results.length){
    box.textContent = '（総当たりの結果がありません）';
    if (btn) btn.disabled = true;
    return;
  }

  if (btn) btn.disabled = false;

  window.__bruteforceAllResults = results;
  
  const lines = [];
  results.forEach((r, idx) => {
    const rank = idx + 1;
    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };
    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    lines.push(
      `#${rank} score=${(r.score ?? 0).toFixed(4)} raw=${(r.rawScore ?? r.score ?? 0).toFixed(4)} ` +
      `σd=${sig.dist.toFixed(2)}km σt=${sig.time.toFixed(2)}min σE=${sig.energy.toFixed(1)}kJ`
    );
    lines.push(
      `   picks: ${names}`
    );
  });

  box.textContent = lines.join('\n');
}

function downloadBruteforceCsv(){
  const rows = window.__bruteforceAllResults || [];
  if (!rows.length){
    alert('総当たりがまだ実行されていません');
    return;
  }

  const header = [
    'rank',
    'score',
    'rawScore',
    'sigmaDist_km',
    'sigmaTime_min',
    'sigmaEnergy_kJ',
    'poi_names'
  ];

  const bodyRows = rows.map((r, idx) => {
    const rank = idx + 1;

    const sig = {
      dist: stdDev(r.stats?.dist || []),
      time: stdDev(r.stats?.time || []),
      energy: stdDev(r.stats?.energy || [])
    };

    const names = (r.picks || r.picksByTrigger || [])
      .filter(Boolean)
      .map(p => p.name || 'POI')
      .join(' -> ');

    return [
      rank,
      r.score ?? '',
      r.rawScore ?? '',
      sig.dist.toFixed(3),
      sig.time.toFixed(3),
      sig.energy.toFixed(3),
      `"${csvEscape(names)}"`
    ];
  });

  const blob = buildCsvBlob(header, bodyRows);
  downloadBlob(blob, 'bruteforce_all_combos.csv');
}

// トリガー ↔ POI のビームを全部消す
function clearRestBeams() {
  if (restBeamLayer) {
    restBeamLayer.clearLayers();
  }
}

// restGroups をもとにトリガー ↔ POI のビームを引く
function drawRestBeams() {
  if (!restBeamLayer) return;
  if (!window.restGroups || !Array.isArray(window.restGroups)) return;

  // いったん全部消す
  clearRestBeams();

  window.restGroups.forEach(group => {
    if (!group) return;

    // group.rest に「休憩トリガーの地点」が入っている想定
    const r = group.rest;
    const pois = group.pois || [];
    if (!r || !Array.isArray(pois) || !pois.length) return;

    const baseLat = Number(r.lat);
    const baseLon = Number(r.lon);
    if (!Number.isFinite(baseLat) || !Number.isFinite(baseLon)) return;

    const baseLL = L.latLng(baseLat, baseLon);

    pois.forEach(p => {
      if (!p) return;
      const lat = Number(p.lat);
      const lon = Number(p.lon);
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

      const poiLL = L.latLng(lat, lon);

      // トリガー ↔ POI の直線（道のりビーム）
      const line = L.polyline([baseLL, poiLL], {
        color: 'orange',     // お好みで
        weight: 2,
        opacity: 0.7,
        dashArray: '4,4'     // 点線っぽく
      });

      line.addTo(restBeamLayer);
    });
  });
}

// ---- 対策A：Viterbi風（API）で TopK 候補を作る（ビーム） ----
async function runViterbiTopK_API(start, goal, restGroups, profile, opt = {}) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  // const beamWidth = Math.max(1, Number(opt.beamWidth) || 10); // 各ステップで残す本数
  // const topK      = Math.max(1, Number(opt.topK) || 50);      // 最終候補数
  const ap = autoBeamParams(restGroups, opt);
const beamWidth = ap.beamWidth;
const topK      = ap.topK;

// デバッグしたいなら（任意）
console.log('[autoBeamParams]', ap);


  // ideal 1 leg（既存と同じ）
  const cumTotals = window.__cumTotals || {};
  const totalDkm  = (Number(cumTotals.D) || 0) / 1000;
  const totalTmin = (Number(cumTotals.T) || 0) / 60;
  const totalEkJ  = Number(cumTotals.E)  || 0;
  const R = T + 1;
  const idealDistPerLeg   = R > 0 ? totalDkm  / R : 0;
  const idealTimePerLeg   = R > 0 ? totalTmin / R : 0;
  const idealEnergyPerLeg = R > 0 ? totalEkJ  / R : 0;

  // 事前チェック
  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  // beam state: {cost, idxes:[...], lastPoi}
  let beam = [];

  // step0: start -> group0
  for (let k = 0; k < Klist[0]; k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);
    const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                           idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
    beam.push({ cost: mse, idxes: [k], lastPoi: poi });
  }
  beam.sort((a,b)=>a.cost-b.cost);
  beam = beam.slice(0, beamWidth);

  // step t: group(t-1) -> group(t)
  for (let t = 1; t < T; t++){
    const next = [];
    const curGroup = restGroups[t];

    for (const st of beam){
      for (let j = 0; j < curGroup.length; j++){
        const toPoi = curGroup[j];
        const leg = await calcLegCostWithApi(st.lastPoi, toPoi, profile);
        const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                               idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
        next.push({ cost: st.cost + mse, idxes: [...st.idxes, j], lastPoi: toPoi });
      }
    }
    next.sort((a,b)=>a.cost-b.cost);
    beam = next.slice(0, beamWidth);
  }

  // last -> goal
  const finals = [];
  for (const st of beam){
    const leg = await calcLegCostWithApi(st.lastPoi, goal, profile);
    const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                           idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
    finals.push({ cost: st.cost + mse, idxes: st.idxes });
  }
  finals.sort((a,b)=>a.cost-b.cost);

  // idxes から picks を復元して返す（ここではまだ “近似cost”）
  const cand = finals.slice(0, topK).map(x=>{
    const picksByTrigger = x.idxes.map((j, t)=> restGroups[t][j]);
    return {
      approxScore: x.cost,
      picksByTrigger,
      picks: picksByTrigger.filter(Boolean)
    };
  });

  return cand;
}

// ======================================================
// 共通：TopK候補（runViterbiTopK_APIの返り値）を
// 1) 重複排除（任意）
// 2) ORSで stats を作り直して energyMSE で再評価
// 3) 並べ替え
// 4) 1本返す or 全件返す を切替
// ======================================================
async function rerankTopKCandsByExactScore(start, goal, candList, profile, opt = {}){
  const list = Array.isArray(candList) ? candList : [];
  if (!list.length) return [];

  const ideals = getIdealPerLegs();
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const doDedupe = !!opt.dedupe;
  const returnAll = !!opt.returnAll;

  // 1) 重複排除（任意）
  let work = list;
  if (doDedupe){
    const seen = new Set();
    const uniq = [];
    for (const c of list){
      const key = comboKeyFromPicksByTrigger(c && c.picksByTrigger, 6);
      if (seen.has(key)) continue;
      seen.add(key);
      uniq.push(c);
    }
    work = uniq;
  }
  if (!work.length) return [];

  // 2) ORSで正確なstatsを作って energyMSE で再評価
  const rescored = [];
  for (const c of work){
    try{
      const picks = Array.isArray(c && c.picks) ? c.picks : [];
      const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
      const out = await routeLegStatsForWaypoints(wps, profile);
      const feature = out && out.feature ? out.feature : null;
      const stats = out && out.stats ? out.stats : null;

      const score = (stats ? routeEnergyMseFromStats(stats, idealEnergyPerLeg) : NaN);

      rescored.push({
        score: score,
        rawScore: c.approxScore,
        feature,
        stats,
        picks,
        picksByTrigger: c.picksByTrigger
      });
    }catch(e){
      console.warn('[rerankTopKCandsByExactScore] candidate fail', e);
    }
  }

  if (!rescored.length) return [];

  // 3) scoreで並べ替え（NaNは後ろへ）
  rescored.sort((a,b)=>{
    const sa = unifiedScoreForCompare(a, idealEnergyPerLeg);
    const sb = unifiedScoreForCompare(b, idealEnergyPerLeg);
    return sa - sb;
  });

  // 4) 返す形を切替
  return returnAll ? rescored : [rescored[0]];
}

// ---- 対策A：TopKを総量MSEで再ランキングして “1本” だけ返す ----
async function runViterbiTopK_Rerank_API(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: false,
    returnAll: false
  });
}
  
function legL1Cost(d, t, e, ideald, idealt, ideale){
  return Math.abs(d-ideald) + Math.abs(t-idealt) + Math.abs(e-ideale);
}
  
async function runViterbiOnce_API_L1(start, goal, restGroups, profile) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  const cumTotals = window.__cumTotals || {};
  const totalDkm  = (Number(cumTotals.D) || 0) / 1000;
  const totalTmin = (Number(cumTotals.T) || 0) / 60;
  const totalEkJ  = Number(cumTotals.E)  || 0;

  const R = T + 1;
  const idealDistPerLeg   = R > 0 ? totalDkm  / R : 0;
  const idealTimePerLeg   = R > 0 ? totalTmin / R : 0;
  const idealEnergyPerLeg = R > 0 ? totalEkJ  / R : 0;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  const dp=[], prev=[];
  for(let t=0;t<T;t++){
    dp[t]=new Array(Klist[t]).fill(Infinity);
    prev[t]=new Array(Klist[t]).fill(-1);
  }

  // start -> 0
  for (let k=0;k<Klist[0];k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApi(start, poi, profile);
    const c = legL1Cost(leg.distKm, leg.timeMin, leg.energyKj,
                        idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
    dp[0][k]=c;
  }

  // t-1 -> t
  for (let t=1;t<T;t++){
    for (let j=0;j<Klist[t];j++){
      const toPoi = restGroups[t][j];
      let best=Infinity, bestIdx=-1;

      for (let i=0;i<Klist[t-1];i++){
        if (!Number.isFinite(dp[t-1][i])) continue;
        const fromPoi = restGroups[t-1][i];
        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);
        const c = legL1Cost(leg.distKm, leg.timeMin, leg.energyKj,
                            idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
        const cand = dp[t-1][i] + c;
        if (cand < best){ best=cand; bestIdx=i; }
      }
      dp[t][j]=best;
      prev[t][j]=bestIdx;
    }
  }

  // last -> goal
  const lastT=T-1;
  let bestFinal=Infinity, bestIdx=-1;
  for (let k=0;k<Klist[lastT];k++){
    if (!Number.isFinite(dp[lastT][k])) continue;
    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApi(poi, goal, profile);
    const c = legL1Cost(leg.distKm, leg.timeMin, leg.energyKj,
                        idealDistPerLeg, idealTimePerLeg, idealEnergyPerLeg);
    const cand = dp[lastT][k] + c;
    if (cand < bestFinal){ bestFinal=cand; bestIdx=k; }
  }
  if (bestIdx<0) return [];

  // 復元
  const picks=new Array(T);
  let cur=bestIdx;
  for(let t=lastT;t>=0;t--){
    picks[t]=restGroups[t][cur];
    cur=prev[t][cur];
  }

  // 統計（既存と同じ）
  let feature=null, stats={dist:[],time:[],energy:[]};
  try{
    const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out.feature;
    if(out.stats) stats = out.stats;
  }catch(e){
    console.warn('[Viterbi_L1] stats build fail', e);
  }

  return [{
    score: bestFinal,     // ← L1最適化のスコア
    rawScore: bestFinal,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// -------------------------------
// bf_rank 付与用：組合せキー生成
//  - picksByTrigger を前提に「トリガー順」を固定して比較
//  - POI同一判定は lat/lon を丸めて文字列化（誤差吸収）
// -------------------------------
function comboKeyFromPicksByTrigger(picksByTrigger, decimals = 6){
  const arr = Array.isArray(picksByTrigger) ? picksByTrigger : [];
  const f = (x)=> Number(x).toFixed(decimals);

  return arr.map(p=>{
    if(!p) return 'null';
    const lat = (p.lat ?? p.latitude);
    const lon = (p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

// bfList（総当たり結果）から rank マップを作る
function buildBfRankMap(bfList){
  const map = new Map();
  (bfList || []).forEach((r, idx)=>{
    const key = comboKeyFromPicksByTrigger(r.picksByTrigger);
    // 同一キーが複数出ても「最上位」を採用
    if(!map.has(key)) map.set(key, idx + 1);
  });
  return map;
}

// 任意アルゴ結果に bfRank を付与（見つからなければ null）
function attachBfRank(resultList, bfRankMap){
  if(!bfRankMap || !(bfRankMap instanceof Map)) return resultList;
  if(!Array.isArray(resultList)) return resultList;

  resultList.forEach(r=>{
    const pbt = Array.isArray(r.picksByTrigger) ? r.picksByTrigger
              : Array.isArray(r.picks) ? r.picks
              : null;

    const key = pbt ? comboKeyFromPicksByTrigger(pbt) : 'bad';
    r.bfRank = bfRankMap.has(key) ? bfRankMap.get(key) : null;
  });
  return resultList;
}

function autoBeamParams(restGroups, opt = {}){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;

  // 各トリガー候補数（配列の配列を想定）
  const Klist = (Array.isArray(restGroups) ? restGroups : []).map(g => Array.isArray(g) ? g.length : 0);
  const Kmin = Klist.length ? Math.min(...Klist) : 0;
  const Kavg = Klist.length ? (Klist.reduce((a,b)=>a+b,0) / Klist.length) : 0;

  // --- ベース：Tが増えるほど少しだけ広げる（爆発させない） ---
  let beamWidth =
      (T <= 1) ? 12 :
      (T === 2) ? 18 :
      (T === 3) ? 24 :
      (T === 4) ? 30 :
      (T === 5) ? 36 :
                 40; // 6以上は上限

  // 候補が少ないならビームを広げても意味が薄いので抑える
  // 逆に候補が多いときは少し増やす
  if (Kavg <= 3) beamWidth = Math.min(beamWidth, 18);
  if (Kavg >= 10) beamWidth = Math.min(CFG.viterbi.autoBeam.maxBeamWidth, Math.floor(beamWidth * 1.25));

  // beamWidth は「各段で残す本数」なので、各トリガー候補より大きくしてもムダになりがち
  // 目安として Kmin*3 くらいを上限にしておく（Kminが小さいときの無駄防止）
  if (Kmin > 0) beamWidth = Math.min(beamWidth, Kmin * 3);

  // --- topK：最終候補数。Tが増えるほど少し増やすが上限付き ---
  let topK =
      (T <= 1) ? 30 :
      (T === 2) ? 60 :
      (T === 3) ? 90 :
      (T === 4) ? 120 :
      (T === 5) ? 150 :
                 180; // 6以上は上限

  // rerank をするなら topK は大きすぎると ORS 追加呼び出しが増えがち → 上限
  topK = Math.min(topK, CFG.viterbi.autoBeam.maxTopK);

  // --- ユーザー指定があれば優先（明示指定は最強） ---
  if (opt.beamWidth != null) beamWidth = Math.max(1, Number(opt.beamWidth) || 1);
  if (opt.topK != null)      topK      = Math.max(1, Number(opt.topK) || 1);

  return { beamWidth, topK, T, Kmin, Kavg };
}

// ---- 対策B：TopKを重複排除してから総量MSEで再ランキング（API） ----
async function runViterbiTopK_Rerank_API_Dedupe(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: false
  });
}

// ---- 対策A(全件)：TopKを総量MSEで再ランキング（全件返す・重複排除なし） ----
async function runViterbiTopK_Rerank_All_API(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: false,
    returnAll: true
  });
}

function routeEnergyMseFromStats(stats, idealEnergyPerLeg){
  const eArr = stats && Array.isArray(stats.energy) ? stats.energy : [];
  const n = eArr.length;
  if (!n) return NaN;

  let sum = 0;
  for (let i = 0; i < n; i++){
    const ei = Number(eArr[i]);
    const de = (Number.isFinite(ei) ? ei : 0) - idealEnergyPerLeg;
    sum += de * de;
  }
  return sum / n;
}

function defaultLinearSorter(a, b){
  const score = p =>
    (Number(p?.distFromTriggerM) || 0) +
    (Number(p?._proj?.perpM) || 0);
  return score(a) - score(b);
}

function sumNums(arr){
  return (arr || []).reduce((a,b)=>a + (Number(b)||0), 0);
}

function finalScoreFromStats(stats, ideals){
  // 今の方針：レグごとの energy 均等性
  return routeEnergyMseFromStats(stats, ideals.idealEnergyPerLeg);
}

// ======================================================
// 共通：理想レグ（ideal per leg）を計算
// ======================================================
function getIdealPerLegs(){
  const cumTotals = window.__cumTotals || {};
  const totalDkm  = (Number(cumTotals.D) || 0) / 1000;
  const totalTmin = (Number(cumTotals.T) || 0) / 60;
  const totalEkJ  = Number(cumTotals.E)  || 0;

  const T = Array.isArray(window.restGroups) ? window.restGroups.length : 0;
  const R = T + 1;

  return {
    totalDkm, totalTmin, totalEkJ,
    T, R,
    idealDistPerLeg:   R > 0 ? totalDkm  / R : 0,
    idealTimePerLeg:   R > 0 ? totalTmin / R : 0,
    idealEnergyPerLeg: R > 0 ? totalEkJ  / R : 0,
  };
}

// ======================================================
// 共通：比較用のスコア（並び順・CSV・表示を一致させる）
// stats があれば energyMSE を最優先（総当たりと同じ土俵）
// ======================================================
function unifiedScoreForCompare(r, idealEnergyPerLeg){
  const e = (r && r.stats) ? routeEnergyMseFromStats(r.stats, idealEnergyPerLeg) : NaN;
  if (Number.isFinite(e)) return e;

  const s = Number(r && r.score);
  if (Number.isFinite(s)) return s;

  const rs = Number(r && r.rawScore);
  if (Number.isFinite(rs)) return rs;

  return Infinity;
}

// 共通：破壊しないソート（元配列を壊さない）
function sortResultsByUnifiedScore(list, idealEnergyPerLeg){
  const arr = Array.isArray(list) ? list : [];
  return arr.slice().sort((a,b)=>{
    return unifiedScoreForCompare(a, idealEnergyPerLeg) - unifiedScoreForCompare(b, idealEnergyPerLeg);
  });
}

async function runViterbiTopK_Rerank_All_API_Dedupe(start, goal, restGroups, profile, opt = {}){
  const topKList = await runViterbiTopK_API(start, goal, restGroups, profile, opt);
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: true
  });
}

function getAbViterbiOpt(ui){
  ui = ui || readUI();

  // ✅ auto=trueでも "明示パラメータ" を返す（autoBeamParams側に行かせない狙い）
  // ※runViterbiTopK_API が opt.beamWidth / opt.topK を優先して使う実装なら効果あり
  const opt = {};

  const bw = ui.ab.beamWidth;
  const tk = ui.ab.topK;

  // auto=true のときは UI値が空でも CFGのデフォルトに落とす
  if (ui.ab.auto) {
    opt.beamWidth = Number.isFinite(bw) && bw > 0 ? bw : (CFG?.viterbi?.beamWidthDefault ?? 40);
    opt.topK      = Number.isFinite(tk) && tk > 0 ? tk : (CFG?.viterbi?.topKDefault ?? 150);
    return opt;
  }

  // auto=false の通常挙動
  if (Number.isFinite(bw) && bw > 0) opt.beamWidth = bw;
  if (Number.isFinite(tk) && tk > 0) opt.topK = tk;
  return opt;
}

// lat/lon正規化（揺れ吸収）
function normLL(p){
  if(!p) return null;
  const lat = Number(p.lat ?? p.latitude ?? p.y);
  const lon = Number(p.lon ?? p.lng ?? p.longitude ?? p.x);
  if(!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
  return { lat, lon };
}

function distMeters(a, b){
  const A = normLL(a), B = normLL(b);
  if(!A || !B) return Infinity;

  if (window.L && L.latLng){
    return L.latLng(A.lat, A.lon).distanceTo(L.latLng(B.lat, B.lon));
  }
  // 簡易フォールバック（雑でOK）
  const dx = (A.lat - B.lat) * 111320;
  const dy = (A.lon - B.lon) * 111320;
  return Math.hypot(dx, dy);
}

// start/goalに近い端トリガーをwaypointsに差し込むか判断
function maybeEndTriggersAsWaypoints(start, goal, restGroups, opt){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!T) return { addStartTrig:false, addGoalTrig:false, startTrig:null, goalTrig:null };

  const thr = Number(opt?.adjacentMeters) || 80;

  const startTrig = restGroups[0]?.rest || null;
  const goalTrig  = restGroups[T-1]?.rest || null;

  const addStartTrig = !!(opt?.includeEndTriggers && startTrig && distMeters(start, startTrig) <= thr);
  const addGoalTrig  = !!(opt?.includeEndTriggers && goalTrig  && distMeters(goal,  goalTrig)  <= thr);

  return { addStartTrig, addGoalTrig, startTrig, goalTrig };
}

// 表示・stats計算用のwaypointsを作る（必要なら端トリガーを差し込む）
function buildWaypointsForRoute(start, goal, picks, restGroups, opt){
  const ends = maybeEndTriggersAsWaypoints(start, goal, restGroups, opt);

  const wps = [];
  wps.push(start);

  if (ends.addStartTrig) wps.push(ends.startTrig);

  (picks || []).forEach(p=>{ if (p) wps.push(p); });

  if (ends.addGoalTrig) wps.push(ends.goalTrig);

  wps.push(goal);

  // ORS入力用に lat/lon を確実化
  return wps.map(p => {
    const ll = normLL(p) || {lat:NaN, lon:NaN};
    return {
      lat: ll.lat,
      lon: ll.lon,
      name: p?.name || 'POI'
    };
  });
}

async function runViterbiOnce_API_C(start, goal, restGroups, profile, opt = {}) {
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (!Number.isInteger(T) || T <= 0) return [];

  const ideals = getIdealPerLegs();
  const idealDistPerLeg   = ideals.idealDistPerLeg;
  const idealTimePerLeg   = ideals.idealTimePerLeg;
  const idealEnergyPerLeg = ideals.idealEnergyPerLeg;

  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => !Number.isInteger(k) || k <= 0)) return [];

  const dp   = [];
  const prev = [];
  for (let t = 0; t < T; t++) {
    dp[t]   = new Array(Klist[t]).fill(Infinity);
    prev[t] = new Array(Klist[t]).fill(-1);
  }

  // ★対策C：端（start→1st / last→goal）をDPスコアから除外
  // dp[0][k] は全部0スタート
  for (let k = 0; k < Klist[0]; k++) dp[0][k] = 0;

  // ★トリガー間だけ評価（t-1 → t）
  for (let t = 1; t < T; t++) {
    const curGroup  = restGroups[t];
    const prevGroup = restGroups[t - 1];

    for (let j = 0; j < Klist[t]; j++) {
      const toPoi = curGroup[j];

      let bestCost = Infinity;
      let bestIdx  = -1;

      for (let i = 0; i < Klist[t - 1]; i++) {
        const prevCost = dp[t - 1][i];
        if (!Number.isFinite(prevCost)) continue;

        const fromPoi = prevGroup[i];
        const leg = await calcLegCostWithApi(fromPoi, toPoi, profile);

        const mse = legMseCost(
          leg.distKm,
          leg.timeMin,
          leg.energyKj,
          idealDistPerLeg,
          idealTimePerLeg,
          idealEnergyPerLeg
        );

        const cand = prevCost + mse;
        if (cand < bestCost) {
          bestCost = cand;
          bestIdx  = i;
        }
      }

      dp[t][j]   = bestCost;
      prev[t][j] = bestIdx;
    }
  }

  // ★最後→goalも足さない：dp[last] の最小を採用
  const lastT = T - 1;
  let bestFinalCost = Infinity;
  let bestFinalIdx  = -1;
  for (let k = 0; k < Klist[lastT]; k++){
    const v = dp[lastT][k];
    if (Number.isFinite(v) && v < bestFinalCost){
      bestFinalCost = v;
      bestFinalIdx = k;
    }
  }
  if (bestFinalIdx < 0 || !Number.isFinite(bestFinalCost)) return [];

  // 復元
  const picks = new Array(T);
  let curIdx  = bestFinalIdx;
  for (let t = lastT; t >= 0; t--) {
    picks[t] = restGroups[t][curIdx];
    curIdx   = prev[t][curIdx];
  }

  // ★表示・CSV用：完全経路(start..goal)で1回だけstatsを作る
  let feature = null;
  let stats   = { dist:[], time:[], energy:[] };
  let finalScore = bestFinalCost; // フォールバック

  try {
    // 端トリガーを条件で差し込む（ここが「先ほどのC」）
    const wps = buildWaypointsForRoute(start, goal, picks, window.restGroups, opt);

    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if (out?.stats) stats = out.stats;

    const exact = finalScoreFromStats(stats, { idealEnergyPerLeg });
    if (Number.isFinite(exact)) finalScore = exact;
  } catch (e) {
    console.warn('[Viterbi_C] stats build fail', e);
  }

  return [{
    score: finalScore,       // 表示・比較はこっち（総当たりと同じ土俵）
    rawScore: bestFinalCost, // DP近似（端除外）
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// ======================================================
// NEW 対策C（置き換え案）:
//  - DPではなく Beam（近似）
//  - 各段で「start + これまでのpicks + 次候補 (+ goal)」を1回のORSで評価
//  - beamWidth 本だけ残す
//  - キャッシュで同じwaypoints列の再計算を避ける
// ======================================================
function wpsKey(points, decimals = 6){
  const f = (x)=> Number(x).toFixed(decimals);
  return (points || []).map(p=>{
    if(!p) return 'null';
    const lat = Number(p.lat ?? p.latitude);
    const lon = Number(p.lon ?? p.lng ?? p.longitude);
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) return 'bad';
    return `${f(lat)},${f(lon)}`;
  }).join('||');
}

async function orsRouteCached(wps, profile, cache){
  const key = wpsKey(wps, 6);
  if (cache && cache.has(key)) return cache.get(key);

  const out = await routeLegStatsForWaypoints(
    wps.map(p=>({ lat:p.lat, lon:p.lon, name:p.name || 'POI' })),
    profile
  );

  const packed = {
    key,
    feature: out?.feature || null,
    stats: out?.stats || null
  };

  if (cache) cache.set(key, packed);
  return packed;
}

// ★ 対策C（Beam + 経由地増やすORS）
async function runViterbiOnce_API_C_BeamFull(start, goal, groups, profile, opt = {}){
  const T = Array.isArray(groups) ? groups.length : 0;
  if (!T) return [];

  const beamWidth = Math.max(1, Number(opt.beamWidth) || 12);

  // スコアは「最終経路statsから energyMSE」を優先（既存方針に合わせる）
  const ideals = getIdealPerLegs();

  // ORS結果キャッシュ（同じwaypoints列は二度呼ばない）
  const cache = new Map();

  // beam state:
  // { score, picks, picksByTrigger, feature, stats }
  let beam = [];

  // --- t=0（最初のトリガー候補を展開） ---
  for (let j = 0; j < groups[0].length; j++){
    const p0 = groups[0][j];
    const wps0 = [start, p0]; // まだgoalは入れない
    const out0 = await orsRouteCached(wps0, profile, cache);

    // ※中間段はstatsが「最後まで」じゃないので、暫定スコアとして energyMSE を使う
    //   ここは「距離/時間/エネルギーの部分MSE」でもOKだが、まずは簡単に統一スコアで。
    const s0 = (out0.stats ? finalScoreFromStats(out0.stats, ideals) : Infinity);

    beam.push({
      score: Number.isFinite(s0) ? s0 : Infinity,
      picks: [p0],
      picksByTrigger: [p0],
      feature: out0.feature,
      stats: out0.stats
    });
  }

  beam.sort((a,b)=>a.score-b.score);
  beam = beam.slice(0, beamWidth);

  // --- t=1..T-1 ---
  for (let t = 1; t < T; t++){
    const next = [];

    for (const st of beam){
      for (let j = 0; j < groups[t].length; j++){
        const pt = groups[t][j];
        const picks = [...st.picks, pt];

        // 最後のトリガーなら goal まで含めて “完成形” を評価
        const wps = (t === T-1)
          ? [start, ...picks, goal]
          : [start, ...picks];

        try{
          const out = await orsRouteCached(wps, profile, cache);
          const s = (out.stats ? finalScoreFromStats(out.stats, ideals) : Infinity);

          next.push({
            score: Number.isFinite(s) ? s : Infinity,
            picks,
            picksByTrigger: picks, // トリガー順の列
            feature: out.feature,
            stats: out.stats
          });
        }catch(e){
          // 失敗は捨てる
          console.warn('[C_BeamFull] expand fail', e);
        }
      }
    }

    if (!next.length) return [];

    next.sort((a,b)=>a.score-b.score);
    beam = next.slice(0, beamWidth);
  }

  // beam[0] が最良（完成形）
  return beam.length ? [beam[0]] : [];
}

function buildVitGroupsWithFixedRest(restGroups, capPerTrigger, variableCount, sorter){
  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  const out = [];

  for (let i = 0; i < T; i++){
    const g = restGroups[i];

    if (i < variableCount){
      // 場合分けする
      let pois = Array.isArray(g?.pois) ? g.pois.slice() : [];
      if (typeof sorter === 'function') pois.sort(sorter);
      pois = pois.slice(0, capPerTrigger);

      out.push(pois);
    } else {
      // 固定する: トリガー地点を候補1個として入れる
      const r = g?.rest;
      out.push(r ? [r] : []);
    }
  }
  return out;
}

async function runViterbi_D_Progressive(start, goal, restGroups, profile, opt = {}){
  const capPerTrigger = Math.max(1, Number(opt.capPerTrigger) || 5);
  const sorter = opt.sorter || null;

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  const allResults = [];

  for (let variableCount = 1; variableCount <= T; variableCount++){
    const vitGroups = buildVitGroupsWithFixedRest(
      restGroups,
      capPerTrigger,
      variableCount,
      sorter
    );

    const list = await runViterbiOnce_API(start, goal, vitGroups, profile);
    const best = (Array.isArray(list) && list.length) ? list[0] : null;

    allResults.push({
      variableCount,
      best
    });
  }

  return allResults;
}

// 名前が無いPOIに POI{triggerIndex}.{id} を付ける
function ensurePoiName(poi, triggerIndex, idInTrigger){
  if (!poi) return poi;

  const raw = (poi.name ?? poi.label ?? poi.title ?? '').toString().trim();

  // ★「不明扱い」判定を追加：空文字だけでなく 'POI' / 'poi' も置換対象にする
  const isUnknown =
    !raw ||
    /^poi$/i.test(raw) ||                 // "POI" だけ
    /^poi[_\-\s]*$/i.test(raw);           // "POI_" みたいなのも一応

  if (!isUnknown) return poi;

  poi.name = `POI${triggerIndex}_${idInTrigger}`; // 0始まり
  return poi;
}

// ======================================================
// 2点区間ORSのキャッシュ（同じfrom/to/profileなら再利用）
// ======================================================
const __legCache = new Map();

function legKey(from, to, profile, decimals=6){
  const f = x => Number(x).toFixed(decimals);
  const aLat = from?.lat ?? from?.latitude ?? from?.y;
  const aLon = from?.lon ?? from?.lng ?? from?.longitude ?? from?.x;
  const bLat = to?.lat   ?? to?.latitude   ?? to?.y;
  const bLon = to?.lon   ?? to?.lng ?? to?.longitude ?? to?.x;
  return `${profile}::${f(aLat)},${f(aLon)}=>${f(bLat)},${f(bLon)}`;
}

async function calcLegCostWithApiCached(from, to, profile){
  const key = legKey(from, to, profile);
  if (__legCache.has(key)) return __legCache.get(key);

  const leg = await calcLegCostWithApi(from, to, profile);
  __legCache.set(key, leg);
  return leg;
}

// ======================================================
// 対策E：Viterbi（2点DP）+ 2点区間キャッシュ
//   - 最適性は維持
//   - “同じ区間の重複呼び出し”が減るとAPI回数が減る
// ======================================================
async function runViterbiOnce_API_E_Cached(start, goal, restGroups, profile){
  // ここは runViterbiOnce_API をコピって
  // calcLegCostWithApi(...) を calcLegCostWithApiCached(...) に置換するだけでOK

  const T = Array.isArray(restGroups) ? restGroups.length : 0;
  if (T <= 0) return [];

  const ideals = getIdealPerLegs();
  const Klist = restGroups.map(g => Array.isArray(g) ? g.length : 0);
  if (Klist.some(k => k <= 0)) return [];

  const dp=[], prev=[];
  for(let t=0;t<T;t++){
    dp[t]=new Array(Klist[t]).fill(Infinity);
    prev[t]=new Array(Klist[t]).fill(-1);
  }

  // start -> 0
  for (let k=0;k<Klist[0];k++){
    const poi = restGroups[0][k];
    const leg = await calcLegCostWithApiCached(start, poi, profile);
    const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                           ideals.idealDistPerLeg, ideals.idealTimePerLeg, ideals.idealEnergyPerLeg);
    dp[0][k]=mse;
  }

  // t-1 -> t
  for (let t=1;t<T;t++){
    for (let j=0;j<Klist[t];j++){
      const toPoi = restGroups[t][j];
      let best=Infinity, bestIdx=-1;

      for (let i=0;i<Klist[t-1];i++){
        if (!Number.isFinite(dp[t-1][i])) continue;
        const fromPoi = restGroups[t-1][i];
        const leg = await calcLegCostWithApiCached(fromPoi, toPoi, profile);
        const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                               ideals.idealDistPerLeg, ideals.idealTimePerLeg, ideals.idealEnergyPerLeg);
        const cand = dp[t-1][i] + mse;
        if (cand < best){ best=cand; bestIdx=i; }
      }
      dp[t][j]=best;
      prev[t][j]=bestIdx;
    }
  }

  // last -> goal
  const lastT=T-1;
  let bestFinal=Infinity, bestIdx=-1;
  for (let k=0;k<Klist[lastT];k++){
    if (!Number.isFinite(dp[lastT][k])) continue;
    const poi = restGroups[lastT][k];
    const leg = await calcLegCostWithApiCached(poi, goal, profile);
    const mse = legMseCost(leg.distKm, leg.timeMin, leg.energyKj,
                           ideals.idealDistPerLeg, ideals.idealTimePerLeg, ideals.idealEnergyPerLeg);
    const cand = dp[lastT][k] + mse;
    if (cand < bestFinal){ bestFinal=cand; bestIdx=k; }
  }
  if (bestIdx<0) return [];

  // 復元
  const picks=new Array(T);
  let cur=bestIdx;
  for(let t=lastT;t>=0;t--){
    picks[t]=restGroups[t][cur];
    cur=prev[t][cur];
  }

  // 表示用 stats を1回作る
  let feature=null, stats={dist:[],time:[],energy:[]};
  try{
    const wps = [start, ...picks, goal].map(p=>({lat:p.lat, lon:p.lon, name:p.name||'POI'}));
    const out = await routeLegStatsForWaypoints(wps, profile);
    feature = out?.feature || null;
    if(out?.stats) stats = out.stats;
  }catch(e){}

  return [{
    score: finalScoreFromStats(stats, { idealEnergyPerLeg: ideals.idealEnergyPerLeg }),
    rawScore: bestFinal,
    feature,
    stats,
    picks,
    picksByTrigger: picks
  }];
}

// ======================================================
// 対策F：TopK候補を作ってから “一気に経由地付きORS”で再評価
//   - TopK生成は近似（ビーム）
//   - 最終順位は routeLegStatsForWaypoints の1回呼びで確定
// ======================================================
async function runViterbi_F_TopN_ThenFullORS(start, goal, groups, profile, opt = {}){
  // 1) 近似でTopK候補（ビーム）
  const topKList = await runViterbiTopK_API(start, goal, groups, profile, opt);

  // 2) 一気に経由地付きORSで再評価（既存）
  // returnAll=true にすると “再評価済み一覧” が取れる
  return await rerankTopKCandsByExactScore(start, goal, topKList, profile, {
    dedupe: true,
    returnAll: true
  });
}

function isAlgoEnabled(id){
  const el = document.getElementById(id);
  return !!(el && el.checked);
}

function applyAutoNamesToAllPois(){
  if (!Array.isArray(restGroups)) return;

  for (let ti = 0; ti < restGroups.length; ti++){
    const arr = restGroups[ti]?.pois || [];
    for (let pi = 0; pi < arr.length; pi++){
      const p = arr[pi];
      if (!p) continue;

      // 安定ID（任意：おすすめ）
      p._triggerId = ti;
      p._poiIdInTrigger = pi;

      // 名前が無ければ POI{ti}_{pi}
      ensurePoiName(p, ti, pi);
    }
  }
}

// ===============================
// ★ 追加：UI値をまとめて読む（ID変更に強くする）
// ===============================
function readUI(){
  // ✅ CFG が無くても動くデフォルト
  const DEFAULT_CAP_PER_TRIGGER = 5;     // poiLimit 未入力・壊れてた時の保険
  const DEFAULT_PROFILE = 'cycling-road';

  const poiLimitRaw = Number(document.getElementById('poiLimit')?.value);
  const poiLimit = Math.max(
    1,
    Number.isFinite(poiLimitRaw) ? Math.floor(poiLimitRaw) : DEFAULT_CAP_PER_TRIGGER
  );

  // profileSelect が無い場合もあるので保険
  const profile = document.getElementById('profileSelect')?.value || DEFAULT_PROFILE;

  const abAuto = !!document.getElementById('abAutoParams')?.checked;
  const abBeamWidth = Number(document.getElementById('abBeamWidth')?.value);
  const abTopK = Number(document.getElementById('abTopK')?.value);

  return {
    poiLimit,
    profile,
    ab: {
      auto: abAuto,
      beamWidth: Number.isFinite(abBeamWidth) ? Math.floor(abBeamWidth) : null,
      topK: Number.isFinite(abTopK) ? Math.floor(abTopK) : null,
    }
  };
}
</script>
</body>
</html>







